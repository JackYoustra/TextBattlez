; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

	TITLE	C:\Users\jack\Documents\Visual Studio 2012\Projects\Battelz\Main\Source.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?value@?$_Gcd@$0PECEA@$00@std@@2_JB		; std::_Gcd<1000000,1>::value
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?num@?$ratio@$0PECEA@$00@std@@2_JB		; std::ratio<1000000,1>::num
PUBLIC	?den@?$ratio@$0PECEA@$00@std@@2_JB		; std::ratio<1000000,1>::den
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?value@?$_Is_duration@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@@chrono@std@@2_NB ; std::chrono::_Is_duration<std::chrono::duration<__int64,std::ratio<1,1000000000> > >::value
PUBLIC	?value@?$integral_constant@H$0A@@std@@2HB	; std::integral_constant<int,0>::value
PUBLIC	?value@?$_Is_ratio@U?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@2_NB ; std::chrono::_Is_ratio<std::ratio<1,1000000000> >::value
PUBLIC	?value@?$_Abs@$0GE@@std@@2_JB			; std::_Abs<100>::value
PUBLIC	?value@?$_GcdX@$00$0DLJKMKAA@@std@@2_JB		; std::_GcdX<1,1000000000>::value
PUBLIC	?value@?$_Abs@$0DLJKMKAA@@std@@2_JB		; std::_Abs<1000000000>::value
PUBLIC	?value@?$_Gcd@$00$0DLJKMKAA@@std@@2_JB		; std::_Gcd<1,1000000000>::value
PUBLIC	?num@?$ratio@$00$0DLJKMKAA@@std@@2_JB		; std::ratio<1,1000000000>::num
PUBLIC	?value@?$_Is_duration@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@@chrono@std@@2_NB ; std::chrono::_Is_duration<std::chrono::duration<__int64,std::ratio<1,1> > >::value
PUBLIC	?den@?$ratio@$00$0DLJKMKAA@@std@@2_JB		; std::ratio<1,1000000000>::den
PUBLIC	?value@?$_GcdX@$0GE@$0A@@std@@2_JB		; std::_GcdX<100,0>::value
PUBLIC	?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB	; std::_GcdX<1000000000,100>::value
PUBLIC	?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
PUBLIC	?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_GcdX<100,1000000000>::value
PUBLIC	?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
PUBLIC	?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
PUBLIC	?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
PUBLIC	?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB	; std::_Gcd<100,1000000000>::value
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
PUBLIC	?value@?$_Abs@$00@std@@2_JB			; std::_Abs<1>::value
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$00$0DLJKMKAA@@std@@U?$ratio@$00$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,1000000000>,std::ratio<1,1> >::_G1
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$00$0DLJKMKAA@@std@@U?$ratio@$00$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,1000000000>,std::ratio<1,1> >::_G2
PUBLIC	?value@?$_GcdX@$00$0A@@std@@2_JB		; std::_GcdX<1,0>::value
PUBLIC	?value@?$_GcdX@$00$00@std@@2_JB			; std::_GcdX<1,1>::value
PUBLIC	?value@?$_Gcd@$00$00@std@@2_JB			; std::_Gcd<1,1>::value
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_monotonic@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_monotonic
PUBLIC	?is_steady@system_clock@chrono@std@@2_NB	; std::chrono::system_clock::is_steady
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?value@?$_Always_false@_J@std@@2_NB		; std::_Always_false<__int64>::value
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$00$00@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,1>,std::ratio<1000000000,1> >::_G1
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?value@?$_GcdX@$0DLJKMKAA@$00@std@@2_JB		; std::_GcdX<1000000000,1>::value
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?value@?$_Gcd@$0DLJKMKAA@$00@std@@2_JB		; std::_Gcd<1000000000,1>::value
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$00$00@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,1>,std::ratio<1000000000,1> >::_G2
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?num@?$ratio@$0DLJKMKAA@$00@std@@2_JB		; std::ratio<1000000000,1>::num
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?den@?$ratio@$0DLJKMKAA@$00@std@@2_JB		; std::ratio<1000000000,1>::den
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$00$00@std@@U12@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,1>,std::ratio<1,1> >::_G1
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$00$00@std@@U12@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,1>,std::ratio<1,1> >::_G2
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?value@?$_Is_ratio@U?$ratio@$00$00@std@@@chrono@std@@2_NB ; std::chrono::_Is_ratio<std::ratio<1,1> >::value
PUBLIC	?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
PUBLIC	?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
PUBLIC	?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_nonNull
PUBLIC	?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB ; Concurrency::details::_TaskCollectionBase::_S_cancelException
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_notInlined
PUBLIC	?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_structured
PUBLIC	?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_localCancel
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_reserved
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB		; std::_GcdX<10000000,1>::value
PUBLIC	?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB		; std::_GcdX<1,10000000>::value
PUBLIC	?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB		; std::_Gcd<1,10000000>::value
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?num@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::num
PUBLIC	?den@?$ratio@$00$0JIJGIA@@std@@2_JB		; std::ratio<1,10000000>::den
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$_Abs@$0JIJGIA@@std@@2_JB		; std::_Abs<10000000>::value
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB		; std::_GcdX<10000000,0>::value
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_GcdX<10000000,10000000>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB	; std::_Gcd<10000000,10000000>::value
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?num@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::num
PUBLIC	?den@?$ratio@$00$00@std@@2_JB			; std::ratio<1,1>::den
PUBLIC	?value@?$_Is_ratio@U?$ratio@$00$0DOI@@std@@@chrono@std@@2_NB ; std::chrono::_Is_ratio<std::ratio<1,1000> >::value
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Abs@$0DOI@@std@@2_JB			; std::_Abs<1000>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?_Gx@?$_Lcm@$0DOI@$0DOI@@std@@2_JB		; std::_Lcm<1000,1000>::_Gx
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?value@?$_Lcm@$0DOI@$0DOI@@std@@2_JB		; std::_Lcm<1000,1000>::value
PUBLIC	?value@?$_GcdX@$0DOI@$00@std@@2_JB		; std::_GcdX<1000,1>::value
PUBLIC	?colorsEnabled@@3_NA				; colorsEnabled
PUBLIC	?gameView@@3PAVScreen@@A			; gameView
PUBLIC	?value@?$_GcdX@$00$0DOI@@std@@2_JB		; std::_GcdX<1,1000>::value
PUBLIC	?value@?$_Gcd@$00$0DOI@@std@@2_JB		; std::_Gcd<1,1000>::value
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?num@?$ratio@$00$0DOI@@std@@2_JB		; std::ratio<1,1000>::num
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?den@?$ratio@$00$0DOI@@std@@2_JB		; std::ratio<1,1000>::den
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$00$0DLJKMKAA@@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,1000000000>,std::ratio<1000000000,1> >::_G1
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_monotonic@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_monotonic
PUBLIC	?is_steady@steady_clock@chrono@std@@2_NB	; std::chrono::steady_clock::is_steady
PUBLIC	?value@?$_GcdX@$0DLJKMKAA@$0A@@std@@2_JB	; std::_GcdX<1000000000,0>::value
PUBLIC	?value@?$_GcdX@$0DLJKMKAA@$0DLJKMKAA@@std@@2_JB	; std::_GcdX<1000000000,1000000000>::value
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<1000000000,1> >::_G1
PUBLIC	?value@?$_Gcd@$0DLJKMKAA@$0DLJKMKAA@@std@@2_JB	; std::_Gcd<1000000000,1000000000>::value
PUBLIC	?value@?$_GcdX@$0DLJKMKAA@$0JIJGIA@@std@@2_JB	; std::_GcdX<1000000000,10000000>::value
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$00$0DLJKMKAA@@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,1000000000>,std::ratio<1000000000,1> >::_G2
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?value@?$_Gcd@$0DLJKMKAA@$0JIJGIA@@std@@2_JB	; std::_Gcd<1000000000,10000000>::value
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<1000000000,1> >::_G2
PUBLIC	_ConcRT_ProviderGuid
PUBLIC	_ConcRTEventGuid
PUBLIC	_SchedulerEventGuid
PUBLIC	_ScheduleGroupEventGuid
PUBLIC	_ContextEventGuid
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	_ChoreEventGuid
PUBLIC	_VirtualProcessorEventGuid
PUBLIC	_LockEventGuid
PUBLIC	_ResourceManagerEventGuid
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	_PPLParallelInvokeEventGuid
PUBLIC	_PPLParallelForEventGuid
PUBLIC	_PPLParallelForeachEventGuid
PUBLIC	_AgentEventGuid
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?value@?$_GcdX@$0GE@$00@std@@2_JB		; std::_GcdX<100,1>::value
PUBLIC	?value@?$_Gcd@$0GE@$00@std@@2_JB		; std::_Gcd<100,1>::value
PUBLIC	?num@?$ratio@$0GE@$00@std@@2_JB			; std::ratio<100,1>::num
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?den@?$ratio@$0GE@$00@std@@2_JB			; std::ratio<100,1>::den
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,1000>,std::ratio<1000000000,1> >::_G1
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$_GcdX@$0DOI@$0A@@std@@2_JB		; std::_GcdX<1000,0>::value
PUBLIC	?value@?$_GcdX@$0DLJKMKAA@$0DOI@@std@@2_JB	; std::_GcdX<1000000000,1000>::value
PUBLIC	?value@?$_Gcd@$0DLJKMKAA@$0DOI@@std@@2_JB	; std::_Gcd<1000000000,1000>::value
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,1000>,std::ratio<1000000000,1> >::_G2
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?_G1@?$_Ratio_multiply2@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,1000>,std::ratio<1000,1> >::_G1
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?value@?$_GcdX@$0DOI@$0DOI@@std@@2_JB		; std::_GcdX<1000,1000>::value
PUBLIC	?ai_player_mutex@@3PAUpthread_mutex_t_@@A	; ai_player_mutex
PUBLIC	?value@?$_Gcd@$0DOI@$0DOI@@std@@2_JB		; std::_Gcd<1000,1000>::value
PUBLIC	?value@?$_Abs@$0PECEA@@std@@2_JB		; std::_Abs<1000000>::value
PUBLIC	?_G2@?$_Ratio_multiply2@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB ; std::_Ratio_multiply2<std::ratio<1,1000>,std::ratio<1000,1> >::_G2
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?value@?$_GcdX@$0PECEA@$00@std@@2_JB		; std::_GcdX<1000000,1>::value
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
_BSS	SEGMENT
?colorsEnabled@@3_NA DB 01H DUP (?)			; colorsEnabled
	ALIGN	4

?gameView@@3PAVScreen@@A DD 01H DUP (?)			; gameView
_BSS	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0PECEA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0PECEA@$00@std@@2_JB DQ 0000000000000001H ; std::_GcdX<1000000,1>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB DQ 00000000000003e8H ; std::_Ratio_multiply2<std::ratio<1,1000>,std::ratio<1000,1> >::_G2
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0PECEA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0PECEA@@std@@2_JB DQ 00000000000f4240H	; std::_Abs<1000000>::value
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0DOI@$0DOI@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0DOI@$0DOI@@std@@2_JB DQ 00000000000003e8H ; std::_Gcd<1000,1000>::value
CONST	ENDS
_DATA	SEGMENT
?ai_player_mutex@@3PAUpthread_mutex_t_@@A DD 0ffffffffH	; ai_player_mutex
_DATA	ENDS
;	COMDAT ?value@?$_GcdX@$0DOI@$0DOI@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DOI@$0DOI@@std@@2_JB DQ 00000000000003e8H ; std::_GcdX<1000,1000>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DOI@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<1,1000>,std::ratio<1000,1> >::_G1
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB DQ 00000000000003e8H ; std::_Ratio_multiply2<std::ratio<1,1000>,std::ratio<1000000000,1> >::_G2
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0DLJKMKAA@$0DOI@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0DLJKMKAA@$0DOI@@std@@2_JB DQ 00000000000003e8H ; std::_Gcd<1000000000,1000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DLJKMKAA@$0DOI@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DLJKMKAA@$0DOI@@std@@2_JB DQ 00000000000003e8H ; std::_GcdX<1000000000,1000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DOI@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DOI@$0A@@std@@2_JB DQ 00000000000003e8H ; std::_GcdX<1000,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$00$0DOI@@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<1,1000>,std::ratio<1000000000,1> >::_G1
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?den@?$ratio@$0GE@$00@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$0GE@$00@std@@2_JB DQ 0000000000000001H	; std::ratio<100,1>::den
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?num@?$ratio@$0GE@$00@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$0GE@$00@std@@2_JB DQ 0000000000000064H	; std::ratio<100,1>::num
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0GE@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0GE@$00@std@@2_JB DQ 0000000000000001H	; std::_Gcd<100,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$00@std@@2_JB DQ 0000000000000001H	; std::_GcdX<100,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT _AgentEventGuid
CONST	SEGMENT
_AgentEventGuid DD 0b9b5b78cH
	DW	0713H
	DW	04898H
	DB	0a2H
	DB	01aH
	DB	0c6H
	DB	079H
	DB	049H
	DB	0dcH
	DB	0edH
	DB	07H
CONST	ENDS
;	COMDAT _PPLParallelForeachEventGuid
CONST	SEGMENT
_PPLParallelForeachEventGuid DD 05cb7d785H
	DW	09d66H
	DW	0465dH
	DB	0baH
	DB	0e1H
	DB	046H
	DB	011H
	DB	06H
	DB	01bH
	DB	054H
	DB	034H
CONST	ENDS
;	COMDAT _PPLParallelForEventGuid
CONST	SEGMENT
_PPLParallelForEventGuid DD 031c8da6bH
	DW	06165H
	DW	04042H
	DB	08bH
	DB	092H
	DB	094H
	DB	09eH
	DB	031H
	DB	05fH
	DB	04dH
	DB	084H
CONST	ENDS
;	COMDAT _PPLParallelInvokeEventGuid
CONST	SEGMENT
_PPLParallelInvokeEventGuid DD 0d1b5b133H
	DW	0ec3dH
	DW	049f4H
	DB	098H
	DB	0a3H
	DB	046H
	DB	04dH
	DB	01aH
	DB	09eH
	DB	046H
	DB	082H
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT _ResourceManagerEventGuid
CONST	SEGMENT
_ResourceManagerEventGuid DD 02718d25bH
	DW	05bf5H
	DW	04479H
	DB	08eH
	DB	088H
	DB	0baH
	DB	0bcH
	DB	064H
	DB	0bdH
	DB	0bfH
	DB	0caH
CONST	ENDS
;	COMDAT _LockEventGuid
CONST	SEGMENT
_LockEventGuid DD 079a60dc6H
	DW	05fc8H
	DW	04952H
	DB	0a4H
	DB	01cH
	DB	011H
	DB	063H
	DB	0aeH
	DB	0ecH
	DB	05eH
	DB	0b8H
CONST	ENDS
;	COMDAT _VirtualProcessorEventGuid
CONST	SEGMENT
_VirtualProcessorEventGuid DD 02f27805fH
	DW	01676H
	DW	04eccH
	DB	096H
	DB	0faH
	DB	07eH
	DB	0b0H
	DB	09dH
	DB	044H
	DB	030H
	DB	02fH
CONST	ENDS
;	COMDAT _ChoreEventGuid
CONST	SEGMENT
_ChoreEventGuid DD 07e854ec7H
	DW	0cdc4H
	DW	0405aH
	DB	0b5H
	DB	0b2H
	DB	0aaH
	DB	0f7H
	DB	0c9H
	DB	0e7H
	DB	0d4H
	DB	0cH
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT _ContextEventGuid
CONST	SEGMENT
_ContextEventGuid DD 05727a00fH
	DW	050beH
	DW	04519H
	DB	082H
	DB	056H
	DB	0f7H
	DB	069H
	DB	098H
	DB	071H
	DB	0feH
	DB	0cbH
CONST	ENDS
;	COMDAT _ScheduleGroupEventGuid
CONST	SEGMENT
_ScheduleGroupEventGuid DD 0e8a3bf1fH
	DW	0a86bH
	DW	04390H
	DB	09cH
	DB	060H
	DB	053H
	DB	090H
	DB	0b9H
	DB	069H
	DB	0d2H
	DB	02cH
CONST	ENDS
;	COMDAT _SchedulerEventGuid
CONST	SEGMENT
_SchedulerEventGuid DD 0e2091f8aH
	DW	01e0aH
	DW	04731H
	DB	084H
	DB	0a2H
	DB	0dH
	DB	0d5H
	DB	07cH
	DB	08aH
	DB	052H
	DB	061H
CONST	ENDS
;	COMDAT _ConcRTEventGuid
CONST	SEGMENT
_ConcRTEventGuid DD 072b14a7dH
	DW	0704cH
	DW	0423eH
	DB	092H
	DB	0f8H
	DB	07eH
	DB	06dH
	DB	064H
	DB	0bcH
	DB	0b9H
	DB	02aH
CONST	ENDS
;	COMDAT _ConcRT_ProviderGuid
CONST	SEGMENT
_ConcRT_ProviderGuid DD 0f7b697a3H
	DW	04db5H
	DW	04d3bH
	DB	0beH
	DB	071H
	DB	0c4H
	DB	0d2H
	DB	084H
	DB	0e6H
	DB	059H
	DB	02fH
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB DQ 0000000000989680H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<1000000000,1> >::_G2
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0DLJKMKAA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0DLJKMKAA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_Gcd<1000000000,10000000>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$00$0DLJKMKAA@@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$00$0DLJKMKAA@@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB DQ 000000003b9aca00H ; std::_Ratio_multiply2<std::ratio<1,1000000000>,std::ratio<1000000000,1> >::_G2
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DLJKMKAA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DLJKMKAA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<1000000000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0DLJKMKAA@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0DLJKMKAA@$0DLJKMKAA@@std@@2_JB DQ 000000003b9aca00H ; std::_Gcd<1000000000,1000000000>::value
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<1000000000,1> >::_G1
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DLJKMKAA@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DLJKMKAA@$0DLJKMKAA@@std@@2_JB DQ 000000003b9aca00H ; std::_GcdX<1000000000,1000000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DLJKMKAA@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DLJKMKAA@$0A@@std@@2_JB DQ 000000003b9aca00H ; std::_GcdX<1000000000,0>::value
CONST	ENDS
;	COMDAT ?is_steady@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@steady_clock@chrono@std@@2_NB DB 01H		; std::chrono::steady_clock::is_steady
CONST	ENDS
;	COMDAT ?is_monotonic@steady_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@steady_clock@chrono@std@@2_NB DB 01H	; std::chrono::steady_clock::is_monotonic
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$00$0DLJKMKAA@@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$00$0DLJKMKAA@@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<1,1000000000>,std::ratio<1000000000,1> >::_G1
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$0DOI@@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$0DOI@@std@@2_JB DQ 00000000000003e8H	; std::ratio<1,1000>::den
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$0DOI@@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$0DOI@@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1000>::num
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$0DOI@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$0DOI@@std@@2_JB DQ 0000000000000001H	; std::_Gcd<1,1000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0DOI@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0DOI@@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,1000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DOI@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DOI@$00@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1000,1>::value
CONST	ENDS
;	COMDAT ?value@?$_Lcm@$0DOI@$0DOI@@std@@2_JB
CONST	SEGMENT
?value@?$_Lcm@$0DOI@$0DOI@@std@@2_JB DQ 00000000000003e8H ; std::_Lcm<1000,1000>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?_Gx@?$_Lcm@$0DOI@$0DOI@@std@@2_JB
CONST	SEGMENT
?_Gx@?$_Lcm@$0DOI@$0DOI@@std@@2_JB DQ 00000000000003e8H	; std::_Lcm<1000,1000>::_Gx
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0DOI@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0DOI@@std@@2_JB DQ 00000000000003e8H	; std::_Abs<1000>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Is_ratio@U?$ratio@$00$0DOI@@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_ratio@U?$ratio@$00$0DOI@@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_ratio<std::ratio<1,1000> >::value
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$00@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1,1>::num
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000989680H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G2
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_Gcd<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$0A@@std@@2_JB DQ 0000000000989680H ; std::_GcdX<10000000,0>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0JIJGIA@@std@@2_JB DQ 0000000000989680H	; std::_Abs<10000000>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$00$0JIJGIA@@std@@U?$ratio@$0JIJGIA@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<1,10000000>,std::ratio<10000000,1> >::_G1
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000989680H ; std::ratio<1,10000000>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::ratio<1,10000000>::num
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_Gcd<1,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0JIJGIA@@std@@2_JB DQ 0000000000000001H ; std::_GcdX<1,10000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0JIJGIA@$00@std@@2_JB DQ 0000000000000001H ; std::_GcdX<10000000,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_ratio@U?$ratio@$00$0JIJGIA@@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_ratio<std::ratio<1,10000000> >::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB DD 0cH ; Concurrency::details::_TaskCollectionBase::_S_reserved
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB DD 02H ; Concurrency::details::_TaskCollectionBase::_S_localCancel
CONST	ENDS
;	COMDAT ?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB DD 01H ; Concurrency::details::_TaskCollectionBase::_S_structured
CONST	ENDS
;	COMDAT ?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB DD 0ffffffffH ; Concurrency::details::_TaskCollectionBase::_S_notInlined
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1IB DD 0cH ; Concurrency::details::_TaskCollectionBase::_S_cancelException
CONST	ENDS
;	COMDAT ?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1IB DD 08H ; Concurrency::details::_TaskCollectionBase::_S_nonNull
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1IB DD 03H ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1IB DD 02H ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
CONST	ENDS
;	COMDAT ?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1IB DD 01H ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
CONST	ENDS
;	COMDAT ?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1IB DD 00H ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB
CONST	SEGMENT
?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1IB DD 03H ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
CONST	ENDS
;	COMDAT ?value@?$_Is_ratio@U?$ratio@$00$00@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_ratio@U?$ratio@$00$00@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_ratio<std::ratio<1,1> >::value
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$00$00@std@@U12@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$00$00@std@@U12@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<1,1>,std::ratio<1,1> >::_G2
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$00$00@std@@U12@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$00$00@std@@U12@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<1,1>,std::ratio<1,1> >::_G1
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?den@?$ratio@$0DLJKMKAA@$00@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$0DLJKMKAA@$00@std@@2_JB DQ 0000000000000001H ; std::ratio<1000000000,1>::den
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?num@?$ratio@$0DLJKMKAA@$00@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$0DLJKMKAA@$00@std@@2_JB DQ 000000003b9aca00H ; std::ratio<1000000000,1>::num
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$00$00@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$00$00@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<1,1>,std::ratio<1000000000,1> >::_G2
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0DLJKMKAA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0DLJKMKAA@$00@std@@2_JB DQ 0000000000000001H ; std::_Gcd<1000000000,1>::value
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DLJKMKAA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DLJKMKAA@$00@std@@2_JB DQ 0000000000000001H ; std::_GcdX<1000000000,1>::value
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$00$00@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$00$00@std@@U?$ratio@$0DLJKMKAA@$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<1,1>,std::ratio<1000000000,1> >::_G1
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?value@?$_Always_false@_J@std@@2_NB
CONST	SEGMENT
?value@?$_Always_false@_J@std@@2_NB DB 00H		; std::_Always_false<__int64>::value
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_steady@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_steady@system_clock@chrono@std@@2_NB DB 00H		; std::chrono::system_clock::is_steady
CONST	ENDS
;	COMDAT ?is_monotonic@system_clock@chrono@std@@2_NB
CONST	SEGMENT
?is_monotonic@system_clock@chrono@std@@2_NB DB 00H	; std::chrono::system_clock::is_monotonic
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G2
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$00@std@@2_JB DQ 0000000000000001H	; std::_Gcd<1,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$00@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$00@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,1>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0A@@std@@2_JB DQ 0000000000000001H	; std::_GcdX<1,0>::value
CONST	ENDS
;	COMDAT ?_G2@?$_Ratio_multiply2@U?$ratio@$00$0DLJKMKAA@@std@@U?$ratio@$00$00@2@@std@@2_JB
CONST	SEGMENT
?_G2@?$_Ratio_multiply2@U?$ratio@$00$0DLJKMKAA@@std@@U?$ratio@$00$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<1,1000000000>,std::ratio<1,1> >::_G2
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$00$0DLJKMKAA@@std@@U?$ratio@$00$00@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$00$0DLJKMKAA@@std@@U?$ratio@$00$00@2@@std@@2_JB DQ 0000000000000001H ; std::_Ratio_multiply2<std::ratio<1,1000000000>,std::ratio<1,1> >::_G1
CONST	ENDS
;	COMDAT ?value@?$_Abs@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$00@std@@2_JB DQ 0000000000000001H	; std::_Abs<1>::value
CONST	ENDS
;	COMDAT ?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB
CONST	SEGMENT
?_G1@?$_Ratio_multiply2@U?$ratio@$0GE@$00@std@@U?$ratio@$00$0DLJKMKAA@@2@@std@@2_JB DQ 0000000000000064H ; std::_Ratio_multiply2<std::ratio<100,1>,std::ratio<1,1000000000> >::_G1
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_Gcd<100,1000000000>::value
CONST	ENDS
;	COMDAT ?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB DD 03H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
CONST	ENDS
;	COMDAT ?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 02H ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
CONST	ENDS
;	COMDAT ?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 01H ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0DLJKMKAA@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<100,1000000000>::value
CONST	ENDS
;	COMDAT ?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB DD 00H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0DLJKMKAA@$0GE@@std@@2_JB DQ 0000000000000064H ; std::_GcdX<1000000000,100>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$0GE@$0A@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$0GE@$0A@@std@@2_JB DQ 0000000000000064H	; std::_GcdX<100,0>::value
CONST	ENDS
;	COMDAT ?den@?$ratio@$00$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$00$0DLJKMKAA@@std@@2_JB DQ 000000003b9aca00H ; std::ratio<1,1000000000>::den
CONST	ENDS
;	COMDAT ?value@?$_Is_duration@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_duration@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_duration<std::chrono::duration<__int64,std::ratio<1,1> > >::value
CONST	ENDS
;	COMDAT ?num@?$ratio@$00$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$00$0DLJKMKAA@@std@@2_JB DQ 0000000000000001H ; std::ratio<1,1000000000>::num
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$00$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$00$0DLJKMKAA@@std@@2_JB DQ 0000000000000001H ; std::_Gcd<1,1000000000>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0DLJKMKAA@@std@@2_JB DQ 000000003b9aca00H ; std::_Abs<1000000000>::value
CONST	ENDS
;	COMDAT ?value@?$_GcdX@$00$0DLJKMKAA@@std@@2_JB
CONST	SEGMENT
?value@?$_GcdX@$00$0DLJKMKAA@@std@@2_JB DQ 0000000000000001H ; std::_GcdX<1,1000000000>::value
CONST	ENDS
;	COMDAT ?value@?$_Abs@$0GE@@std@@2_JB
CONST	SEGMENT
?value@?$_Abs@$0GE@@std@@2_JB DQ 0000000000000064H	; std::_Abs<100>::value
CONST	ENDS
;	COMDAT ?value@?$_Is_ratio@U?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_ratio@U?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_ratio<std::ratio<1,1000000000> >::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@H$0A@@std@@2HB
CONST	SEGMENT
?value@?$integral_constant@H$0A@@std@@2HB DD 00H	; std::integral_constant<int,0>::value
CONST	ENDS
;	COMDAT ?value@?$_Is_duration@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@@chrono@std@@2_NB
CONST	SEGMENT
?value@?$_Is_duration@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@@chrono@std@@2_NB DB 01H ; std::chrono::_Is_duration<std::chrono::duration<__int64,std::ratio<1,1000000000> > >::value
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?den@?$ratio@$0PECEA@$00@std@@2_JB
CONST	SEGMENT
?den@?$ratio@$0PECEA@$00@std@@2_JB DQ 0000000000000001H	; std::ratio<1000000,1>::den
CONST	ENDS
;	COMDAT ?num@?$ratio@$0PECEA@$00@std@@2_JB
CONST	SEGMENT
?num@?$ratio@$0PECEA@$00@std@@2_JB DQ 00000000000f4240H	; std::ratio<1000000,1>::num
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?value@?$_Gcd@$0PECEA@$00@std@@2_JB
CONST	SEGMENT
?value@?$_Gcd@$0PECEA@$00@std@@2_JB DQ 0000000000000001H ; std::_Gcd<1000000,1>::value
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	??0_Container_proxy@std@@QAE@XZ			; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::_Iterator_base12
PUBLIC	??0_Iterator_base12@std@@QAE@ABU01@@Z		; std::_Iterator_base12::_Iterator_base12
PUBLIC	??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z	; std::_Iterator_base12::operator=
PUBLIC	??1_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::~_Iterator_base12
PUBLIC	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
PUBLIC	?_Clrcont@_Iterator_base12@std@@QAEXXZ		; std::_Iterator_base12::_Clrcont
PUBLIC	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
PUBLIC	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ	; std::_Iterator_base12::_Getpnext
PUBLIC	?_Orphan_me@_Iterator_base12@std@@QAEXXZ	; std::_Iterator_base12::_Orphan_me
PUBLIC	?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ ; std::allocator<char>::select_on_container_copy_construction
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Change_alloc
PUBLIC	?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z		; std::_Debug_pointer<char>
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ; std::chrono::system_clock::now
PUBLIC	?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
PUBLIC	??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
PUBLIC	?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch
PUBLIC	??$?0_J@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64>
PUBLIC	??0_Ignore@std@@QAE@XZ				; std::_Ignore::_Ignore
PUBLIC	?sleep_until@this_thread@std@@YAXPBUxtime@@@Z	; std::this_thread::sleep_until
PUBLIC	?getOppositeDirection@@YA?AW4Directions@@W41@@Z	; getOppositeDirection
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??0OnScreen@@QAE@XZ				; OnScreen::OnScreen
PUBLIC	??1OnScreen@@UAE@XZ				; OnScreen::~OnScreen
PUBLIC	?isInScreenBounds@OnScreen@@QAE_NXZ		; OnScreen::isInScreenBounds
PUBLIC	??0?$allocator@PAVOnScreen@@@std@@QAE@XZ	; std::allocator<OnScreen *>::allocator<OnScreen *>
PUBLIC	?deallocate@?$allocator@PAVOnScreen@@@std@@QAEXPAPAVOnScreen@@I@Z ; std::allocator<OnScreen *>::deallocate
PUBLIC	?allocate@?$allocator@PAVOnScreen@@@std@@QAEPAPAVOnScreen@@I@Z ; std::allocator<OnScreen *>::allocate
PUBLIC	?construct@?$allocator@PAVOnScreen@@@std@@QAEXPAPAVOnScreen@@ABQAV3@@Z ; std::allocator<OnScreen *>::construct
PUBLIC	?max_size@?$allocator@PAVOnScreen@@@std@@QBEIXZ	; std::allocator<OnScreen *>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVOnScreen@@@std@@@std@@SAIABV?$allocator@PAVOnScreen@@@2@@Z ; std::allocator_traits<std::allocator<OnScreen *> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<OnScreen *> >::_Wrap_alloc<std::allocator<OnScreen *> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAEPAPAVOnScreen@@I@Z ; std::_Wrap_alloc<std::allocator<OnScreen *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAEXPAPAVOnScreen@@I@Z ; std::_Wrap_alloc<std::allocator<OnScreen *> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<OnScreen *> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<OnScreen *> >::_Vector_val<std::_Simple_types<OnScreen *> >
PUBLIC	??1?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<OnScreen *> >::~_Vector_val<std::_Simple_types<OnScreen *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVOnScreen@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >
PUBLIC	??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::~_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >
PUBLIC	?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Free_proxy
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Getal
PUBLIC	??0?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE@XZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::vector<OnScreen *,std::allocator<OnScreen *> >
PUBLIC	??1?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE@XZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::~vector<OnScreen *,std::allocator<OnScreen *> >
PUBLIC	?capacity@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::capacity
PUBLIC	?_Unused_capacity@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Unused_capacity
PUBLIC	?begin@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@XZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::begin
PUBLIC	?end@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@XZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::end
PUBLIC	?_Make_iter@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Make_iter
PUBLIC	?size@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::size
PUBLIC	?max_size@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::max_size
PUBLIC	?push_back@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAEXABQAVOnScreen@@@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::push_back
PUBLIC	?erase@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::erase
PUBLIC	?_Destroy@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXPAPAVOnScreen@@0@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Destroy
PUBLIC	?_Grow_to@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEII@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Grow_to
PUBLIC	?_Inside@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBE_NPBQAVOnScreen@@@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Inside
PUBLIC	?_Reallocate@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Reallocate
PUBLIC	?_Reserve@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Reserve
PUBLIC	?_Tidy@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXXZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Tidy
PUBLIC	?_Xlen@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEXXZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEXPAPAVOnScreen@@0@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Orphan_range
PUBLIC	?getLocation@OnScreen@@QAE?AVPoint@@XZ		; OnScreen::getLocation
PUBLIC	?intersects@OnScreen@@QAE_NPAV1@@Z		; OnScreen::intersects
PUBLIC	?move@OnScreen@@MAE_NW4Directions@@H@Z		; OnScreen::move
PUBLIC	??_GOnScreen@@UAEPAXI@Z				; OnScreen::`scalar deleting destructor'
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVOnScreen@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,OnScreen *,int,OnScreen * const *,OnScreen * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,OnScreen *,int,OnScreen * const *,OnScreen * const &,std::_Iterator_base12>
PUBLIC	??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVOnScreen@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,OnScreen *,int,OnScreen * const *,OnScreen * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,OnScreen *,int,OnScreen * const *,OnScreen * const &,std::_Iterator_base12>
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVOnScreen@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,OnScreen *,int,OnScreen * const *,OnScreen * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,OnScreen *,int,OnScreen * const *,OnScreen * const &,std::_Iterator_base12>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@PAPAVOnScreen@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBEABQAVOnScreen@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::_Compat
PUBLIC	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@PAPAVOnScreen@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBEAAPAVOnScreen@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator++
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator++
PUBLIC	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >
PUBLIC	??0LivingEntity@@QAE@XZ				; LivingEntity::LivingEntity
PUBLIC	??1LivingEntity@@UAE@XZ				; LivingEntity::~LivingEntity
PUBLIC	?subHealth@LivingEntity@@UAEXH@Z		; LivingEntity::subHealth
PUBLIC	?isAlive@LivingEntity@@QAE_NXZ			; LivingEntity::isAlive
PUBLIC	??0?$allocator@PAVLivingEntity@@@std@@QAE@XZ	; std::allocator<LivingEntity *>::allocator<LivingEntity *>
PUBLIC	?deallocate@?$allocator@PAVLivingEntity@@@std@@QAEXPAPAVLivingEntity@@I@Z ; std::allocator<LivingEntity *>::deallocate
PUBLIC	?allocate@?$allocator@PAVLivingEntity@@@std@@QAEPAPAVLivingEntity@@I@Z ; std::allocator<LivingEntity *>::allocate
PUBLIC	?construct@?$allocator@PAVLivingEntity@@@std@@QAEXPAPAVLivingEntity@@ABQAV3@@Z ; std::allocator<LivingEntity *>::construct
PUBLIC	?max_size@?$allocator@PAVLivingEntity@@@std@@QBEIXZ ; std::allocator<LivingEntity *>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVLivingEntity@@@std@@@std@@SAIABV?$allocator@PAVLivingEntity@@@2@@Z ; std::allocator_traits<std::allocator<LivingEntity *> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::_Wrap_alloc<std::allocator<LivingEntity *> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEPAPAVLivingEntity@@I@Z ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEXPAPAVLivingEntity@@I@Z ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<LivingEntity *> >::_Vector_val<std::_Simple_types<LivingEntity *> >
PUBLIC	??1?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<LivingEntity *> >::~_Vector_val<std::_Simple_types<LivingEntity *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVLivingEntity@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >
PUBLIC	??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::~_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >
PUBLIC	?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Free_proxy
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Getal
PUBLIC	??0?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE@XZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::vector<LivingEntity *,std::allocator<LivingEntity *> >
PUBLIC	??1?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE@XZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::~vector<LivingEntity *,std::allocator<LivingEntity *> >
PUBLIC	?capacity@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::capacity
PUBLIC	?_Unused_capacity@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Unused_capacity
PUBLIC	?begin@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@XZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::begin
PUBLIC	?end@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@XZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::end
PUBLIC	?_Make_iter@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Make_iter
PUBLIC	?size@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::size
PUBLIC	?max_size@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::max_size
PUBLIC	?push_back@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEXABQAVLivingEntity@@@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::push_back
PUBLIC	?erase@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::erase
PUBLIC	?_Destroy@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXPAPAVLivingEntity@@0@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Destroy
PUBLIC	?_Grow_to@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEII@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Grow_to
PUBLIC	?_Inside@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBE_NPBQAVLivingEntity@@@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Inside
PUBLIC	?_Reallocate@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Reallocate
PUBLIC	?_Reserve@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Reserve
PUBLIC	?_Tidy@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXXZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Tidy
PUBLIC	?_Xlen@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEXXZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEXPAPAVLivingEntity@@0@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Orphan_range
PUBLIC	??_GLivingEntity@@UAEPAXI@Z			; LivingEntity::`scalar deleting destructor'
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVLivingEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,LivingEntity *,int,LivingEntity * const *,LivingEntity * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,LivingEntity *,int,LivingEntity * const *,LivingEntity * const &,std::_Iterator_base12>
PUBLIC	??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVLivingEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,LivingEntity *,int,LivingEntity * const *,LivingEntity * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,LivingEntity *,int,LivingEntity * const *,LivingEntity * const &,std::_Iterator_base12>
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVLivingEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,LivingEntity *,int,LivingEntity * const *,LivingEntity * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,LivingEntity *,int,LivingEntity * const *,LivingEntity * const &,std::_Iterator_base12>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@PAPAVLivingEntity@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBEABQAVLivingEntity@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::_Compat
PUBLIC	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@PAPAVLivingEntity@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBEAAPAVLivingEntity@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator++
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator++
PUBLIC	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >
PUBLIC	??0Bullet@@QAE@HW4Directions@@HHH@Z		; Bullet::Bullet
PUBLIC	??1Bullet@@UAE@XZ				; Bullet::~Bullet
PUBLIC	?renderBullets@Bullet@@SAXXZ			; Bullet::renderBullets
PUBLIC	??0?$allocator@PAVBullet@@@std@@QAE@XZ		; std::allocator<Bullet *>::allocator<Bullet *>
PUBLIC	?deallocate@?$allocator@PAVBullet@@@std@@QAEXPAPAVBullet@@I@Z ; std::allocator<Bullet *>::deallocate
PUBLIC	?allocate@?$allocator@PAVBullet@@@std@@QAEPAPAVBullet@@I@Z ; std::allocator<Bullet *>::allocate
PUBLIC	?construct@?$allocator@PAVBullet@@@std@@QAEXPAPAVBullet@@ABQAV3@@Z ; std::allocator<Bullet *>::construct
PUBLIC	?max_size@?$allocator@PAVBullet@@@std@@QBEIXZ	; std::allocator<Bullet *>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVBullet@@@std@@@std@@SAIABV?$allocator@PAVBullet@@@2@@Z ; std::allocator_traits<std::allocator<Bullet *> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<Bullet *> >::_Wrap_alloc<std::allocator<Bullet *> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAEPAPAVBullet@@I@Z ; std::_Wrap_alloc<std::allocator<Bullet *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAEXPAPAVBullet@@I@Z ; std::_Wrap_alloc<std::allocator<Bullet *> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<Bullet *> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Bullet *> >::_Vector_val<std::_Simple_types<Bullet *> >
PUBLIC	??1?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Bullet *> >::~_Vector_val<std::_Simple_types<Bullet *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVBullet@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >
PUBLIC	??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::~_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >
PUBLIC	?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Free_proxy
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Getal
PUBLIC	??0?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE@XZ ; std::vector<Bullet *,std::allocator<Bullet *> >::vector<Bullet *,std::allocator<Bullet *> >
PUBLIC	??1?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE@XZ ; std::vector<Bullet *,std::allocator<Bullet *> >::~vector<Bullet *,std::allocator<Bullet *> >
PUBLIC	?capacity@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ ; std::vector<Bullet *,std::allocator<Bullet *> >::capacity
PUBLIC	?_Unused_capacity@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ ; std::vector<Bullet *,std::allocator<Bullet *> >::_Unused_capacity
PUBLIC	?begin@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@XZ ; std::vector<Bullet *,std::allocator<Bullet *> >::begin
PUBLIC	?end@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@XZ ; std::vector<Bullet *,std::allocator<Bullet *> >::end
PUBLIC	?_Make_iter@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::_Make_iter
PUBLIC	?size@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ ; std::vector<Bullet *,std::allocator<Bullet *> >::size
PUBLIC	?max_size@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ ; std::vector<Bullet *,std::allocator<Bullet *> >::max_size
PUBLIC	??A?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAEAAPAVBullet@@I@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::operator[]
PUBLIC	?push_back@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAEXABQAVBullet@@@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::push_back
PUBLIC	?erase@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::erase
PUBLIC	?_Destroy@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXPAPAVBullet@@0@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::_Destroy
PUBLIC	?_Grow_to@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEII@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::_Grow_to
PUBLIC	?_Inside@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBE_NPBQAVBullet@@@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::_Inside
PUBLIC	?_Reallocate@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::_Reallocate
PUBLIC	?_Reserve@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::_Reserve
PUBLIC	?_Tidy@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXXZ ; std::vector<Bullet *,std::allocator<Bullet *> >::_Tidy
PUBLIC	?_Xlen@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEXXZ ; std::vector<Bullet *,std::allocator<Bullet *> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEXPAPAVBullet@@0@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::_Orphan_range
PUBLIC	?addBullet@Bullet@@KAXPAV1@@Z			; Bullet::addBullet
PUBLIC	?move@Bullet@@MAE_NXZ				; Bullet::move
PUBLIC	?toChar@Bullet@@MAEDXZ				; Bullet::toChar
PUBLIC	??_GBullet@@UAEPAXI@Z				; Bullet::`scalar deleting destructor'
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVBullet@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,Bullet *,int,Bullet * const *,Bullet * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Bullet *,int,Bullet * const *,Bullet * const &,std::_Iterator_base12>
PUBLIC	??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVBullet@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,Bullet *,int,Bullet * const *,Bullet * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,Bullet *,int,Bullet * const *,Bullet * const &,std::_Iterator_base12>
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVBullet@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,Bullet *,int,Bullet * const *,Bullet * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Bullet *,int,Bullet * const *,Bullet * const &,std::_Iterator_base12>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@PAPAVBullet@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBEABQAVBullet@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::_Compat
PUBLIC	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@PAPAVBullet@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBEAAPAVBullet@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator++
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator++
PUBLIC	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >
PUBLIC	??0FightingEntity@@QAE@XZ			; FightingEntity::FightingEntity
PUBLIC	??1FightingEntity@@UAE@XZ			; FightingEntity::~FightingEntity
PUBLIC	??_GFightingEntity@@UAEPAXI@Z			; FightingEntity::`scalar deleting destructor'
PUBLIC	??0Player@@QAE@HHMHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Directions@@@Z ; Player::Player
PUBLIC	?getName@Player@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Player::getName
PUBLIC	?move@Player@@QAEXW4Directions@@@Z		; Player::move
PUBLIC	?shoot@Player@@UAEXW4Directions@@@Z		; Player::shoot
PUBLIC	?subHealth@Player@@UAEXH@Z			; Player::subHealth
PUBLIC	?toChar@Player@@MAEDXZ				; Player::toChar
PUBLIC	??1Player@@UAE@XZ				; Player::~Player
PUBLIC	??_GPlayer@@UAEPAXI@Z				; Player::`scalar deleting destructor'
PUBLIC	??0Enemy@@QAE@XZ				; Enemy::Enemy
PUBLIC	??1Enemy@@UAE@XZ				; Enemy::~Enemy
PUBLIC	?aiTurn@Enemy@@SAXPAVLivingEntity@@@Z		; Enemy::aiTurn
PUBLIC	?getEnemies@Enemy@@SA?AV?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@XZ ; Enemy::getEnemies
PUBLIC	?select_on_container_copy_construction@?$allocator@PAVEnemy@@@std@@QBE?AV12@XZ ; std::allocator<Enemy *>::select_on_container_copy_construction
PUBLIC	??0?$allocator@PAVEnemy@@@std@@QAE@XZ		; std::allocator<Enemy *>::allocator<Enemy *>
PUBLIC	??0?$allocator@PAVEnemy@@@std@@QAE@ABV01@@Z	; std::allocator<Enemy *>::allocator<Enemy *>
PUBLIC	?deallocate@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@I@Z ; std::allocator<Enemy *>::deallocate
PUBLIC	?allocate@?$allocator@PAVEnemy@@@std@@QAEPAPAVEnemy@@I@Z ; std::allocator<Enemy *>::allocate
PUBLIC	?construct@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@ABQAV3@@Z ; std::allocator<Enemy *>::construct
PUBLIC	?max_size@?$allocator@PAVEnemy@@@std@@QBEIXZ	; std::allocator<Enemy *>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SAIABV?$allocator@PAVEnemy@@@2@@Z ; std::allocator_traits<std::allocator<Enemy *> >::max_size
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SA?AV?$allocator@PAVEnemy@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<Enemy *> >::select_on_container_copy_construction
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<Enemy *> >::select_on_container_copy_construction
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<Enemy *> >::_Wrap_alloc<std::allocator<Enemy *> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV?$allocator@PAVEnemy@@@1@@Z ; std::_Wrap_alloc<std::allocator<Enemy *> >::_Wrap_alloc<std::allocator<Enemy *> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEPAPAVEnemy@@I@Z ; std::_Wrap_alloc<std::allocator<Enemy *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEXPAPAVEnemy@@I@Z ; std::_Wrap_alloc<std::allocator<Enemy *> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<Enemy *> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Enemy *> >::_Vector_val<std::_Simple_types<Enemy *> >
PUBLIC	??1?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Enemy *> >::~_Vector_val<std::_Simple_types<Enemy *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEnemy@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >
PUBLIC	??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::~_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >
PUBLIC	?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Free_proxy
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Getal
PUBLIC	??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@XZ ; std::vector<Enemy *,std::allocator<Enemy *> >::vector<Enemy *,std::allocator<Enemy *> >
PUBLIC	??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::vector<Enemy *,std::allocator<Enemy *> >
PUBLIC	??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@$$QAV01@@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::vector<Enemy *,std::allocator<Enemy *> >
PUBLIC	?_Assign_rv@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAEX$$QAV12@@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Assign_rv
PUBLIC	??1?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@XZ ; std::vector<Enemy *,std::allocator<Enemy *> >::~vector<Enemy *,std::allocator<Enemy *> >
PUBLIC	?capacity@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ; std::vector<Enemy *,std::allocator<Enemy *> >::capacity
PUBLIC	?_Unused_capacity@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ; std::vector<Enemy *,std::allocator<Enemy *> >::_Unused_capacity
PUBLIC	?begin@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@XZ ; std::vector<Enemy *,std::allocator<Enemy *> >::begin
PUBLIC	?begin@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@XZ ; std::vector<Enemy *,std::allocator<Enemy *> >::begin
PUBLIC	?end@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@XZ ; std::vector<Enemy *,std::allocator<Enemy *> >::end
PUBLIC	?end@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@XZ ; std::vector<Enemy *,std::allocator<Enemy *> >::end
PUBLIC	?_Make_iter@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Make_iter
PUBLIC	?size@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ; std::vector<Enemy *,std::allocator<Enemy *> >::size
PUBLIC	?max_size@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ; std::vector<Enemy *,std::allocator<Enemy *> >::max_size
PUBLIC	??A?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAEAAPAVEnemy@@I@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::operator[]
PUBLIC	?push_back@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAEXABQAVEnemy@@@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::push_back
PUBLIC	?erase@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::erase
PUBLIC	?_Buy@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAE_NI@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Buy
PUBLIC	?_Destroy@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXPAPAVEnemy@@0@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Destroy
PUBLIC	?_Grow_to@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEII@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Grow_to
PUBLIC	?_Inside@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBE_NPBQAVEnemy@@@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Inside
PUBLIC	?_Reallocate@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Reallocate
PUBLIC	?_Reserve@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Reserve
PUBLIC	?_Tidy@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXXZ ; std::vector<Enemy *,std::allocator<Enemy *> >::_Tidy
PUBLIC	?_Xlen@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEXXZ ; std::vector<Enemy *,std::allocator<Enemy *> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEXPAPAVEnemy@@0@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Orphan_range
PUBLIC	??_GEnemy@@UAEPAXI@Z				; Enemy::`scalar deleting destructor'
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEnemy@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,Enemy *,int,Enemy * const *,Enemy * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Enemy *,int,Enemy * const *,Enemy * const &,std::_Iterator_base12>
PUBLIC	??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEnemy@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,Enemy *,int,Enemy * const *,Enemy * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,Enemy *,int,Enemy * const *,Enemy * const &,std::_Iterator_base12>
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEnemy@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,Enemy *,int,Enemy * const *,Enemy * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Enemy *,int,Enemy * const *,Enemy * const &,std::_Iterator_base12>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@PAPAVEnemy@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBEABQAVEnemy@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator!=
PUBLIC	??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator<
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::_Compat
PUBLIC	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@PAPAVEnemy@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBEAAPAVEnemy@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator++
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator++
PUBLIC	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >
PUBLIC	??0EnemySoldier@@QAE@HHMHHH@Z			; EnemySoldier::EnemySoldier
PUBLIC	?shoot@EnemySoldier@@UAEXW4Directions@@@Z	; EnemySoldier::shoot
PUBLIC	?processAndAct@EnemySoldier@@UAEXPAVLivingEntity@@@Z ; EnemySoldier::processAndAct
PUBLIC	?toChar@EnemySoldier@@MAEDXZ			; EnemySoldier::toChar
PUBLIC	??1EnemySoldier@@UAE@XZ				; EnemySoldier::~EnemySoldier
PUBLIC	??_GEnemySoldier@@UAEPAXI@Z			; EnemySoldier::`scalar deleting destructor'
PUBLIC	??0Screen@@QAE@DPAVPlayer@@@Z			; Screen::Screen
PUBLIC	?stuffAt@Screen@@QAE_NHH@Z			; Screen::stuffAt
PUBLIC	?render@Screen@@QAEXXZ				; Screen::render
PUBLIC	?setColor@Screen@@QAEXE@Z			; Screen::setColor
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?getInput@@YAXPAVPlayer@@@Z			; getInput
PUBLIC	?processaiwhole@@YAPAXPAX@Z			; processaiwhole
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
PUBLIC	?zero@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@SA?AV123@XZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::zero
PUBLIC	??$?0H@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@ABHPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><int>
PUBLIC	??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z ; std::this_thread::sleep_for<__int64,std::ratio<1,1000> >
PUBLIC	?processaibysingle@@YAPAXPAX@Z			; processaibysingle
PUBLIC	?levelOne@@YAXPAVScreen@@@Z			; levelOne
PUBLIC	?mainMenu@@YAXXZ				; mainMenu
PUBLIC	_main
PUBLIC	??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::operator!=<std::allocator<char>,std::allocator<char> >
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBEPQ?$_Bool_struct@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@2@HXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator int std::_Bool_struct<std::basic_ostream<char,std::char_traits<char> > >::*
PUBLIC	??$addressof@QAVOnScreen@@@std@@YAPBQAVOnScreen@@ABQAV1@@Z ; std::addressof<OnScreen * const>
PUBLIC	??$construct@PAVOnScreen@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAEXPAPAVOnScreen@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<OnScreen *> >::construct<OnScreen *,OnScreen * &>
PUBLIC	??$construct@PAVOnScreen@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAEXPAPAVOnScreen@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<OnScreen *> >::construct<OnScreen *,OnScreen * const &>
PUBLIC	??$_Move@PAPAVOnScreen@@PAPAV1@@std@@YAPAPAVOnScreen@@PAPAV1@00@Z ; std::_Move<OnScreen * *,OnScreen * *>
PUBLIC	??$addressof@QAVLivingEntity@@@std@@YAPBQAVLivingEntity@@ABQAV1@@Z ; std::addressof<LivingEntity * const>
PUBLIC	??$construct@PAVLivingEntity@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEXPAPAVLivingEntity@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::construct<LivingEntity *,LivingEntity * &>
PUBLIC	??$construct@PAVLivingEntity@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEXPAPAVLivingEntity@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::construct<LivingEntity *,LivingEntity * const &>
PUBLIC	??$_Move@PAPAVLivingEntity@@PAPAV1@@std@@YAPAPAVLivingEntity@@PAPAV1@00@Z ; std::_Move<LivingEntity * *,LivingEntity * *>
PUBLIC	??$addressof@QAVBullet@@@std@@YAPBQAVBullet@@ABQAV1@@Z ; std::addressof<Bullet * const>
PUBLIC	??$construct@PAVBullet@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAEXPAPAVBullet@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<Bullet *> >::construct<Bullet *,Bullet * &>
PUBLIC	??$construct@PAVBullet@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAEXPAPAVBullet@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<Bullet *> >::construct<Bullet *,Bullet * const &>
PUBLIC	??$_Move@PAPAVBullet@@PAPAV1@@std@@YAPAPAVBullet@@PAPAV1@00@Z ; std::_Move<Bullet * *,Bullet * *>
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@1@0PAPAV2@@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > > >
PUBLIC	??$forward@V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@YA$$QAV?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@0@AAV10@@Z ; std::forward<std::vector<Enemy *,std::allocator<Enemy *> > >
PUBLIC	??$addressof@QAVEnemy@@@std@@YAPBQAVEnemy@@ABQAV1@@Z ; std::addressof<Enemy * const>
PUBLIC	??$construct@PAVEnemy@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEXPAPAVEnemy@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<Enemy *> >::construct<Enemy *,Enemy * &>
PUBLIC	??$construct@PAVEnemy@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEXPAPAVEnemy@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<Enemy *> >::construct<Enemy *,Enemy * const &>
PUBLIC	??$_Move@PAPAVEnemy@@PAPAV1@@std@@YAPAPAVEnemy@@PAPAV1@00@Z ; std::_Move<Enemy * *,Enemy * *>
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@YAXPAPAVOnScreen@@0AAU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<OnScreen *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@YAXPAPAVLivingEntity@@0AAU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<LivingEntity *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@@std@@YAXPAPAVBullet@@0AAU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Bullet *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@@std@@YAXPAPAVEnemy@@0AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Enemy *> > >
PUBLIC	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
PUBLIC	??$_Umove@PAPAVOnScreen@@@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEPAPAVOnScreen@@PAPAV2@00@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Umove<OnScreen * *>
PUBLIC	??$_Umove@PAPAVLivingEntity@@@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEPAPAVLivingEntity@@PAPAV2@00@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Umove<LivingEntity * *>
PUBLIC	??$_Umove@PAPAVBullet@@@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEPAPAVBullet@@PAPAV2@00@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::_Umove<Bullet * *>
PUBLIC	??$_Umove@PAPAVEnemy@@@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEPAPAVEnemy@@PAPAV2@00@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Umove<Enemy * *>
PUBLIC	??$_Allocate@PAVEnemy@@@std@@YAPAPAVEnemy@@IPAPAV1@@Z ; std::_Allocate<Enemy *>
PUBLIC	??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>
PUBLIC	??$_Allocate@PAVOnScreen@@@std@@YAPAPAVOnScreen@@IPAPAV1@@Z ; std::_Allocate<OnScreen *>
PUBLIC	??$_Allocate@PAVLivingEntity@@@std@@YAPAPAVLivingEntity@@IPAPAV1@@Z ; std::_Allocate<LivingEntity *>
PUBLIC	??$_Allocate@PAVBullet@@@std@@YAPAPAVBullet@@IPAPAV1@@Z ; std::_Allocate<Bullet *>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$_To_xtime@_JU?$ratio@$00$0DOI@@std@@@std@@YA?AUxtime@@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@0@@Z ; std::_To_xtime<__int64,std::ratio<1,1000> >
PUBLIC	??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::operator==<std::allocator<char>,std::allocator<char> >
PUBLIC	??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z		; std::operator==<char,char>
PUBLIC	??$forward@AAPAVOnScreen@@@std@@YAAAPAVOnScreen@@AAPAV1@@Z ; std::forward<OnScreen * &>
PUBLIC	??$construct@PAVOnScreen@@AAPAV1@@?$allocator_traits@V?$allocator@PAVOnScreen@@@std@@@std@@SAXAAV?$allocator@PAVOnScreen@@@1@PAPAVOnScreen@@AAPAV3@@Z ; std::allocator_traits<std::allocator<OnScreen *> >::construct<OnScreen *,OnScreen * &>
PUBLIC	??$forward@ABQAVOnScreen@@@std@@YAABQAVOnScreen@@ABQAV1@@Z ; std::forward<OnScreen * const &>
PUBLIC	??$construct@PAVOnScreen@@ABQAV1@@?$allocator_traits@V?$allocator@PAVOnScreen@@@std@@@std@@SAXAAV?$allocator@PAVOnScreen@@@1@PAPAVOnScreen@@ABQAV3@@Z ; std::allocator_traits<std::allocator<OnScreen *> >::construct<OnScreen *,OnScreen * const &>
PUBLIC	??$_Ptr_cat@PAVOnScreen@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVOnScreen@@0@Z ; std::_Ptr_cat<OnScreen *,OnScreen *>
PUBLIC	??$_Move@PAPAVOnScreen@@PAPAV1@@std@@YAPAPAVOnScreen@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<OnScreen * *,OnScreen * *>
PUBLIC	??$forward@AAPAVLivingEntity@@@std@@YAAAPAVLivingEntity@@AAPAV1@@Z ; std::forward<LivingEntity * &>
PUBLIC	??$construct@PAVLivingEntity@@AAPAV1@@?$allocator_traits@V?$allocator@PAVLivingEntity@@@std@@@std@@SAXAAV?$allocator@PAVLivingEntity@@@1@PAPAVLivingEntity@@AAPAV3@@Z ; std::allocator_traits<std::allocator<LivingEntity *> >::construct<LivingEntity *,LivingEntity * &>
PUBLIC	??$forward@ABQAVLivingEntity@@@std@@YAABQAVLivingEntity@@ABQAV1@@Z ; std::forward<LivingEntity * const &>
PUBLIC	??$construct@PAVLivingEntity@@ABQAV1@@?$allocator_traits@V?$allocator@PAVLivingEntity@@@std@@@std@@SAXAAV?$allocator@PAVLivingEntity@@@1@PAPAVLivingEntity@@ABQAV3@@Z ; std::allocator_traits<std::allocator<LivingEntity *> >::construct<LivingEntity *,LivingEntity * const &>
PUBLIC	??$_Ptr_cat@PAVLivingEntity@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVLivingEntity@@0@Z ; std::_Ptr_cat<LivingEntity *,LivingEntity *>
PUBLIC	??$_Move@PAPAVLivingEntity@@PAPAV1@@std@@YAPAPAVLivingEntity@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<LivingEntity * *,LivingEntity * *>
PUBLIC	??$forward@AAPAVBullet@@@std@@YAAAPAVBullet@@AAPAV1@@Z ; std::forward<Bullet * &>
PUBLIC	??$construct@PAVBullet@@AAPAV1@@?$allocator_traits@V?$allocator@PAVBullet@@@std@@@std@@SAXAAV?$allocator@PAVBullet@@@1@PAPAVBullet@@AAPAV3@@Z ; std::allocator_traits<std::allocator<Bullet *> >::construct<Bullet *,Bullet * &>
PUBLIC	??$forward@ABQAVBullet@@@std@@YAABQAVBullet@@ABQAV1@@Z ; std::forward<Bullet * const &>
PUBLIC	??$construct@PAVBullet@@ABQAV1@@?$allocator_traits@V?$allocator@PAVBullet@@@std@@@std@@SAXAAV?$allocator@PAVBullet@@@1@PAPAVBullet@@ABQAV3@@Z ; std::allocator_traits<std::allocator<Bullet *> >::construct<Bullet *,Bullet * const &>
PUBLIC	??$_Ptr_cat@PAVBullet@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVBullet@@0@Z ; std::_Ptr_cat<Bullet *,Bullet *>
PUBLIC	??$_Move@PAPAVBullet@@PAPAV1@@std@@YAPAPAVBullet@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<Bullet * *,Bullet * *>
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >,Enemy * *,std::_Wrap_alloc<std::allocator<Enemy *> > >
PUBLIC	??$forward@AAPAVEnemy@@@std@@YAAAPAVEnemy@@AAPAV1@@Z ; std::forward<Enemy * &>
PUBLIC	??$construct@PAVEnemy@@AAPAV1@@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SAXAAV?$allocator@PAVEnemy@@@1@PAPAVEnemy@@AAPAV3@@Z ; std::allocator_traits<std::allocator<Enemy *> >::construct<Enemy *,Enemy * &>
PUBLIC	??$forward@ABQAVEnemy@@@std@@YAABQAVEnemy@@ABQAV1@@Z ; std::forward<Enemy * const &>
PUBLIC	??$construct@PAVEnemy@@ABQAV1@@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SAXAAV?$allocator@PAVEnemy@@@1@PAPAVEnemy@@ABQAV3@@Z ; std::allocator_traits<std::allocator<Enemy *> >::construct<Enemy *,Enemy * const &>
PUBLIC	??$_Ptr_cat@PAVEnemy@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVEnemy@@0@Z ; std::_Ptr_cat<Enemy *,Enemy *>
PUBLIC	??$_Move@PAPAVEnemy@@PAPAV1@@std@@YAPAPAVEnemy@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<Enemy * *,Enemy * *>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@YAXPAPAVOnScreen@@0AAU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<OnScreen *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@YAXPAPAVLivingEntity@@0AAU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<LivingEntity *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@@std@@YAXPAPAVBullet@@0AAU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Bullet *> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@@std@@YAXPAPAVEnemy@@0AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Enemy *> > >
PUBLIC	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
PUBLIC	??$_Uninitialized_move@PAPAVOnScreen@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@YAPAPAVOnScreen@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@0@@Z ; std::_Uninitialized_move<OnScreen * *,OnScreen * *,std::_Wrap_alloc<std::allocator<OnScreen *> > >
PUBLIC	??$_Uninitialized_move@PAPAVLivingEntity@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@YAPAPAVLivingEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@0@@Z ; std::_Uninitialized_move<LivingEntity * *,LivingEntity * *,std::_Wrap_alloc<std::allocator<LivingEntity *> > >
PUBLIC	??$_Uninitialized_move@PAPAVBullet@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@@std@@YAPAPAVBullet@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@0@@Z ; std::_Uninitialized_move<Bullet * *,Bullet * *,std::_Wrap_alloc<std::allocator<Bullet *> > >
PUBLIC	??$_Uninitialized_move@PAPAVEnemy@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@@std@@YAPAPAVEnemy@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z ; std::_Uninitialized_move<Enemy * *,Enemy * *,std::_Wrap_alloc<std::allocator<Enemy *> > >
PUBLIC	??$?N_JU?$ratio@$00$0DOI@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@0@Z ; std::chrono::operator<=<__int64,std::ratio<1,1000>,__int64,std::ratio<1,1000> >
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
PUBLIC	??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator+=
PUBLIC	??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator-=
PUBLIC	??$?0_JU?$ratio@$00$0JIJGIA@@std@@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@PAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,10000000> >
PUBLIC	??$?0_JU?$ratio@$00$0DOI@@std@@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@PAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000> >
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1> >,__int64,std::ratio<1,1000000000> >
PUBLIC	?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
PUBLIC	??$?0_J@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64>
PUBLIC	??$?0_JU?$ratio@$00$00@std@@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$00@std@@@12@PAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1> >
PUBLIC	??$construct@PAVOnScreen@@AAPAV1@@?$allocator@PAVOnScreen@@@std@@QAEXPAPAVOnScreen@@AAPAV2@@Z ; std::allocator<OnScreen *>::construct<OnScreen *,OnScreen * &>
PUBLIC	??$construct@PAVLivingEntity@@AAPAV1@@?$allocator@PAVLivingEntity@@@std@@QAEXPAPAVLivingEntity@@AAPAV2@@Z ; std::allocator<LivingEntity *>::construct<LivingEntity *,LivingEntity * &>
PUBLIC	??$construct@PAVBullet@@AAPAV1@@?$allocator@PAVBullet@@@std@@QAEXPAPAVBullet@@AAPAV2@@Z ; std::allocator<Bullet *>::construct<Bullet *,Bullet * &>
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@AAPAPAVEnemy@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >,Enemy * *>
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >,Enemy * *,std::allocator<Enemy *> >
PUBLIC	??$construct@PAVEnemy@@AAPAV1@@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@AAPAV2@@Z ; std::allocator<Enemy *>::construct<Enemy *,Enemy * &>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??$_Val_type@PAPAVOnScreen@@@std@@YAPAPAVOnScreen@@PAPAV1@@Z ; std::_Val_type<OnScreen * *>
PUBLIC	??$_Uninit_move@PAVOnScreen@@PAV1@PAV1@@std@@YAPAPAVOnScreen@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<OnScreen *,OnScreen *,OnScreen *>
PUBLIC	??$_Val_type@PAPAVLivingEntity@@@std@@YAPAPAVLivingEntity@@PAPAV1@@Z ; std::_Val_type<LivingEntity * *>
PUBLIC	??$_Uninit_move@PAVLivingEntity@@PAV1@PAV1@@std@@YAPAPAVLivingEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<LivingEntity *,LivingEntity *,LivingEntity *>
PUBLIC	??$_Val_type@PAPAVBullet@@@std@@YAPAPAVBullet@@PAPAV1@@Z ; std::_Val_type<Bullet * *>
PUBLIC	??$_Uninit_move@PAVBullet@@PAV1@PAV1@@std@@YAPAPAVBullet@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Bullet *,Bullet *,Bullet *>
PUBLIC	??$_Val_type@PAPAVEnemy@@@std@@YAPAPAVEnemy@@PAPAV1@@Z ; std::_Val_type<Enemy * *>
PUBLIC	??$_Uninit_move@PAVEnemy@@PAV1@PAV1@@std@@YAPAPAVEnemy@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Enemy *,Enemy *,Enemy *>
PUBLIC	?zero@?$duration_values@_J@chrono@std@@SA_JXZ	; std::chrono::duration_values<__int64>::zero
PUBLIC	??$?0_J@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><__int64>
PUBLIC	??$?M_JU?$ratio@$00$0DOI@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@0@Z ; std::chrono::operator<<__int64,std::ratio<1,1000>,__int64,std::ratio<1,1000> >
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,10000000> >
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000> >
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$00@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1> >
PUBLIC	??$_Debug_range@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > > >
PUBLIC	??$_Debug_pointer@PAVEnemy@@@std@@YAXPAPAVEnemy@@PB_WI@Z ; std::_Debug_pointer<Enemy *>
PUBLIC	??$destroy@PAVEnemy@@@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEXPAPAVEnemy@@@Z ; std::_Wrap_alloc<std::allocator<Enemy *> >::destroy<Enemy *>
PUBLIC	??$_Debug_range@PAPAVOnScreen@@@std@@YAXPAPAVOnScreen@@0PB_WI@Z ; std::_Debug_range<OnScreen * *>
PUBLIC	??$_Debug_pointer@PAVOnScreen@@@std@@YAXPAPAVOnScreen@@PB_WI@Z ; std::_Debug_pointer<OnScreen *>
PUBLIC	??$_Debug_range@PAPAVLivingEntity@@@std@@YAXPAPAVLivingEntity@@0PB_WI@Z ; std::_Debug_range<LivingEntity * *>
PUBLIC	??$_Debug_pointer@PAVLivingEntity@@@std@@YAXPAPAVLivingEntity@@PB_WI@Z ; std::_Debug_pointer<LivingEntity *>
PUBLIC	??$_Debug_range@PAPAVBullet@@@std@@YAXPAPAVBullet@@0PB_WI@Z ; std::_Debug_range<Bullet * *>
PUBLIC	??$_Debug_pointer@PAVBullet@@@std@@YAXPAPAVBullet@@PB_WI@Z ; std::_Debug_pointer<Bullet *>
PUBLIC	??$_Debug_range@PAPAVEnemy@@@std@@YAXPAPAVEnemy@@0PB_WI@Z ; std::_Debug_range<Enemy * *>
PUBLIC	??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64>
PUBLIC	??$_Iter_cat@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > > >
PUBLIC	??$_Debug_range2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > > >
PUBLIC	??$destroy@PAVEnemy@@@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SAXAAV?$allocator@PAVEnemy@@@1@PAPAVEnemy@@@Z ; std::allocator_traits<std::allocator<Enemy *> >::destroy<Enemy *>
PUBLIC	??$_Iter_cat@PAPAVOnScreen@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVOnScreen@@@Z ; std::_Iter_cat<OnScreen * *>
PUBLIC	??$_Debug_range2@PAPAVOnScreen@@@std@@YAXPAPAVOnScreen@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<OnScreen * *>
PUBLIC	??$_Iter_cat@PAPAVLivingEntity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVLivingEntity@@@Z ; std::_Iter_cat<LivingEntity * *>
PUBLIC	??$_Debug_range2@PAPAVLivingEntity@@@std@@YAXPAPAVLivingEntity@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<LivingEntity * *>
PUBLIC	??$_Iter_cat@PAPAVBullet@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBullet@@@Z ; std::_Iter_cat<Bullet * *>
PUBLIC	??$_Debug_range2@PAPAVBullet@@@std@@YAXPAPAVBullet@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<Bullet * *>
PUBLIC	??$_Iter_cat@PAPAVEnemy@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVEnemy@@@Z ; std::_Iter_cat<Enemy * *>
PUBLIC	??$_Debug_range2@PAPAVEnemy@@@std@@YAXPAPAVEnemy@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<Enemy * *>
PUBLIC	??$_Debug_pointer@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > > >
PUBLIC	??$destroy@PAVEnemy@@@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@@Z ; std::allocator<Enemy *>::destroy<Enemy *>
PUBLIC	??_C@_1JA@NLMHOKKJ@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; `string'
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@		; `string'
PUBLIC	??_C@_03LCPHGAHP@cls?$AA@			; `string'
PUBLIC	??_C@_05KKCIMGE@error?$AA@			; `string'
PUBLIC	??_C@_05PDJBBECF@pause?$AA@			; `string'
PUBLIC	?visibleItems@OnScreen@@2V?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@A ; OnScreen::visibleItems
PUBLIC	??_7OnScreen@@6B@				; OnScreen::`vftable'
PUBLIC	?livingThings@LivingEntity@@2V?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@A ; LivingEntity::livingThings
PUBLIC	??_7LivingEntity@@6B@				; LivingEntity::`vftable'
PUBLIC	?bullets@Bullet@@1V?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@A ; Bullet::bullets
PUBLIC	??_7Bullet@@6B@					; Bullet::`vftable'
PUBLIC	??_7FightingEntity@@6B@				; FightingEntity::`vftable'
PUBLIC	??_7Player@@6B@					; Player::`vftable'
PUBLIC	?enemies@Enemy@@1V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@A ; Enemy::enemies
PUBLIC	??_7Enemy@@6B@					; Enemy::`vftable'
PUBLIC	??_7EnemySoldier@@6B@				; EnemySoldier::`vftable'
PUBLIC	??_C@_08OBFFCDMO@Color?5?$EA?$EA?$AA@		; `string'
PUBLIC	??_C@_08NFNKKEKP@Color?507?$AA@			; `string'
PUBLIC	??_C@_09LCCGMOOO@?5Health?3?5?$AA@		; `string'
PUBLIC	??_C@_0L@BBALFDB@?3?5?5Ammo?3?5?5?$AA@		; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0CI@FIKJMPDF@Anything?5else?0?5and?5it?8ll?5just?5be@ ; `string'
PUBLIC	??_C@_0EB@EJGMMLCB@Now?0?5do?5you?5want?5?$CI0?$CJ?5no?5colors?5a@ ; `string'
PUBLIC	??_C@_0EE@NEGOOMNL@A?5little?5?$CIglitchy?$CJ?5game?5that?5I?5m@ ; `string'
PUBLIC	??_C@_08IDPINFPD@Player?51?$AA@			; `string'
PUBLIC	??_C@_08DGMLKBON@you?5win?$CB?$AA@		; `string'
PUBLIC	??_C@_09GBKDONCB@you?5lose?$CB?$AA@		; `string'
PUBLIC	??_C@_1IO@DBKIKIHF@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@ ; `string'
PUBLIC	??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; `string'
PUBLIC	??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; `string'
PUBLIC	??_C@_1JO@DMPMMILD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAB?$AAu?$AAl?$AAl?$AAe?$AAt?$AA?5?$AA?$CK?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs@ ; `string'
PUBLIC	??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1JK@MCCMGKDA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAE?$AAn?$AAe?$AAm?$AAy?$AA?5?$AA?$CK?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@ ; `string'
PUBLIC	??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ ; `string'
PUBLIC	??_C@_1NO@JHOOOHOP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1OG@OAIFONBP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1NK@ILKCDHLI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1NI@JDFLGOO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@ ; `string'
PUBLIC	??_C@_1OA@FLOHPEIM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ ; `string'
PUBLIC	??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ ; `string'
PUBLIC	??_C@_1NI@HEJHPDDM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1OI@KPIOILEE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1OA@GBDFFJPG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1NM@CIMOPBIH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1NE@PDAEDKHB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1NK@FOJADKHE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1NC@HPHJKDBI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1IO@NPCEFBKE@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Player@@6B@				; Player::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVPlayer@@@8				; Player `RTTI Type Descriptor'
PUBLIC	??_R3Player@@8					; Player::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Player@@8					; Player::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Player@@8				; Player::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@FightingEntity@@8			; FightingEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVFightingEntity@@@8			; FightingEntity `RTTI Type Descriptor'
PUBLIC	??_R3FightingEntity@@8				; FightingEntity::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FightingEntity@@8				; FightingEntity::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@LivingEntity@@8			; LivingEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVLivingEntity@@@8			; LivingEntity `RTTI Type Descriptor'
PUBLIC	??_R3LivingEntity@@8				; LivingEntity::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2LivingEntity@@8				; LivingEntity::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@OnScreen@@8			; OnScreen::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVOnScreen@@@8				; OnScreen `RTTI Type Descriptor'
PUBLIC	??_R3OnScreen@@8				; OnScreen::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2OnScreen@@8				; OnScreen::`RTTI Base Class Array'
PUBLIC	??_R4Bullet@@6B@				; Bullet::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVBullet@@@8				; Bullet `RTTI Type Descriptor'
PUBLIC	??_R3Bullet@@8					; Bullet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Bullet@@8					; Bullet::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Bullet@@8				; Bullet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4OnScreen@@6B@				; OnScreen::`RTTI Complete Object Locator'
PUBLIC	??_R4LivingEntity@@6B@				; LivingEntity::`RTTI Complete Object Locator'
PUBLIC	??_R4FightingEntity@@6B@			; FightingEntity::`RTTI Complete Object Locator'
PUBLIC	??_R4Enemy@@6B@					; Enemy::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVEnemy@@@8				; Enemy `RTTI Type Descriptor'
PUBLIC	??_R3Enemy@@8					; Enemy::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Enemy@@8					; Enemy::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Enemy@@8				; Enemy::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4EnemySoldier@@6B@				; EnemySoldier::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVEnemySoldier@@@8			; EnemySoldier `RTTI Type Descriptor'
PUBLIC	??_R3EnemySoldier@@8				; EnemySoldier::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2EnemySoldier@@8				; EnemySoldier::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@EnemySoldier@@8			; EnemySoldier::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@41200000
PUBLIC	__real@42c80000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__imp___invalid_parameter:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	__imp__rand:PROC
EXTRN	__imp__srand:PROC
EXTRN	__imp__system:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp___CrtDbgReportW:PROC
EXTRN	__imp_?_Debug_message@std@@YAXPB_W0I@Z:PROC
EXTRN	__imp_??0_Container_base12@std@@QAE@XZ:PROC
EXTRN	__imp_??1_Container_base12@std@@QAE@XZ:PROC
EXTRN	__imp_?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ:PROC
EXTRN	__imp_?_Orphan_all@_Container_base12@std@@QAEXXZ:PROC
EXTRN	__imp_?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	__imp_??0id@locale@std@@QAE@I@Z:PROC
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	__imp_?_Syserror_map@std@@YAPBDH@Z:PROC
EXTRN	__imp_?_Winerror_map@std@@YAPBDH@Z:PROC
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z:PROC
EXTRN	__imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AA_N@Z:PROC
EXTRN	__imp__getch:PROC
EXTRN	__imp__kbhit:PROC
EXTRN	__imp___time64:PROC
EXTRN	__imp__xtime_get:PROC
EXTRN	__imp___Xtime_diff_to_millis2:PROC
EXTRN	__imp___Xtime_get_ticks:PROC
EXTRN	__imp_?wait@Concurrency@@YAXI@Z:PROC
EXTRN	__imp_?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ:PROC
EXTRN	__imp___Thrd_sleep:PROC
EXTRN	__imp__pthread_create:PROC
EXTRN	__imp__pthread_mutex_lock:PROC
EXTRN	__imp__pthread_mutex_unlock:PROC
EXTRN	??_EOnScreen@@UAEPAXI@Z:PROC			; OnScreen::`vector deleting destructor'
EXTRN	??_ELivingEntity@@UAEPAXI@Z:PROC		; LivingEntity::`vector deleting destructor'
EXTRN	??_EBullet@@UAEPAXI@Z:PROC			; Bullet::`vector deleting destructor'
EXTRN	??_EFightingEntity@@UAEPAXI@Z:PROC		; FightingEntity::`vector deleting destructor'
EXTRN	??_EPlayer@@UAEPAXI@Z:PROC			; Player::`vector deleting destructor'
EXTRN	??_EEnemy@@UAEPAXI@Z:PROC			; Enemy::`vector deleting destructor'
EXTRN	??_EEnemySoldier@@UAEPAXI@Z:PROC		; EnemySoldier::`vector deleting destructor'
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	4

_ignore	DB	01H DUP (?)
	ALIGN	4

__Tuple_alloc DB 01H DUP (?)
	ALIGN	4

?visibleItems@OnScreen@@2V?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@A DB 010H DUP (?) ; OnScreen::visibleItems
?livingThings@LivingEntity@@2V?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@A DB 010H DUP (?) ; LivingEntity::livingThings
?bullets@Bullet@@1V?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@A DB 010H DUP (?) ; Bullet::bullets
?enemies@Enemy@@1V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@A DB 010H DUP (?) ; Enemy::enemies
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@EnemySoldier@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@EnemySoldier@@8 DD FLAT:??_R0?AVEnemySoldier@@@8 ; EnemySoldier::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3EnemySoldier@@8
rdata$r	ENDS
;	COMDAT ??_R2EnemySoldier@@8
rdata$r	SEGMENT
??_R2EnemySoldier@@8 DD FLAT:??_R1A@?0A@EA@EnemySoldier@@8 ; EnemySoldier::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Enemy@@8
	DD	FLAT:??_R1A@?0A@EA@FightingEntity@@8
	DD	FLAT:??_R1A@?0A@EA@LivingEntity@@8
	DD	FLAT:??_R1A@?0A@EA@OnScreen@@8
rdata$r	ENDS
;	COMDAT ??_R3EnemySoldier@@8
rdata$r	SEGMENT
??_R3EnemySoldier@@8 DD 00H				; EnemySoldier::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2EnemySoldier@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVEnemySoldier@@@8
_DATA	SEGMENT
??_R0?AVEnemySoldier@@@8 DD FLAT:??_7type_info@@6B@	; EnemySoldier `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVEnemySoldier@@', 00H
_DATA	ENDS
;	COMDAT ??_R4EnemySoldier@@6B@
rdata$r	SEGMENT
??_R4EnemySoldier@@6B@ DD 00H				; EnemySoldier::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVEnemySoldier@@@8
	DD	FLAT:??_R3EnemySoldier@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Enemy@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Enemy@@8 DD FLAT:??_R0?AVEnemy@@@8	; Enemy::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Enemy@@8
rdata$r	ENDS
;	COMDAT ??_R2Enemy@@8
rdata$r	SEGMENT
??_R2Enemy@@8 DD FLAT:??_R1A@?0A@EA@Enemy@@8		; Enemy::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@FightingEntity@@8
	DD	FLAT:??_R1A@?0A@EA@LivingEntity@@8
	DD	FLAT:??_R1A@?0A@EA@OnScreen@@8
rdata$r	ENDS
;	COMDAT ??_R3Enemy@@8
rdata$r	SEGMENT
??_R3Enemy@@8 DD 00H					; Enemy::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2Enemy@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVEnemy@@@8
_DATA	SEGMENT
??_R0?AVEnemy@@@8 DD FLAT:??_7type_info@@6B@		; Enemy `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVEnemy@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Enemy@@6B@
rdata$r	SEGMENT
??_R4Enemy@@6B@ DD 00H					; Enemy::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVEnemy@@@8
	DD	FLAT:??_R3Enemy@@8
rdata$r	ENDS
;	COMDAT ??_R4FightingEntity@@6B@
rdata$r	SEGMENT
??_R4FightingEntity@@6B@ DD 00H				; FightingEntity::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVFightingEntity@@@8
	DD	FLAT:??_R3FightingEntity@@8
rdata$r	ENDS
;	COMDAT ??_R4LivingEntity@@6B@
rdata$r	SEGMENT
??_R4LivingEntity@@6B@ DD 00H				; LivingEntity::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVLivingEntity@@@8
	DD	FLAT:??_R3LivingEntity@@8
rdata$r	ENDS
;	COMDAT ??_R4OnScreen@@6B@
rdata$r	SEGMENT
??_R4OnScreen@@6B@ DD 00H				; OnScreen::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVOnScreen@@@8
	DD	FLAT:??_R3OnScreen@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Bullet@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Bullet@@8 DD FLAT:??_R0?AVBullet@@@8	; Bullet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Bullet@@8
rdata$r	ENDS
;	COMDAT ??_R2Bullet@@8
rdata$r	SEGMENT
??_R2Bullet@@8 DD FLAT:??_R1A@?0A@EA@Bullet@@8		; Bullet::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@OnScreen@@8
rdata$r	ENDS
;	COMDAT ??_R3Bullet@@8
rdata$r	SEGMENT
??_R3Bullet@@8 DD 00H					; Bullet::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2Bullet@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVBullet@@@8
_DATA	SEGMENT
??_R0?AVBullet@@@8 DD FLAT:??_7type_info@@6B@		; Bullet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVBullet@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Bullet@@6B@
rdata$r	SEGMENT
??_R4Bullet@@6B@ DD 00H					; Bullet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVBullet@@@8
	DD	FLAT:??_R3Bullet@@8
rdata$r	ENDS
;	COMDAT ??_R2OnScreen@@8
rdata$r	SEGMENT
??_R2OnScreen@@8 DD FLAT:??_R1A@?0A@EA@OnScreen@@8	; OnScreen::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3OnScreen@@8
rdata$r	SEGMENT
??_R3OnScreen@@8 DD 00H					; OnScreen::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2OnScreen@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVOnScreen@@@8
_DATA	SEGMENT
??_R0?AVOnScreen@@@8 DD FLAT:??_7type_info@@6B@		; OnScreen `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVOnScreen@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@OnScreen@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@OnScreen@@8 DD FLAT:??_R0?AVOnScreen@@@8	; OnScreen::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3OnScreen@@8
rdata$r	ENDS
;	COMDAT ??_R2LivingEntity@@8
rdata$r	SEGMENT
??_R2LivingEntity@@8 DD FLAT:??_R1A@?0A@EA@LivingEntity@@8 ; LivingEntity::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@OnScreen@@8
rdata$r	ENDS
;	COMDAT ??_R3LivingEntity@@8
rdata$r	SEGMENT
??_R3LivingEntity@@8 DD 00H				; LivingEntity::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2LivingEntity@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVLivingEntity@@@8
_DATA	SEGMENT
??_R0?AVLivingEntity@@@8 DD FLAT:??_7type_info@@6B@	; LivingEntity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVLivingEntity@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@LivingEntity@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@LivingEntity@@8 DD FLAT:??_R0?AVLivingEntity@@@8 ; LivingEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3LivingEntity@@8
rdata$r	ENDS
;	COMDAT ??_R2FightingEntity@@8
rdata$r	SEGMENT
??_R2FightingEntity@@8 DD FLAT:??_R1A@?0A@EA@FightingEntity@@8 ; FightingEntity::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@LivingEntity@@8
	DD	FLAT:??_R1A@?0A@EA@OnScreen@@8
rdata$r	ENDS
;	COMDAT ??_R3FightingEntity@@8
rdata$r	SEGMENT
??_R3FightingEntity@@8 DD 00H				; FightingEntity::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2FightingEntity@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFightingEntity@@@8
_DATA	SEGMENT
??_R0?AVFightingEntity@@@8 DD FLAT:??_7type_info@@6B@	; FightingEntity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFightingEntity@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@FightingEntity@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FightingEntity@@8 DD FLAT:??_R0?AVFightingEntity@@@8 ; FightingEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FightingEntity@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Player@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Player@@8 DD FLAT:??_R0?AVPlayer@@@8	; Player::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Player@@8
rdata$r	ENDS
;	COMDAT ??_R2Player@@8
rdata$r	SEGMENT
??_R2Player@@8 DD FLAT:??_R1A@?0A@EA@Player@@8		; Player::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@FightingEntity@@8
	DD	FLAT:??_R1A@?0A@EA@LivingEntity@@8
	DD	FLAT:??_R1A@?0A@EA@OnScreen@@8
rdata$r	ENDS
;	COMDAT ??_R3Player@@8
rdata$r	SEGMENT
??_R3Player@@8 DD 00H					; Player::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2Player@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVPlayer@@@8
_DATA	SEGMENT
??_R0?AVPlayer@@@8 DD FLAT:??_7type_info@@6B@		; Player `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVPlayer@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Player@@6B@
rdata$r	SEGMENT
??_R4Player@@6B@ DD 00H					; Player::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVPlayer@@@8
	DD	FLAT:??_R3Player@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_1IO@NPCEFBKE@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1IO@NPCEFBKE@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'e'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '1', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H, 'e'
	DB	00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H
	DB	'g', 00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p'
	DB	00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1NC@HPHJKDBI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NC@HPHJKDBI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'E', 00H, 'n', 00H
	DB	'e', 00H, 'm', 00H, 'y', 00H, ' ', 00H, '*', 00H, '>', 00H, ' '
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, '_', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1NK@FOJADKHE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NK@FOJADKHE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'E', 00H, 'n', 00H
	DB	'e', 00H, 'm', 00H, 'y', 00H, ' ', 00H, '*', 00H, '>', 00H, ' '
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H
	DB	'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, '+', 00H, '+', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1NE@PDAEDKHB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NE@PDAEDKHB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'B', 00H, 'u', 00H
	DB	'l', 00H, 'l', 00H, 'e', 00H, 't', 00H, ' ', 00H, '*', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H
	DB	'_', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1NM@CIMOPBIH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NM@CIMOPBIH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'B', 00H, 'u', 00H
	DB	'l', 00H, 'l', 00H, 'e', 00H, 't', 00H, ' ', 00H, '*', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H
	DB	'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, '+', 00H, '+', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1OA@GBDFFJPG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1OA@GBDFFJPG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'L', 00H, 'i', 00H
	DB	'v', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 'E', 00H, 'n', 00H, 't'
	DB	00H, 'i', 00H, 't', 00H, 'y', 00H, ' ', 00H, '*', 00H, '>', 00H
	DB	' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1OI@KPIOILEE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1OI@KPIOILEE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'L', 00H, 'i', 00H
	DB	'v', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 'E', 00H, 'n', 00H, 't'
	DB	00H, 'i', 00H, 't', 00H, 'y', 00H, ' ', 00H, '*', 00H, '>', 00H
	DB	' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o'
	DB	00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, '+', 00H, '+', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1NI@HEJHPDDM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NI@HEJHPDDM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'O', 00H, 'n', 00H
	DB	'S', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'e', 00H, 'n', 00H, ' '
	DB	00H, '*', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H
	DB	':', 00H, ':', 00H, '_', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p'
	DB	00H, 'a', 00H, 't', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
CONST	SEGMENT
??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ DB '"'
	DB	00H, 'S', 00H, 't', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'a', 00H
	DB	'r', 00H, 'd', 00H, ' ', 00H, 'C', 00H, '+', 00H, '+', 00H, ' '
	DB	00H, 'L', 00H, 'i', 00H, 'b', 00H, 'r', 00H, 'a', 00H, 'r', 00H
	DB	'i', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'I', 00H, 'n', 00H, 'v'
	DB	00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H, ' ', 00H, 'A', 00H
	DB	'r', 00H, 'g', 00H, 'u', 00H, 'm', 00H, 'e', 00H, 'n', 00H, 't'
	DB	00H, '"', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
CONST	SEGMENT
??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ DB 'Standa'
	DB	'rd C++ Libraries Invalid Argument', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1OA@FLOHPEIM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1OA@FLOHPEIM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'O', 00H, 'n', 00H
	DB	'S', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'e', 00H, 'n', 00H, ' '
	DB	00H, '*', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H
	DB	':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '+', 00H, '+', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
CONST	SEGMENT
??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'm', 00H, 'e'
	DB	00H, 'n', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1NI@JDFLGOO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NI@JDFLGOO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'E', 00H, 'n', 00H
	DB	'e', 00H, 'm', 00H, 'y', 00H, ' ', 00H, '*', 00H, '>', 00H, ' '
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H
	DB	'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, '*', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1NK@ILKCDHLI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NK@ILKCDHLI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'B', 00H, 'u', 00H
	DB	'l', 00H, 'l', 00H, 'e', 00H, 't', 00H, ' ', 00H, '*', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H
	DB	'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, '*', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1OG@OAIFONBP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1OG@OAIFONBP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'L', 00H, 'i', 00H
	DB	'v', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 'E', 00H, 'n', 00H, 't'
	DB	00H, 'i', 00H, 't', 00H, 'y', 00H, ' ', 00H, '*', 00H, '>', 00H
	DB	' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o'
	DB	00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, '*', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1NO@JHOOOHOP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NO@JHOOOHOP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'O', 00H, 'n', 00H
	DB	'S', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'e', 00H, 'n', 00H, ' '
	DB	00H, '*', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H
	DB	':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '*', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
CONST	SEGMENT
??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H
	DB	'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1JK@MCCMGKDA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAE?$AAn?$AAe?$AAm?$AAy?$AA?5?$AA?$CK?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@
CONST	SEGMENT
??_C@_1JK@MCCMGKDA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAE?$AAn?$AAe?$AAm?$AAy?$AA?5?$AA?$CK?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'E', 00H, 'n', 00H
	DB	'e', 00H, 'm', 00H, 'y', 00H, ' ', 00H, '*', 00H, ',', 00H, 'c'
	DB	00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l'
	DB	00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' '
	DB	00H, 'E', 00H, 'n', 00H, 'e', 00H, 'm', 00H, 'y', 00H, ' ', 00H
	DB	'*', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o'
	DB	00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, '[', 00H, ']', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ DB '"'
	DB	00H, 'o', 00H, 'u', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H
	DB	' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '"'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1JO@DMPMMILD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAB?$AAu?$AAl?$AAl?$AAe?$AAt?$AA?5?$AA?$CK?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs@
CONST	SEGMENT
??_C@_1JO@DMPMMILD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAB?$AAu?$AAl?$AAl?$AAe?$AAt?$AA?5?$AA?$CK?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'B', 00H, 'u', 00H
	DB	'l', 00H, 'l', 00H, 'e', 00H, 't', 00H, ' ', 00H, '*', 00H, ','
	DB	00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's'
	DB	00H, ' ', 00H, 'B', 00H, 'u', 00H, 'l', 00H, 'l', 00H, 'e', 00H
	DB	't', 00H, ' ', 00H, '*', 00H, '>', 00H, ' ', 00H, '>', 00H, ':'
	DB	00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '[', 00H, ']', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
CONST	SEGMENT
??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ DB '"'
	DB	00H, 'S', 00H, 't', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'a', 00H
	DB	'r', 00H, 'd', 00H, ' ', 00H, 'C', 00H, '+', 00H, '+', 00H, ' '
	DB	00H, 'L', 00H, 'i', 00H, 'b', 00H, 'r', 00H, 'a', 00H, 'r', 00H
	DB	'i', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'O', 00H, 'u', 00H, 't'
	DB	00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'R', 00H, 'a', 00H
	DB	'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
CONST	SEGMENT
??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ DB 'Stand'
	DB	'ard C++ Libraries Out of Range', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	's', 00H, 'u', 00H, 'b', 00H, 's', 00H, 'c', 00H, 'r', 00H, 'i'
	DB	00H, 'p', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n'
	DB	00H, 'g', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@
CONST	SEGMENT
??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 's', 00H, 'e', 00H, ' ', 00H, 'i'
	DB	00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, 's', 00H, 'i'
	DB	00H, 'd', 00H, 'e', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H
	DB	'g', 00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'e'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '1', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'v', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1IO@DBKIKIHF@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1IO@DBKIKIHF@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'e'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '1', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GBKDONCB@you?5lose?$CB?$AA@
CONST	SEGMENT
??_C@_09GBKDONCB@you?5lose?$CB?$AA@ DB 'you lose!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DGMLKBON@you?5win?$CB?$AA@
CONST	SEGMENT
??_C@_08DGMLKBON@you?5win?$CB?$AA@ DB 'you win!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IDPINFPD@Player?51?$AA@
CONST	SEGMENT
??_C@_08IDPINFPD@Player?51?$AA@ DB 'Player 1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@NEGOOMNL@A?5little?5?$CIglitchy?$CJ?5game?5that?5I?5m@
CONST	SEGMENT
??_C@_0EE@NEGOOMNL@A?5little?5?$CIglitchy?$CJ?5game?5that?5I?5m@ DB 'A li'
	DB	'ttle (glitchy) game that I made just for you. Hope you like i'
	DB	't!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@EJGMMLCB@Now?0?5do?5you?5want?5?$CI0?$CJ?5no?5colors?5a@
CONST	SEGMENT
??_C@_0EB@EJGMMLCB@Now?0?5do?5you?5want?5?$CI0?$CJ?5no?5colors?5a@ DB 'No'
	DB	'w, do you want (0) no colors and no lag or (1) colors and lag'
	DB	'?', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FIKJMPDF@Anything?5else?0?5and?5it?8ll?5just?5be@
CONST	SEGMENT
??_C@_0CI@FIKJMPDF@Anything?5else?0?5and?5it?8ll?5just?5be@ DB 'Anything '
	DB	'else, and it''ll just be random', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BBALFDB@?3?5?5Ammo?3?5?5?$AA@
CONST	SEGMENT
??_C@_0L@BBALFDB@?3?5?5Ammo?3?5?5?$AA@ DB ':  Ammo:  ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LCCGMOOO@?5Health?3?5?$AA@
CONST	SEGMENT
??_C@_09LCCGMOOO@?5Health?3?5?$AA@ DB ' Health: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NFNKKEKP@Color?507?$AA@
CONST	SEGMENT
??_C@_08NFNKKEKP@Color?507?$AA@ DB 'Color 07', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08OBFFCDMO@Color?5?$EA?$EA?$AA@
CONST	SEGMENT
??_C@_08OBFFCDMO@Color?5?$EA?$EA?$AA@ DB 'Color @@', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7EnemySoldier@@6B@
CONST	SEGMENT
??_7EnemySoldier@@6B@ DD FLAT:??_R4EnemySoldier@@6B@	; EnemySoldier::`vftable'
	DD	FLAT:??_EEnemySoldier@@UAEPAXI@Z
	DD	FLAT:?toChar@EnemySoldier@@MAEDXZ
	DD	FLAT:?move@OnScreen@@MAE_NW4Directions@@H@Z
	DD	FLAT:?subHealth@LivingEntity@@UAEXH@Z
	DD	FLAT:?shoot@EnemySoldier@@UAEXW4Directions@@@Z
	DD	FLAT:?processAndAct@EnemySoldier@@UAEXPAVLivingEntity@@@Z
CONST	ENDS
;	COMDAT ??_7Enemy@@6B@
CONST	SEGMENT
??_7Enemy@@6B@ DD FLAT:??_R4Enemy@@6B@			; Enemy::`vftable'
	DD	FLAT:??_EEnemy@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:?move@OnScreen@@MAE_NW4Directions@@H@Z
	DD	FLAT:?subHealth@LivingEntity@@UAEXH@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7Player@@6B@
CONST	SEGMENT
??_7Player@@6B@ DD FLAT:??_R4Player@@6B@		; Player::`vftable'
	DD	FLAT:??_EPlayer@@UAEPAXI@Z
	DD	FLAT:?toChar@Player@@MAEDXZ
	DD	FLAT:?move@OnScreen@@MAE_NW4Directions@@H@Z
	DD	FLAT:?subHealth@Player@@UAEXH@Z
	DD	FLAT:?shoot@Player@@UAEXW4Directions@@@Z
CONST	ENDS
;	COMDAT ??_7FightingEntity@@6B@
CONST	SEGMENT
??_7FightingEntity@@6B@ DD FLAT:??_R4FightingEntity@@6B@ ; FightingEntity::`vftable'
	DD	FLAT:??_EFightingEntity@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:?move@OnScreen@@MAE_NW4Directions@@H@Z
	DD	FLAT:?subHealth@LivingEntity@@UAEXH@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7Bullet@@6B@
CONST	SEGMENT
??_7Bullet@@6B@ DD FLAT:??_R4Bullet@@6B@		; Bullet::`vftable'
	DD	FLAT:??_EBullet@@UAEPAXI@Z
	DD	FLAT:?toChar@Bullet@@MAEDXZ
	DD	FLAT:?move@OnScreen@@MAE_NW4Directions@@H@Z
	DD	FLAT:?move@Bullet@@MAE_NXZ
CONST	ENDS
;	COMDAT ??_7LivingEntity@@6B@
CONST	SEGMENT
??_7LivingEntity@@6B@ DD FLAT:??_R4LivingEntity@@6B@	; LivingEntity::`vftable'
	DD	FLAT:??_ELivingEntity@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:?move@OnScreen@@MAE_NW4Directions@@H@Z
	DD	FLAT:?subHealth@LivingEntity@@UAEXH@Z
CONST	ENDS
;	COMDAT ??_7OnScreen@@6B@
CONST	SEGMENT
??_7OnScreen@@6B@ DD FLAT:??_R4OnScreen@@6B@		; OnScreen::`vftable'
	DD	FLAT:??_EOnScreen@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:?move@OnScreen@@MAE_NW4Directions@@H@Z
CONST	ENDS
;	COMDAT ??_C@_05PDJBBECF@pause?$AA@
CONST	SEGMENT
??_C@_05PDJBBECF@pause?$AA@ DB 'pause', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KKCIMGE@error?$AA@
CONST	SEGMENT
??_C@_05KKCIMGE@error?$AA@ DB 'error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LCPHGAHP@cls?$AA@
CONST	SEGMENT
??_C@_03LCPHGAHP@cls?$AA@ DB 'cls', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ DB '%', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
CONST	ENDS
;	COMDAT ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ DB 'I'
	DB	00H, 'T', 00H, 'E', 00H, 'R', 00H, 'A', 00H, 'T', 00H, 'O', 00H
	DB	'R', 00H, ' ', 00H, 'L', 00H, 'I', 00H, 'S', 00H, 'T', 00H, ' '
	DB	00H, 'C', 00H, 'O', 00H, 'R', 00H, 'R', 00H, 'U', 00H, 'P', 00H
	DB	'T', 00H, 'E', 00H, 'D', 00H, '!', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1JA@NLMHOKKJ@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1JA@NLMHOKKJ@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'e'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '1', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'u', 00H, 't'
	DB	00H, 'i', 00H, 'l', 00H, 'i', 00H, 't', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Debug_range2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Debug_range2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Debug_range2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1
__ehfuncinfo$??$_Debug_range2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Debug_range2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Debug_range@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WI@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WI@Z$2
__ehfuncinfo$??$_Debug_range@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Debug_range@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PAVEnemy@@AAPAV1@@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@AAPAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PAVEnemy@@AAPAV1@@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@AAPAV2@@Z$0
__ehfuncinfo$??$construct@PAVEnemy@@AAPAV1@@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@AAPAV2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PAVEnemy@@AAPAV1@@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@AAPAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$6
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$4
	DD	01H
	DD	00H
	DD	01H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PAVBullet@@AAPAV1@@?$allocator@PAVBullet@@@std@@QAEXPAPAVBullet@@AAPAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PAVBullet@@AAPAV1@@?$allocator@PAVBullet@@@std@@QAEXPAPAVBullet@@AAPAV2@@Z$0
__ehfuncinfo$??$construct@PAVBullet@@AAPAV1@@?$allocator@PAVBullet@@@std@@QAEXPAPAVBullet@@AAPAV2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PAVBullet@@AAPAV1@@?$allocator@PAVBullet@@@std@@QAEXPAPAVBullet@@AAPAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PAVLivingEntity@@AAPAV1@@?$allocator@PAVLivingEntity@@@std@@QAEXPAPAVLivingEntity@@AAPAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PAVLivingEntity@@AAPAV1@@?$allocator@PAVLivingEntity@@@std@@QAEXPAPAVLivingEntity@@AAPAV2@@Z$0
__ehfuncinfo$??$construct@PAVLivingEntity@@AAPAV1@@?$allocator@PAVLivingEntity@@@std@@QAEXPAPAVLivingEntity@@AAPAV2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PAVLivingEntity@@AAPAV1@@?$allocator@PAVLivingEntity@@@std@@QAEXPAPAVLivingEntity@@AAPAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PAVOnScreen@@AAPAV1@@?$allocator@PAVOnScreen@@@std@@QAEXPAPAVOnScreen@@AAPAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PAVOnScreen@@AAPAV1@@?$allocator@PAVOnScreen@@@std@@QAEXPAPAVOnScreen@@AAPAV2@@Z$0
__ehfuncinfo$??$construct@PAVOnScreen@@AAPAV1@@?$allocator@PAVOnScreen@@@std@@QAEXPAPAVOnScreen@@AAPAV2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PAVOnScreen@@AAPAV1@@?$allocator@PAVOnScreen@@@std@@QAEXPAPAVOnScreen@@AAPAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z$2
__ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
__ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@1@0PAPAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@1@0PAPAV2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@1@0PAPAV2@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@1@0PAPAV2@@Z$2
__ehfuncinfo$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@1@0PAPAV2@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@1@0PAPAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$_main DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$_main
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$_main DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_main$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_main$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_main$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_main$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_main$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_main$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?levelOne@@YAXPAVScreen@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?levelOne@@YAXPAVScreen@@@Z$0
__ehfuncinfo$?levelOne@@YAXPAVScreen@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?levelOne@@YAXPAVScreen@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?processaibysingle@@YAPAXPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?processaibysingle@@YAPAXPAX@Z$2
__ehfuncinfo$?processaibysingle@@YAPAXPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?processaibysingle@@YAPAXPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0
__tryblocktable$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$3
__unwindtable$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?render@Screen@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?render@Screen@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?render@Screen@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?render@Screen@@QAEXXZ$3
__ehfuncinfo$?render@Screen@@QAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?render@Screen@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?shoot@EnemySoldier@@UAEXW4Directions@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?shoot@EnemySoldier@@UAEXW4Directions@@@Z$0
__ehfuncinfo$?shoot@EnemySoldier@@UAEXW4Directions@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?shoot@EnemySoldier@@UAEXW4Directions@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE?AV01@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE?AV01@H@Z$0
__ehfuncinfo$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE?AV01@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE?AV01@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@PAPAVEnemy@@PBU_Container_base12@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@PAPAVEnemy@@PBU_Container_base12@1@@Z$0
__ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@PAPAVEnemy@@PBU_Container_base12@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@PAPAVEnemy@@PBU_Container_base12@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Orphan_range@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEXPAPAVEnemy@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_range@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEXPAPAVEnemy@@0@Z$0
__ehfuncinfo$?_Orphan_range@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEXPAPAVEnemy@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_range@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEXPAPAVEnemy@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z$0
__ehfuncinfo$?erase@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Make_iter@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Make_iter@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z$0
__ehfuncinfo$?_Make_iter@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Make_iter@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@$$QAV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@$$QAV01@@Z$0
__ehfuncinfo$??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@$$QAV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@$$QAV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV01@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV01@@Z$5
__unwindtable$??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEnemy@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEnemy@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEnemy@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEnemy@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?getEnemies@Enemy@@SA?AV?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getEnemies@Enemy@@SA?AV?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@XZ$0
__ehfuncinfo$?getEnemies@Enemy@@SA?AV?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getEnemies@Enemy@@SA?AV?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?aiTurn@Enemy@@SAXPAVLivingEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?aiTurn@Enemy@@SAXPAVLivingEntity@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?aiTurn@Enemy@@SAXPAVLivingEntity@@@Z$2
__ehfuncinfo$?aiTurn@Enemy@@SAXPAVLivingEntity@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?aiTurn@Enemy@@SAXPAVLivingEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1Enemy@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Enemy@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1Enemy@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1Enemy@@UAE@XZ$3
__ehfuncinfo$??1Enemy@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1Enemy@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Enemy@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Enemy@@QAE@XZ$0
__ehfuncinfo$??0Enemy@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Enemy@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?shoot@Player@@UAEXW4Directions@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?shoot@Player@@UAEXW4Directions@@@Z$0
__ehfuncinfo$?shoot@Player@@UAEXW4Directions@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?shoot@Player@@UAEXW4Directions@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Player@@QAE@HHMHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Directions@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Player@@QAE@HHMHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Directions@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Player@@QAE@HHMHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Directions@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Player@@QAE@HHMHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Directions@@@Z$2
__ehfuncinfo$??0Player@@QAE@HHMHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Directions@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0Player@@QAE@HHMHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Directions@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE?AV01@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE?AV01@H@Z$0
__ehfuncinfo$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE?AV01@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE?AV01@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@PAPAVBullet@@PBU_Container_base12@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@PAPAVBullet@@PBU_Container_base12@1@@Z$0
__ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@PAPAVBullet@@PBU_Container_base12@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@PAPAVBullet@@PBU_Container_base12@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Orphan_range@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEXPAPAVBullet@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_range@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEXPAPAVBullet@@0@Z$0
__ehfuncinfo$?_Orphan_range@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEXPAPAVBullet@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_range@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEXPAPAVBullet@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z$0
__ehfuncinfo$?erase@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Make_iter@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Make_iter@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z$0
__ehfuncinfo$?_Make_iter@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Make_iter@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVBullet@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVBullet@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVBullet@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVBullet@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?renderBullets@Bullet@@SAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?renderBullets@Bullet@@SAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?renderBullets@Bullet@@SAXXZ$2
__ehfuncinfo$?renderBullets@Bullet@@SAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?renderBullets@Bullet@@SAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1Bullet@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Bullet@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1Bullet@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1Bullet@@UAE@XZ$3
__ehfuncinfo$??1Bullet@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1Bullet@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Bullet@@QAE@HW4Directions@@HHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Bullet@@QAE@HW4Directions@@HHH@Z$0
__ehfuncinfo$??0Bullet@@QAE@HW4Directions@@HHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Bullet@@QAE@HW4Directions@@HHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE?AV01@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE?AV01@H@Z$0
__ehfuncinfo$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE?AV01@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE?AV01@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@PAPAVLivingEntity@@PBU_Container_base12@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@PAPAVLivingEntity@@PBU_Container_base12@1@@Z$0
__ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@PAPAVLivingEntity@@PBU_Container_base12@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@PAPAVLivingEntity@@PBU_Container_base12@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Orphan_range@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEXPAPAVLivingEntity@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_range@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEXPAPAVLivingEntity@@0@Z$0
__ehfuncinfo$?_Orphan_range@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEXPAPAVLivingEntity@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_range@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEXPAPAVLivingEntity@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z$0
__ehfuncinfo$?erase@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Make_iter@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Make_iter@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z$0
__ehfuncinfo$?_Make_iter@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Make_iter@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVLivingEntity@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVLivingEntity@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVLivingEntity@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVLivingEntity@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1LivingEntity@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1LivingEntity@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1LivingEntity@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1LivingEntity@@UAE@XZ$3
__ehfuncinfo$??1LivingEntity@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1LivingEntity@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0LivingEntity@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0LivingEntity@@QAE@XZ$0
__ehfuncinfo$??0LivingEntity@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0LivingEntity@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE?AV01@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE?AV01@H@Z$0
__ehfuncinfo$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE?AV01@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE?AV01@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@PAPAVOnScreen@@PBU_Container_base12@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@PAPAVOnScreen@@PBU_Container_base12@1@@Z$0
__ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@PAPAVOnScreen@@PBU_Container_base12@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@PAPAVOnScreen@@PBU_Container_base12@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Orphan_range@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEXPAPAVOnScreen@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_range@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEXPAPAVOnScreen@@0@Z$0
__ehfuncinfo$?_Orphan_range@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEXPAPAVOnScreen@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_range@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEXPAPAVOnScreen@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z$0
__ehfuncinfo$?erase@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Make_iter@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Make_iter@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z$0
__ehfuncinfo$?_Make_iter@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Make_iter@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVOnScreen@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVOnScreen@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVOnScreen@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVOnScreen@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1OnScreen@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1OnScreen@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1OnScreen@@UAE@XZ$2
__ehfuncinfo$??1OnScreen@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1OnScreen@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$3
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
__ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1
__ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0
__ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?visibleItems$initializer$@OnScreen@@2P6AXXZA DD FLAT:??__E?visibleItems@OnScreen@@2V?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@A@@YAXXZ ; OnScreen::visibleItems$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?livingThings$initializer$@LivingEntity@@2P6AXXZA DD FLAT:??__E?livingThings@LivingEntity@@2V?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@A@@YAXXZ ; LivingEntity::livingThings$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?bullets$initializer$@Bullet@@1P6AXXZA DD FLAT:??__E?bullets@Bullet@@1V?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@A@@YAXXZ ; Bullet::bullets$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?enemies$initializer$@Enemy@@1P6AXXZA DD FLAT:??__E?enemies@Enemy@@1V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@A@@YAXXZ ; Enemy::enemies$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVEnemy@@@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAVEnemy@@@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@@Z PROC ; std::allocator<Enemy *>::destroy<Enemy *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAVEnemy@@@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@@Z ENDP ; std::allocator<Enemy *>::destroy<Enemy *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@PB_WI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Debug_pointer@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@PB_WI@Z PROC ; std::_Debug_pointer<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > > >, COMDAT

; 605  : 	{	// test pointer for non-singularity, arbitrary type

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 606  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_pointer@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@PB_WI@Z ENDP ; std::_Debug_pointer<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Debug_range2@PAPAVEnemy@@@std@@YAXPAPAVEnemy@@0PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Debug_range2@PAPAVEnemy@@@std@@YAXPAPAVEnemy@@0PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range2<Enemy * *>, COMDAT

; 635  : 	{	// test iterator pair for valid range, random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 636  : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN3@Debug_rang

; 637  : 		{	// check for non-null pointers, valid range
; 638  : 		_DEBUG_POINTER2(_First, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Debug_pointer@PAVEnemy@@@std@@YAXPAPAVEnemy@@PB_WI@Z ; std::_Debug_pointer<Enemy *>
	add	esp, 12					; 0000000cH

; 639  : 		_DEBUG_POINTER2(_Last, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Debug_pointer@PAVEnemy@@@std@@YAXPAPAVEnemy@@PB_WI@Z ; std::_Debug_pointer<Enemy *>
	add	esp, 12					; 0000000cH

; 640  : 		if (_Last < _First)

	mov	eax, DWORD PTR __Last$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jae	SHORT $LN3@Debug_rang

; 641  : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Debug_rang:

; 642  : 		}
; 643  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_range2@PAPAVEnemy@@@std@@YAXPAPAVEnemy@@0PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range2<Enemy * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAPAVEnemy@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVEnemy@@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVEnemy@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVEnemy@@@Z PROC ; std::_Iter_cat<Enemy * *>, COMDAT

; 398  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 399  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 400  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR __Cat$[ebp]
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 401  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iter_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Iter_cat:
	DD	1
	DD	$LN4@Iter_cat
$LN4@Iter_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Iter_cat
$LN3@Iter_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Iter_cat@PAPAVEnemy@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVEnemy@@@Z ENDP ; std::_Iter_cat<Enemy * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Debug_range2@PAPAVBullet@@@std@@YAXPAPAVBullet@@0PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Debug_range2@PAPAVBullet@@@std@@YAXPAPAVBullet@@0PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range2<Bullet * *>, COMDAT

; 635  : 	{	// test iterator pair for valid range, random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 636  : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN3@Debug_rang

; 637  : 		{	// check for non-null pointers, valid range
; 638  : 		_DEBUG_POINTER2(_First, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Debug_pointer@PAVBullet@@@std@@YAXPAPAVBullet@@PB_WI@Z ; std::_Debug_pointer<Bullet *>
	add	esp, 12					; 0000000cH

; 639  : 		_DEBUG_POINTER2(_Last, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Debug_pointer@PAVBullet@@@std@@YAXPAPAVBullet@@PB_WI@Z ; std::_Debug_pointer<Bullet *>
	add	esp, 12					; 0000000cH

; 640  : 		if (_Last < _First)

	mov	eax, DWORD PTR __Last$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jae	SHORT $LN3@Debug_rang

; 641  : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Debug_rang:

; 642  : 		}
; 643  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_range2@PAPAVBullet@@@std@@YAXPAPAVBullet@@0PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range2<Bullet * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAPAVBullet@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBullet@@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVBullet@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBullet@@@Z PROC ; std::_Iter_cat<Bullet * *>, COMDAT

; 398  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 399  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 400  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR __Cat$[ebp]
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 401  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iter_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Iter_cat:
	DD	1
	DD	$LN4@Iter_cat
$LN4@Iter_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Iter_cat
$LN3@Iter_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Iter_cat@PAPAVBullet@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBullet@@@Z ENDP ; std::_Iter_cat<Bullet * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Debug_range2@PAPAVLivingEntity@@@std@@YAXPAPAVLivingEntity@@0PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Debug_range2@PAPAVLivingEntity@@@std@@YAXPAPAVLivingEntity@@0PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range2<LivingEntity * *>, COMDAT

; 635  : 	{	// test iterator pair for valid range, random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 636  : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN3@Debug_rang

; 637  : 		{	// check for non-null pointers, valid range
; 638  : 		_DEBUG_POINTER2(_First, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Debug_pointer@PAVLivingEntity@@@std@@YAXPAPAVLivingEntity@@PB_WI@Z ; std::_Debug_pointer<LivingEntity *>
	add	esp, 12					; 0000000cH

; 639  : 		_DEBUG_POINTER2(_Last, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Debug_pointer@PAVLivingEntity@@@std@@YAXPAPAVLivingEntity@@PB_WI@Z ; std::_Debug_pointer<LivingEntity *>
	add	esp, 12					; 0000000cH

; 640  : 		if (_Last < _First)

	mov	eax, DWORD PTR __Last$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jae	SHORT $LN3@Debug_rang

; 641  : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Debug_rang:

; 642  : 		}
; 643  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_range2@PAPAVLivingEntity@@@std@@YAXPAPAVLivingEntity@@0PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range2<LivingEntity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAPAVLivingEntity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVLivingEntity@@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVLivingEntity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVLivingEntity@@@Z PROC ; std::_Iter_cat<LivingEntity * *>, COMDAT

; 398  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 399  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 400  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR __Cat$[ebp]
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 401  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iter_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Iter_cat:
	DD	1
	DD	$LN4@Iter_cat
$LN4@Iter_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Iter_cat
$LN3@Iter_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Iter_cat@PAPAVLivingEntity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVLivingEntity@@@Z ENDP ; std::_Iter_cat<LivingEntity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Debug_range2@PAPAVOnScreen@@@std@@YAXPAPAVOnScreen@@0PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Debug_range2@PAPAVOnScreen@@@std@@YAXPAPAVOnScreen@@0PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range2<OnScreen * *>, COMDAT

; 635  : 	{	// test iterator pair for valid range, random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 636  : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN3@Debug_rang

; 637  : 		{	// check for non-null pointers, valid range
; 638  : 		_DEBUG_POINTER2(_First, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Debug_pointer@PAVOnScreen@@@std@@YAXPAPAVOnScreen@@PB_WI@Z ; std::_Debug_pointer<OnScreen *>
	add	esp, 12					; 0000000cH

; 639  : 		_DEBUG_POINTER2(_Last, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Debug_pointer@PAVOnScreen@@@std@@YAXPAPAVOnScreen@@PB_WI@Z ; std::_Debug_pointer<OnScreen *>
	add	esp, 12					; 0000000cH

; 640  : 		if (_Last < _First)

	mov	eax, DWORD PTR __Last$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jae	SHORT $LN3@Debug_rang

; 641  : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Debug_rang:

; 642  : 		}
; 643  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_range2@PAPAVOnScreen@@@std@@YAXPAPAVOnScreen@@0PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range2<OnScreen * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAPAVOnScreen@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVOnScreen@@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVOnScreen@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVOnScreen@@@Z PROC ; std::_Iter_cat<OnScreen * *>, COMDAT

; 398  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 399  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 400  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR __Cat$[ebp]
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 401  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iter_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Iter_cat:
	DD	1
	DD	$LN4@Iter_cat
$LN4@Iter_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Iter_cat
$LN3@Iter_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Iter_cat@PAPAVOnScreen@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVOnScreen@@@Z ENDP ; std::_Iter_cat<OnScreen * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVEnemy@@@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SAXAAV?$allocator@PAVEnemy@@@1@PAPAVEnemy@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAVEnemy@@@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SAXAAV?$allocator@PAVEnemy@@@1@PAPAVEnemy@@@Z PROC ; std::allocator_traits<std::allocator<Enemy *> >::destroy<Enemy *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAVEnemy@@@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@@Z ; std::allocator<Enemy *>::destroy<Enemy *>

; 758  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$destroy@PAVEnemy@@@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SAXAAV?$allocator@PAVEnemy@@@1@PAPAVEnemy@@@Z ENDP ; std::allocator_traits<std::allocator<Enemy *> >::destroy<Enemy *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Debug_range2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__File$ = 32						; size = 4
__Line$ = 36						; size = 4
___formal$ = 40						; size = 1
??$_Debug_range2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range2<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > > >, COMDAT

; 635  : 	{	// test iterator pair for valid range, random-access iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Debug_range2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 636  : 	if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Debug_rang

; 637  : 		{	// check for non-null pointers, valid range
; 638  : 		_DEBUG_POINTER2(_First, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Debug_pointer@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > > >
	add	esp, 12					; 0000000cH

; 639  : 		_DEBUG_POINTER2(_Last, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Debug_pointer@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > > >
	add	esp, 12					; 0000000cH

; 640  : 		if (_Last < _First)

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator<
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Debug_rang

; 641  : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Debug_rang:

; 642  : 		}
; 643  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Debug_range2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Debug_range2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Debug_range2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Debug_range2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range2<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > > >, COMDAT

; 398  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 399  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 400  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR __Cat$[ebp]
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 401  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iter_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Iter_cat:
	DD	1
	DD	$LN4@Iter_cat
$LN4@Iter_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Iter_cat
$LN3@Iter_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Iter_cat@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64>, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from representation

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Debug_range@PAPAVEnemy@@@std@@YAXPAPAVEnemy@@0PB_WI@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
??$_Debug_range@PAPAVEnemy@@@std@@YAXPAPAVEnemy@@0PB_WI@Z PROC ; std::_Debug_range<Enemy * *>, COMDAT

; 648  : 	{	// test iterator pair for valid range

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 649  : 	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$_Iter_cat@PAPAVEnemy@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVEnemy@@@Z ; std::_Iter_cat<Enemy * *>
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR __Line$[ebp]
	push	ecx
	mov	edx, DWORD PTR __File$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range2@PAPAVEnemy@@@std@@YAXPAPAVEnemy@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<Enemy * *>
	add	esp, 20					; 00000014H

; 650  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_range@PAPAVEnemy@@@std@@YAXPAPAVEnemy@@0PB_WI@Z ENDP ; std::_Debug_range<Enemy * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@PAVBullet@@@std@@YAXPAPAVBullet@@PB_WI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__File$ = 12						; size = 4
__Line$ = 16						; size = 4
??$_Debug_pointer@PAVBullet@@@std@@YAXPAPAVBullet@@PB_WI@Z PROC ; std::_Debug_pointer<Bullet *>, COMDAT

; 617  : 	{	// test iterator for non-singularity, pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 618  : 	if (_First == 0)

	cmp	DWORD PTR __First$[ebp], 0
	jne	SHORT $LN2@Debug_poin

; 619  : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Debug_poin:

; 620  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_pointer@PAVBullet@@@std@@YAXPAPAVBullet@@PB_WI@Z ENDP ; std::_Debug_pointer<Bullet *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Debug_range@PAPAVBullet@@@std@@YAXPAPAVBullet@@0PB_WI@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
??$_Debug_range@PAPAVBullet@@@std@@YAXPAPAVBullet@@0PB_WI@Z PROC ; std::_Debug_range<Bullet * *>, COMDAT

; 648  : 	{	// test iterator pair for valid range

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 649  : 	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$_Iter_cat@PAPAVBullet@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVBullet@@@Z ; std::_Iter_cat<Bullet * *>
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR __Line$[ebp]
	push	ecx
	mov	edx, DWORD PTR __File$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range2@PAPAVBullet@@@std@@YAXPAPAVBullet@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<Bullet * *>
	add	esp, 20					; 00000014H

; 650  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_range@PAPAVBullet@@@std@@YAXPAPAVBullet@@0PB_WI@Z ENDP ; std::_Debug_range<Bullet * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@PAVLivingEntity@@@std@@YAXPAPAVLivingEntity@@PB_WI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__File$ = 12						; size = 4
__Line$ = 16						; size = 4
??$_Debug_pointer@PAVLivingEntity@@@std@@YAXPAPAVLivingEntity@@PB_WI@Z PROC ; std::_Debug_pointer<LivingEntity *>, COMDAT

; 617  : 	{	// test iterator for non-singularity, pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 618  : 	if (_First == 0)

	cmp	DWORD PTR __First$[ebp], 0
	jne	SHORT $LN2@Debug_poin

; 619  : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Debug_poin:

; 620  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_pointer@PAVLivingEntity@@@std@@YAXPAPAVLivingEntity@@PB_WI@Z ENDP ; std::_Debug_pointer<LivingEntity *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Debug_range@PAPAVLivingEntity@@@std@@YAXPAPAVLivingEntity@@0PB_WI@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
??$_Debug_range@PAPAVLivingEntity@@@std@@YAXPAPAVLivingEntity@@0PB_WI@Z PROC ; std::_Debug_range<LivingEntity * *>, COMDAT

; 648  : 	{	// test iterator pair for valid range

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 649  : 	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$_Iter_cat@PAPAVLivingEntity@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVLivingEntity@@@Z ; std::_Iter_cat<LivingEntity * *>
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR __Line$[ebp]
	push	ecx
	mov	edx, DWORD PTR __File$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range2@PAPAVLivingEntity@@@std@@YAXPAPAVLivingEntity@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<LivingEntity * *>
	add	esp, 20					; 00000014H

; 650  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_range@PAPAVLivingEntity@@@std@@YAXPAPAVLivingEntity@@0PB_WI@Z ENDP ; std::_Debug_range<LivingEntity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@PAVOnScreen@@@std@@YAXPAPAVOnScreen@@PB_WI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__File$ = 12						; size = 4
__Line$ = 16						; size = 4
??$_Debug_pointer@PAVOnScreen@@@std@@YAXPAPAVOnScreen@@PB_WI@Z PROC ; std::_Debug_pointer<OnScreen *>, COMDAT

; 617  : 	{	// test iterator for non-singularity, pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 618  : 	if (_First == 0)

	cmp	DWORD PTR __First$[ebp], 0
	jne	SHORT $LN2@Debug_poin

; 619  : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Debug_poin:

; 620  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_pointer@PAVOnScreen@@@std@@YAXPAPAVOnScreen@@PB_WI@Z ENDP ; std::_Debug_pointer<OnScreen *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Debug_range@PAPAVOnScreen@@@std@@YAXPAPAVOnScreen@@0PB_WI@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
??$_Debug_range@PAPAVOnScreen@@@std@@YAXPAPAVOnScreen@@0PB_WI@Z PROC ; std::_Debug_range<OnScreen * *>, COMDAT

; 648  : 	{	// test iterator pair for valid range

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 649  : 	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$_Iter_cat@PAPAVOnScreen@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVOnScreen@@@Z ; std::_Iter_cat<OnScreen * *>
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR __Line$[ebp]
	push	ecx
	mov	edx, DWORD PTR __File$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range2@PAPAVOnScreen@@@std@@YAXPAPAVOnScreen@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<OnScreen * *>
	add	esp, 20					; 00000014H

; 650  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_range@PAPAVOnScreen@@@std@@YAXPAPAVOnScreen@@0PB_WI@Z ENDP ; std::_Debug_range<OnScreen * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVEnemy@@@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEXPAPAVEnemy@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAVEnemy@@@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEXPAPAVEnemy@@@Z PROC ; std::_Wrap_alloc<std::allocator<Enemy *> >::destroy<Enemy *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAVEnemy@@@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SAXAAV?$allocator@PAVEnemy@@@1@PAPAVEnemy@@@Z ; std::allocator_traits<std::allocator<Enemy *> >::destroy<Enemy *>
	add	esp, 8

; 910  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAVEnemy@@@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEXPAPAVEnemy@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Enemy *> >::destroy<Enemy *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@PAVEnemy@@@std@@YAXPAPAVEnemy@@PB_WI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__File$ = 12						; size = 4
__Line$ = 16						; size = 4
??$_Debug_pointer@PAVEnemy@@@std@@YAXPAPAVEnemy@@PB_WI@Z PROC ; std::_Debug_pointer<Enemy *>, COMDAT

; 617  : 	{	// test iterator for non-singularity, pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 618  : 	if (_First == 0)

	cmp	DWORD PTR __First$[ebp], 0
	jne	SHORT $LN2@Debug_poin

; 619  : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Debug_poin:

; 620  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_pointer@PAVEnemy@@@std@@YAXPAPAVEnemy@@PB_WI@Z ENDP ; std::_Debug_pointer<Enemy *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Debug_range@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WI@Z
_TEXT	SEGMENT
tv140 = -252						; size = 4
tv137 = -248						; size = 4
tv143 = -244						; size = 4
$T2 = -233						; size = 1
$T3 = -224						; size = 4
$T4 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__File$ = 32						; size = 4
__Line$ = 36						; size = 4
??$_Debug_range@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WI@Z PROC ; std::_Debug_range<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > > >, COMDAT

; 648  : 	{	// test iterator pair for valid range

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Debug_range@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 649  : 	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??$_Iter_cat@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > > >
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR __Line$[ebp]
	push	ecx
	mov	edx, DWORD PTR __File$[ebp]
	push	edx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv143[ebp], eax
	mov	ecx, DWORD PTR tv143[ebp]
	mov	DWORD PTR tv137[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv140[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$_Debug_range2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > > >
	add	esp, 36					; 00000024H

; 650  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Debug_range@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WI@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WI@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WI@Z$2:
	mov	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Debug_range@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Debug_range@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Debug_range@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WI@Z ENDP ; std::_Debug_range<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$00@std@@@01@@Z
_TEXT	SEGMENT
$T1 = -252						; size = 8
$T2 = -236						; size = 8
$T3 = -220						; size = 8
$T4 = -204						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$00@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1> >, COMDAT

; 535  : 	{	// convert duration to another duration

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 536  : 	typedef typename ratio_divide<_Period, typename _To::period>::type _CF;
; 537  : 	typedef typename common_type<
; 538  : 		typename common_type<typename _To::rep, _Rep>::type,
; 539  : 			intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)

	xor	eax, eax
	je	SHORT $LN6@duration_c

; 541  : 		return (_To(static_cast<typename _To::rep>(_Dur.count())));

	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
	mov	DWORD PTR $T1[ebp], eax
	mov	DWORD PTR $T1[ebp+4], edx
	push	0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN7@duration_c
	jmp	$LN7@duration_c
$LN6@duration_c:

; 542  : 	else if (_CF::num != 1 && _CF::den == 1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN4@duration_c

; 543  : 		return (_To(static_cast<typename _To::rep>(

	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
	push	0
	push	1000000000				; 3b9aca00H
	push	edx
	push	eax
	call	__allmul
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR $T2[ebp+4], edx
	push	0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN7@duration_c
	jmp	SHORT $LN7@duration_c
$LN4@duration_c:

; 544  : 			static_cast<_CR>(_Dur.count())) * static_cast<_CR>(_CF::num)));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)

	xor	eax, eax
	je	SHORT $LN2@duration_c

; 546  : 		return (_To(static_cast<typename _To::rep>(

	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR $T3[ebp+4], edx
	push	0
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN7@duration_c

; 547  : 			static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den))));
; 548  : 	else

	jmp	SHORT $LN7@duration_c
$LN2@duration_c:

; 549  : 		return (_To(static_cast<typename _To::rep>(

	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
	push	0
	push	1000000000				; 3b9aca00H
	push	edx
	push	eax
	call	__allmul
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR $T4[ebp+4], edx
	push	0
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN7@duration_c:

; 550  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
; 551  : 			/ static_cast<_CR>(_CF::den))));
; 552  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$00@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z
_TEXT	SEGMENT
$T1 = -252						; size = 8
$T2 = -236						; size = 8
$T3 = -220						; size = 8
$T4 = -204						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000> >, COMDAT

; 535  : 	{	// convert duration to another duration

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 536  : 	typedef typename ratio_divide<_Period, typename _To::period>::type _CF;
; 537  : 	typedef typename common_type<
; 538  : 		typename common_type<typename _To::rep, _Rep>::type,
; 539  : 			intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)

	xor	eax, eax
	je	SHORT $LN6@duration_c

; 541  : 		return (_To(static_cast<typename _To::rep>(_Dur.count())));

	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
	mov	DWORD PTR $T1[ebp], eax
	mov	DWORD PTR $T1[ebp+4], edx
	push	0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN7@duration_c
	jmp	$LN7@duration_c
$LN6@duration_c:

; 542  : 	else if (_CF::num != 1 && _CF::den == 1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN4@duration_c

; 543  : 		return (_To(static_cast<typename _To::rep>(

	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
	push	0
	push	1000000					; 000f4240H
	push	edx
	push	eax
	call	__allmul
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR $T2[ebp+4], edx
	push	0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN7@duration_c
	jmp	SHORT $LN7@duration_c
$LN4@duration_c:

; 544  : 			static_cast<_CR>(_Dur.count())) * static_cast<_CR>(_CF::num)));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)

	xor	eax, eax
	je	SHORT $LN2@duration_c

; 546  : 		return (_To(static_cast<typename _To::rep>(

	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR $T3[ebp+4], edx
	push	0
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN7@duration_c

; 547  : 			static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den))));
; 548  : 	else

	jmp	SHORT $LN7@duration_c
$LN2@duration_c:

; 549  : 		return (_To(static_cast<typename _To::rep>(

	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
	push	0
	push	1000000					; 000f4240H
	push	edx
	push	eax
	call	__allmul
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR $T4[ebp+4], edx
	push	0
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN7@duration_c:

; 550  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
; 551  : 			/ static_cast<_CR>(_CF::den))));
; 552  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z
_TEXT	SEGMENT
$T1 = -252						; size = 8
$T2 = -236						; size = 8
$T3 = -220						; size = 8
$T4 = -204						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,10000000> >, COMDAT

; 535  : 	{	// convert duration to another duration

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 536  : 	typedef typename ratio_divide<_Period, typename _To::period>::type _CF;
; 537  : 	typedef typename common_type<
; 538  : 		typename common_type<typename _To::rep, _Rep>::type,
; 539  : 			intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)

	xor	eax, eax
	je	SHORT $LN6@duration_c

; 541  : 		return (_To(static_cast<typename _To::rep>(_Dur.count())));

	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
	mov	DWORD PTR $T1[ebp], eax
	mov	DWORD PTR $T1[ebp+4], edx
	push	0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN7@duration_c
	jmp	$LN7@duration_c
$LN6@duration_c:

; 542  : 	else if (_CF::num != 1 && _CF::den == 1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN4@duration_c

; 543  : 		return (_To(static_cast<typename _To::rep>(

	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
	push	0
	push	100					; 00000064H
	push	edx
	push	eax
	call	__allmul
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR $T2[ebp+4], edx
	push	0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN7@duration_c
	jmp	SHORT $LN7@duration_c
$LN4@duration_c:

; 544  : 			static_cast<_CR>(_Dur.count())) * static_cast<_CR>(_CF::num)));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)

	xor	eax, eax
	je	SHORT $LN2@duration_c

; 546  : 		return (_To(static_cast<typename _To::rep>(

	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR $T3[ebp+4], edx
	push	0
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN7@duration_c

; 547  : 			static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den))));
; 548  : 	else

	jmp	SHORT $LN7@duration_c
$LN2@duration_c:

; 549  : 		return (_To(static_cast<typename _To::rep>(

	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
	push	0
	push	100					; 00000064H
	push	edx
	push	eax
	call	__allmul
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR $T4[ebp+4], edx
	push	0
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0_J@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN7@duration_c:

; 550  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
; 551  : 			/ static_cast<_CR>(_CF::den))));
; 552  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,10000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$?M_JU?$ratio@$00$0DOI@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@0@Z
_TEXT	SEGMENT
tv71 = -244						; size = 4
tv94 = -240						; size = 8
tv91 = -232						; size = 8
$T1 = -220						; size = 8
$T2 = -204						; size = 8
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?M_JU?$ratio@$00$0DOI@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@0@Z PROC ; std::chrono::operator<<__int64,std::ratio<1,1000>,__int64,std::ratio<1,1000> >, COMDAT

; 488  : 	{	// test if duration < duration

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 489  : 	typedef typename common_type<
; 490  : 		duration<_Rep1, _Period1>,
; 491  : 		duration<_Rep2, _Period2> >::type _CT;
; 492  : 	return (_CT(_Left).count() < _CT(_Right).count());

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], ecx
	mov	DWORD PTR $T1[ebp+4], edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR $T2[ebp+4], edx
	lea	ecx, DWORD PTR $T1[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
	mov	esi, eax
	mov	edi, edx
	lea	ecx, DWORD PTR $T2[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
	mov	DWORD PTR tv91[ebp], esi
	mov	DWORD PTR tv91[ebp+4], edi
	mov	DWORD PTR tv94[ebp], eax
	mov	DWORD PTR tv94[ebp+4], edx
	mov	eax, DWORD PTR tv91[ebp+4]
	cmp	eax, DWORD PTR tv94[ebp+4]
	jg	SHORT $LN3@operator
	jl	SHORT $LN5@operator
	mov	ecx, DWORD PTR tv91[ebp]
	cmp	ecx, DWORD PTR tv94[ebp]
	jae	SHORT $LN3@operator
$LN5@operator:
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv71[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv71[ebp]

; 493  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?M_JU?$ratio@$00$0DOI@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@0@Z ENDP ; std::chrono::operator<<__int64,std::ratio<1,1000>,__int64,std::ratio<1,1000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$?0_J@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@AB_JPAPAX@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?0_J@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@AB_JPAPAX@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><__int64>, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from representation

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0_J@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><__int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ?zero@?$duration_values@_J@chrono@std@@SA_JXZ
_TEXT	SEGMENT
?zero@?$duration_values@_J@chrono@std@@SA_JXZ PROC	; std::chrono::duration_values<__int64>::zero, COMDAT

; 33   : 		{	// get zero value

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 34   : 		return (_Rep(0));

	xor	eax, eax
	xor	edx, edx

; 35   : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?zero@?$duration_values@_J@chrono@std@@SA_JXZ ENDP	; std::chrono::duration_values<__int64>::zero
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAVEnemy@@PAV1@PAV1@@std@@YAPAPAVEnemy@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVEnemy@@PAV1@PAV1@@std@@YAPAPAVEnemy@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<Enemy *,Enemy *,Enemy *>, COMDAT

; 458  : 	{	// move [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 459  : 	_DEBUG_RANGE(_First, _Last);

	push	459					; 000001cbH
	push	OFFSET ??_C@_1IO@NPCEFBKE@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range@PAPAVEnemy@@@std@@YAXPAPAVEnemy@@0PB_WI@Z ; std::_Debug_range<Enemy * *>
	add	esp, 16					; 00000010H

; 460  : 	_DEBUG_POINTER(_Dest);

	push	460					; 000001ccH
	push	OFFSET ??_C@_1IO@NPCEFBKE@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Debug_pointer@PAVEnemy@@@std@@YAXPAPAVEnemy@@PB_WI@Z ; std::_Debug_pointer<Enemy *>
	add	esp, 12					; 0000000cH

; 461  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 462  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 463  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]

; 464  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_move@PAVEnemy@@PAV1@PAV1@@std@@YAPAPAVEnemy@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Enemy *,Enemy *,Enemy *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVEnemy@@@std@@YAPAPAVEnemy@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVEnemy@@@std@@YAPAPAVEnemy@@PAPAV1@@Z PROC ; std::_Val_type<Enemy * *>, COMDAT

; 710  : 	{	// return value type from arbitrary argument

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 711  : 	return (0);

	xor	eax, eax

; 712  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Val_type@PAPAVEnemy@@@std@@YAPAPAVEnemy@@PAPAV1@@Z ENDP ; std::_Val_type<Enemy * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAVBullet@@PAV1@PAV1@@std@@YAPAPAVBullet@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVBullet@@PAV1@PAV1@@std@@YAPAPAVBullet@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<Bullet *,Bullet *,Bullet *>, COMDAT

; 458  : 	{	// move [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 459  : 	_DEBUG_RANGE(_First, _Last);

	push	459					; 000001cbH
	push	OFFSET ??_C@_1IO@NPCEFBKE@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range@PAPAVBullet@@@std@@YAXPAPAVBullet@@0PB_WI@Z ; std::_Debug_range<Bullet * *>
	add	esp, 16					; 00000010H

; 460  : 	_DEBUG_POINTER(_Dest);

	push	460					; 000001ccH
	push	OFFSET ??_C@_1IO@NPCEFBKE@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Debug_pointer@PAVBullet@@@std@@YAXPAPAVBullet@@PB_WI@Z ; std::_Debug_pointer<Bullet *>
	add	esp, 12					; 0000000cH

; 461  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 462  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 463  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]

; 464  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_move@PAVBullet@@PAV1@PAV1@@std@@YAPAPAVBullet@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Bullet *,Bullet *,Bullet *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVBullet@@@std@@YAPAPAVBullet@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVBullet@@@std@@YAPAPAVBullet@@PAPAV1@@Z PROC ; std::_Val_type<Bullet * *>, COMDAT

; 710  : 	{	// return value type from arbitrary argument

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 711  : 	return (0);

	xor	eax, eax

; 712  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Val_type@PAPAVBullet@@@std@@YAPAPAVBullet@@PAPAV1@@Z ENDP ; std::_Val_type<Bullet * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAVLivingEntity@@PAV1@PAV1@@std@@YAPAPAVLivingEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVLivingEntity@@PAV1@PAV1@@std@@YAPAPAVLivingEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<LivingEntity *,LivingEntity *,LivingEntity *>, COMDAT

; 458  : 	{	// move [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 459  : 	_DEBUG_RANGE(_First, _Last);

	push	459					; 000001cbH
	push	OFFSET ??_C@_1IO@NPCEFBKE@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range@PAPAVLivingEntity@@@std@@YAXPAPAVLivingEntity@@0PB_WI@Z ; std::_Debug_range<LivingEntity * *>
	add	esp, 16					; 00000010H

; 460  : 	_DEBUG_POINTER(_Dest);

	push	460					; 000001ccH
	push	OFFSET ??_C@_1IO@NPCEFBKE@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Debug_pointer@PAVLivingEntity@@@std@@YAXPAPAVLivingEntity@@PB_WI@Z ; std::_Debug_pointer<LivingEntity *>
	add	esp, 12					; 0000000cH

; 461  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 462  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 463  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]

; 464  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_move@PAVLivingEntity@@PAV1@PAV1@@std@@YAPAPAVLivingEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<LivingEntity *,LivingEntity *,LivingEntity *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVLivingEntity@@@std@@YAPAPAVLivingEntity@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVLivingEntity@@@std@@YAPAPAVLivingEntity@@PAPAV1@@Z PROC ; std::_Val_type<LivingEntity * *>, COMDAT

; 710  : 	{	// return value type from arbitrary argument

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 711  : 	return (0);

	xor	eax, eax

; 712  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Val_type@PAPAVLivingEntity@@@std@@YAPAPAVLivingEntity@@PAPAV1@@Z ENDP ; std::_Val_type<LivingEntity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAVOnScreen@@PAV1@PAV1@@std@@YAPAPAVOnScreen@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVOnScreen@@PAV1@PAV1@@std@@YAPAPAVOnScreen@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<OnScreen *,OnScreen *,OnScreen *>, COMDAT

; 458  : 	{	// move [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 459  : 	_DEBUG_RANGE(_First, _Last);

	push	459					; 000001cbH
	push	OFFSET ??_C@_1IO@NPCEFBKE@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range@PAPAVOnScreen@@@std@@YAXPAPAVOnScreen@@0PB_WI@Z ; std::_Debug_range<OnScreen * *>
	add	esp, 16					; 00000010H

; 460  : 	_DEBUG_POINTER(_Dest);

	push	460					; 000001ccH
	push	OFFSET ??_C@_1IO@NPCEFBKE@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Debug_pointer@PAVOnScreen@@@std@@YAXPAPAVOnScreen@@PB_WI@Z ; std::_Debug_pointer<OnScreen *>
	add	esp, 12					; 0000000cH

; 461  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 462  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 463  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]

; 464  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_move@PAVOnScreen@@PAV1@PAV1@@std@@YAPAPAVOnScreen@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<OnScreen *,OnScreen *,OnScreen *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAVOnScreen@@@std@@YAPAPAVOnScreen@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVOnScreen@@@std@@YAPAPAVOnScreen@@PAPAV1@@Z PROC ; std::_Val_type<OnScreen * *>, COMDAT

; 710  : 	{	// return value type from arbitrary argument

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 711  : 	return (0);

	xor	eax, eax

; 712  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Val_type@PAPAVOnScreen@@@std@@YAPAPAVOnScreen@@PAPAV1@@Z ENDP ; std::_Val_type<OnScreen * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
tv73 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVEnemy@@AAPAV1@@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@AAPAV2@@Z
_TEXT	SEGMENT
tv73 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PAVEnemy@@AAPAV1@@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@AAPAV2@@Z PROC ; std::allocator<Enemy *>::construct<Enemy *,Enemy * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PAVEnemy@@AAPAV1@@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@AAPAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAVEnemy@@@std@@YAAAPAVEnemy@@AAPAV1@@Z ; std::forward<Enemy * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PAVEnemy@@AAPAV1@@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@AAPAV2@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PAVEnemy@@AAPAV1@@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@AAPAV2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PAVEnemy@@AAPAV1@@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@AAPAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PAVEnemy@@AAPAV1@@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@AAPAV2@@Z ENDP ; std::allocator<Enemy *>::construct<Enemy *,Enemy * &>
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
tv156 = -268						; size = 4
tv153 = -264						; size = 4
tv163 = -260						; size = 4
tv160 = -260						; size = 4
tv162 = -257						; size = 1
$T2 = -252						; size = 4
$T3 = -240						; size = 4
$T4 = -228						; size = 4
__Next$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Dest$ = 32						; size = 4
__Al$ = 36						; size = 4
___formal$ = 40						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >,Enemy * *,std::allocator<Enemy *> >, COMDAT

; 371  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 372  : 	_DEBUG_RANGE(_First, _Last);

	push	372					; 00000174H
	push	OFFSET ??_C@_1IO@NPCEFBKE@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv160[ebp], eax
	mov	ecx, DWORD PTR tv160[ebp]
	mov	DWORD PTR tv153[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv156[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	call	??$_Debug_range@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@std@@YAXV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > > >
	add	esp, 32					; 00000020H

; 373  : 	_DEBUG_POINTER(_Dest);

	push	373					; 00000175H
	push	OFFSET ??_C@_1IO@NPCEFBKE@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Debug_pointer@PAVEnemy@@@std@@YAXPAPAVEnemy@@PB_WI@Z ; std::_Debug_pointer<Enemy *>
	add	esp, 12					; 0000000cH

; 374  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 375  : 
; 376  : 	_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 3

; 377  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 4
	mov	DWORD PTR __Dest$[ebp], eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator++
$LN6@Uninit_cop:
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator!=
	mov	BYTE PTR tv162[ebp], al
	movzx	ecx, BYTE PTR tv162[ebp]
	test	ecx, ecx
	je	SHORT $LN4@Uninit_cop

; 378  : 		_Al.construct(_Dest, *_First);

	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBEABQAVEnemy@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator*
	mov	DWORD PTR tv163[ebp], eax
	mov	eax, DWORD PTR tv163[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PAVEnemy@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEXPAPAVEnemy@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<Enemy *> >::construct<Enemy *,Enemy * const &>
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 379  : 	_CATCH_ALL
; 380  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 4
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 381  : 		_Al.destroy(_Next);

	mov	eax, DWORD PTR __Next$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAVEnemy@@@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEXPAPAVEnemy@@@Z ; std::_Wrap_alloc<std::allocator<Enemy *> >::destroy<Enemy *>
	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 382  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 383  : 	_CATCH_END

	mov	eax, $LN17@Uninit_cop
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$1
$LN17@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 384  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T4[ebp]
$LN9@Uninit_cop:

; 385  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$3:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$4:
	mov	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-272]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >,Enemy * *,std::allocator<Enemy *> >
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@AAPAPAVEnemy@@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@AAPAPAVEnemy@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >,Enemy * *>, COMDAT

; 407  : 	{	// return pointer category from arbitrary arguments

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 408  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 409  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 410  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Ptr_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Ptr_cat:
	DD	1
	DD	$LN4@Ptr_cat
$LN4@Ptr_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Ptr_cat
$LN3@Ptr_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@AAPAPAVEnemy@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >,Enemy * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVBullet@@AAPAV1@@?$allocator@PAVBullet@@@std@@QAEXPAPAVBullet@@AAPAV2@@Z
_TEXT	SEGMENT
tv73 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PAVBullet@@AAPAV1@@?$allocator@PAVBullet@@@std@@QAEXPAPAVBullet@@AAPAV2@@Z PROC ; std::allocator<Bullet *>::construct<Bullet *,Bullet * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PAVBullet@@AAPAV1@@?$allocator@PAVBullet@@@std@@QAEXPAPAVBullet@@AAPAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAVBullet@@@std@@YAAAPAVBullet@@AAPAV1@@Z ; std::forward<Bullet * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PAVBullet@@AAPAV1@@?$allocator@PAVBullet@@@std@@QAEXPAPAVBullet@@AAPAV2@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PAVBullet@@AAPAV1@@?$allocator@PAVBullet@@@std@@QAEXPAPAVBullet@@AAPAV2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PAVBullet@@AAPAV1@@?$allocator@PAVBullet@@@std@@QAEXPAPAVBullet@@AAPAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PAVBullet@@AAPAV1@@?$allocator@PAVBullet@@@std@@QAEXPAPAVBullet@@AAPAV2@@Z ENDP ; std::allocator<Bullet *>::construct<Bullet *,Bullet * &>
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVLivingEntity@@AAPAV1@@?$allocator@PAVLivingEntity@@@std@@QAEXPAPAVLivingEntity@@AAPAV2@@Z
_TEXT	SEGMENT
tv73 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PAVLivingEntity@@AAPAV1@@?$allocator@PAVLivingEntity@@@std@@QAEXPAPAVLivingEntity@@AAPAV2@@Z PROC ; std::allocator<LivingEntity *>::construct<LivingEntity *,LivingEntity * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PAVLivingEntity@@AAPAV1@@?$allocator@PAVLivingEntity@@@std@@QAEXPAPAVLivingEntity@@AAPAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAVLivingEntity@@@std@@YAAAPAVLivingEntity@@AAPAV1@@Z ; std::forward<LivingEntity * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PAVLivingEntity@@AAPAV1@@?$allocator@PAVLivingEntity@@@std@@QAEXPAPAVLivingEntity@@AAPAV2@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PAVLivingEntity@@AAPAV1@@?$allocator@PAVLivingEntity@@@std@@QAEXPAPAVLivingEntity@@AAPAV2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PAVLivingEntity@@AAPAV1@@?$allocator@PAVLivingEntity@@@std@@QAEXPAPAVLivingEntity@@AAPAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PAVLivingEntity@@AAPAV1@@?$allocator@PAVLivingEntity@@@std@@QAEXPAPAVLivingEntity@@AAPAV2@@Z ENDP ; std::allocator<LivingEntity *>::construct<LivingEntity *,LivingEntity * &>
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVOnScreen@@AAPAV1@@?$allocator@PAVOnScreen@@@std@@QAEXPAPAVOnScreen@@AAPAV2@@Z
_TEXT	SEGMENT
tv73 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PAVOnScreen@@AAPAV1@@?$allocator@PAVOnScreen@@@std@@QAEXPAPAVOnScreen@@AAPAV2@@Z PROC ; std::allocator<OnScreen *>::construct<OnScreen *,OnScreen * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PAVOnScreen@@AAPAV1@@?$allocator@PAVOnScreen@@@std@@QAEXPAPAVOnScreen@@AAPAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAVOnScreen@@@std@@YAAAPAVOnScreen@@AAPAV1@@Z ; std::forward<OnScreen * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PAVOnScreen@@AAPAV1@@?$allocator@PAVOnScreen@@@std@@QAEXPAPAVOnScreen@@AAPAV2@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PAVOnScreen@@AAPAV1@@?$allocator@PAVOnScreen@@@std@@QAEXPAPAVOnScreen@@AAPAV2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PAVOnScreen@@AAPAV1@@?$allocator@PAVOnScreen@@@std@@QAEXPAPAVOnScreen@@AAPAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PAVOnScreen@@AAPAV1@@?$allocator@PAVOnScreen@@@std@@QAEXPAPAVOnScreen@@AAPAV2@@Z ENDP ; std::allocator<OnScreen *>::construct<OnScreen *,OnScreen * &>
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$?0_JU?$ratio@$00$00@std@@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$00@std@@@12@PAPAX@Z
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
__Dur$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?0_JU?$ratio@$00$00@std@@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$00@std@@@12@PAPAX@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1> >, COMDAT
; _this$ = ecx

; 120  : 		{	// construct from a duration

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Dur$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$00@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$00@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1> >
	add	esp, 8
	mov	ecx, eax
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx

; 121  : 		typedef typename ratio_divide<_Period2, _Period>::type _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0_JU?$ratio@$00$00@std@@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$00@std@@@12@PAPAX@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$?0_J@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_JPAPAX@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?0_J@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_JPAPAX@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64>, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from representation

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0_J@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_JPAPAX@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1> >::count, COMDAT
; _this$ = ecx

; 130  : 		{	// get stored rep

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 131  : 		return (_MyRep);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+4]

; 132  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z
_TEXT	SEGMENT
$T1 = -252						; size = 8
$T2 = -236						; size = 8
$T3 = -220						; size = 8
$T4 = -204						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1> >,__int64,std::ratio<1,1000000000> >, COMDAT

; 535  : 	{	// convert duration to another duration

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 536  : 	typedef typename ratio_divide<_Period, typename _To::period>::type _CF;
; 537  : 	typedef typename common_type<
; 538  : 		typename common_type<typename _To::rep, _Rep>::type,
; 539  : 			intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)

	xor	eax, eax
	je	SHORT $LN6@duration_c

; 541  : 		return (_To(static_cast<typename _To::rep>(_Dur.count())));

	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	DWORD PTR $T1[ebp], eax
	mov	DWORD PTR $T1[ebp+4], edx
	push	0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0_J@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN7@duration_c
	jmp	$LN7@duration_c
$LN6@duration_c:

; 542  : 	else if (_CF::num != 1 && _CF::den == 1)

	xor	eax, eax
	je	SHORT $LN4@duration_c

; 543  : 		return (_To(static_cast<typename _To::rep>(

	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR $T2[ebp+4], edx
	push	0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0_J@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN7@duration_c
	jmp	SHORT $LN7@duration_c
$LN4@duration_c:

; 544  : 			static_cast<_CR>(_Dur.count())) * static_cast<_CR>(_CF::num)));
; 545  : 	else if (_CF::num == 1 && _CF::den != 1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@duration_c

; 546  : 		return (_To(static_cast<typename _To::rep>(

	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	push	0
	push	1000000000				; 3b9aca00H
	push	edx
	push	eax
	call	__alldiv
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR $T3[ebp+4], edx
	push	0
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0_J@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN7@duration_c

; 547  : 			static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den))));
; 548  : 	else

	jmp	SHORT $LN7@duration_c
$LN2@duration_c:

; 549  : 		return (_To(static_cast<typename _To::rep>(

	mov	ecx, DWORD PTR __Dur$[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	push	0
	push	1000000000				; 3b9aca00H
	push	edx
	push	eax
	call	__alldiv
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR $T4[ebp+4], edx
	push	0
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0_J@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN7@duration_c:

; 550  : 			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
; 551  : 			/ static_cast<_CR>(_CF::den))));
; 552  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1> >,__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$?0_JU?$ratio@$00$0DOI@@std@@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@PAPAX@Z
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
__Dur$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?0_JU?$ratio@$00$0DOI@@std@@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@PAPAX@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000> >, COMDAT
; _this$ = ecx

; 120  : 		{	// construct from a duration

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Dur$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0DOI@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,1000> >
	add	esp, 8
	mov	ecx, eax
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx

; 121  : 		typedef typename ratio_divide<_Period2, _Period>::type _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0_JU?$ratio@$00$0DOI@@std@@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@PAPAX@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$?0_JU?$ratio@$00$0JIJGIA@@std@@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@PAPAX@Z
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
__Dur$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?0_JU?$ratio@$00$0JIJGIA@@std@@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@PAPAX@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,10000000> >, COMDAT
; _this$ = ecx

; 120  : 		{	// construct from a duration

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Dur$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$duration_cast@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000000000> >,__int64,std::ratio<1,10000000> >
	add	esp, 8
	mov	ecx, eax
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx

; 121  : 		typedef typename ratio_divide<_Period2, _Period>::type _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0_JU?$ratio@$00$0JIJGIA@@std@@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@PAPAX@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,10000000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator-=, COMDAT
; _this$ = ecx

; 173  : 		{	// subtract _Right from rep

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 174  : 		_MyRep -= _Right._MyRep;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	sbb	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax

; 175  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 176  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator-=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator+=, COMDAT
; _this$ = ecx

; 167  : 		{	// add _Right to rep

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 168  : 		_MyRep += _Right._MyRep;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	add	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	adc	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax

; 169  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 170  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count, COMDAT
; _this$ = ecx

; 130  : 		{	// get stored rep

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 131  : 		return (_MyRep);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+4]

; 132  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$?N_JU?$ratio@$00$0DOI@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@0@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?N_JU?$ratio@$00$0DOI@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@0@Z PROC ; std::chrono::operator<=<__int64,std::ratio<1,1000>,__int64,std::ratio<1,1000> >, COMDAT

; 502  : 	{	// test if duration <= duration

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 503  : 	return (!(_Right < _Left));

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	call	??$?M_JU?$ratio@$00$0DOI@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@0@Z ; std::chrono::operator<<__int64,std::ratio<1,1000>,__int64,std::ratio<1,1000> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 504  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?N_JU?$ratio@$00$0DOI@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@0@Z ENDP ; std::chrono::operator<=<__int64,std::ratio<1,1000>,__int64,std::ratio<1,1000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 1569 : 	__PURE_APPDOMAIN_GLOBAL locale::id num_put<_Elem, _OutIt>::id;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	esi, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	DWORD PTR __imp_??0id@locale@std@@QAE@I@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 1569 : 	__PURE_APPDOMAIN_GLOBAL locale::id num_put<_Elem, _OutIt>::id;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	esi, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	DWORD PTR __imp_??0id@locale@std@@QAE@I@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVEnemy@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@@std@@YAPAPAVEnemy@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVEnemy@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@@std@@YAPAPAVEnemy@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z PROC ; std::_Uninitialized_move<Enemy * *,Enemy * *,std::_Wrap_alloc<std::allocator<Enemy *> > >, COMDAT

; 471  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 472  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAVEnemy@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVEnemy@@0@Z ; std::_Ptr_cat<Enemy *,Enemy *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Val_type@PAPAVEnemy@@@std@@YAPAPAVEnemy@@PAPAV1@@Z ; std::_Val_type<Enemy * *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_move@PAVEnemy@@PAV1@PAV1@@std@@YAPAPAVEnemy@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Enemy *,Enemy *,Enemy *>
	add	esp, 24					; 00000018H

; 474  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_move@PAPAVEnemy@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@@std@@YAPAPAVEnemy@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<Enemy * *,Enemy * *,std::_Wrap_alloc<std::allocator<Enemy *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVBullet@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@@std@@YAPAPAVBullet@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVBullet@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@@std@@YAPAPAVBullet@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@0@@Z PROC ; std::_Uninitialized_move<Bullet * *,Bullet * *,std::_Wrap_alloc<std::allocator<Bullet *> > >, COMDAT

; 471  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 472  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAVBullet@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVBullet@@0@Z ; std::_Ptr_cat<Bullet *,Bullet *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Val_type@PAPAVBullet@@@std@@YAPAPAVBullet@@PAPAV1@@Z ; std::_Val_type<Bullet * *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_move@PAVBullet@@PAV1@PAV1@@std@@YAPAPAVBullet@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Bullet *,Bullet *,Bullet *>
	add	esp, 24					; 00000018H

; 474  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_move@PAPAVBullet@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@@std@@YAPAPAVBullet@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<Bullet * *,Bullet * *,std::_Wrap_alloc<std::allocator<Bullet *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVLivingEntity@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@YAPAPAVLivingEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVLivingEntity@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@YAPAPAVLivingEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@0@@Z PROC ; std::_Uninitialized_move<LivingEntity * *,LivingEntity * *,std::_Wrap_alloc<std::allocator<LivingEntity *> > >, COMDAT

; 471  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 472  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAVLivingEntity@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVLivingEntity@@0@Z ; std::_Ptr_cat<LivingEntity *,LivingEntity *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Val_type@PAPAVLivingEntity@@@std@@YAPAPAVLivingEntity@@PAPAV1@@Z ; std::_Val_type<LivingEntity * *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_move@PAVLivingEntity@@PAV1@PAV1@@std@@YAPAPAVLivingEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<LivingEntity *,LivingEntity *,LivingEntity *>
	add	esp, 24					; 00000018H

; 474  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_move@PAPAVLivingEntity@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@YAPAPAVLivingEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<LivingEntity * *,LivingEntity * *,std::_Wrap_alloc<std::allocator<LivingEntity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVOnScreen@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@YAPAPAVOnScreen@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVOnScreen@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@YAPAPAVOnScreen@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@0@@Z PROC ; std::_Uninitialized_move<OnScreen * *,OnScreen * *,std::_Wrap_alloc<std::allocator<OnScreen *> > >, COMDAT

; 471  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 472  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAVOnScreen@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVOnScreen@@0@Z ; std::_Ptr_cat<OnScreen *,OnScreen *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Val_type@PAPAVOnScreen@@@std@@YAPAPAVOnScreen@@PAPAV1@@Z ; std::_Val_type<OnScreen * *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_move@PAVOnScreen@@PAV1@PAV1@@std@@YAPAPAVOnScreen@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<OnScreen *,OnScreen *,OnScreen *>
	add	esp, 24					; 00000018H

; 474  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_move@PAPAVOnScreen@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@YAPAPAVOnScreen@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<OnScreen * *,OnScreen * *,std::_Wrap_alloc<std::allocator<OnScreen *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@@std@@YAXPAPAVEnemy@@0AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@@std@@YAXPAPAVEnemy@@0AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Enemy *> > >, COMDAT

; 96   : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@@std@@YAXPAPAVEnemy@@0AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Enemy *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@@std@@YAXPAPAVBullet@@0AAU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@@std@@YAXPAPAVBullet@@0AAU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Bullet *> > >, COMDAT

; 96   : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@@std@@YAXPAPAVBullet@@0AAU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Bullet *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@YAXPAPAVLivingEntity@@0AAU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@YAXPAPAVLivingEntity@@0AAU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<LivingEntity *> > >, COMDAT

; 96   : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@YAXPAPAVLivingEntity@@0AAU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<LivingEntity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@YAXPAPAVOnScreen@@0AAU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@YAXPAPAVOnScreen@@0AAU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<OnScreen *> > >, COMDAT

; 96   : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@YAXPAPAVOnScreen@@0AAU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<OnScreen *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Move@PAPAVEnemy@@PAPAV1@@std@@YAPAPAVEnemy@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAPAVEnemy@@PAPAV1@@std@@YAPAPAVEnemy@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<Enemy * *,Enemy * *>, COMDAT

; 2474 : 	{	// move [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2475 : 	ptrdiff_t _Count = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 2476 : 	_CSTD memmove(&*_Dest, &*_First,
; 2477 : 		_Count * sizeof (*_First));

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2478 : 	return (_Dest + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]

; 2479 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move@PAPAVEnemy@@PAPAV1@@std@@YAPAPAVEnemy@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<Enemy * *,Enemy * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVEnemy@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVEnemy@@0@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVEnemy@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVEnemy@@0@Z PROC ; std::_Ptr_cat<Enemy *,Enemy *>, COMDAT

; 437  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 438  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 439  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 440  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Ptr_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Ptr_cat:
	DD	1
	DD	$LN4@Ptr_cat
$LN4@Ptr_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Ptr_cat
$LN3@Ptr_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Ptr_cat@PAVEnemy@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVEnemy@@0@Z ENDP ; std::_Ptr_cat<Enemy *,Enemy *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVEnemy@@ABQAV1@@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SAXAAV?$allocator@PAVEnemy@@@1@PAPAVEnemy@@ABQAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PAVEnemy@@ABQAV1@@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SAXAAV?$allocator@PAVEnemy@@@1@PAPAVEnemy@@ABQAV3@@Z PROC ; std::allocator_traits<std::allocator<Enemy *> >::construct<Enemy *,Enemy * const &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@ABQAVEnemy@@@std@@YAABQAVEnemy@@ABQAV1@@Z ; std::forward<Enemy * const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@ABQAV3@@Z ; std::allocator<Enemy *>::construct
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@PAVEnemy@@ABQAV1@@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SAXAAV?$allocator@PAVEnemy@@@1@PAPAVEnemy@@ABQAV3@@Z ENDP ; std::allocator_traits<std::allocator<Enemy *> >::construct<Enemy *,Enemy * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@ABQAVEnemy@@@std@@YAABQAVEnemy@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVEnemy@@@std@@YAABQAVEnemy@@ABQAV1@@Z PROC ; std::forward<Enemy * const &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@ABQAVEnemy@@@std@@YAABQAVEnemy@@ABQAV1@@Z ENDP ; std::forward<Enemy * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVEnemy@@AAPAV1@@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SAXAAV?$allocator@PAVEnemy@@@1@PAPAVEnemy@@AAPAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PAVEnemy@@AAPAV1@@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SAXAAV?$allocator@PAVEnemy@@@1@PAPAVEnemy@@AAPAV3@@Z PROC ; std::allocator_traits<std::allocator<Enemy *> >::construct<Enemy *,Enemy * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAVEnemy@@@std@@YAAAPAVEnemy@@AAPAV1@@Z ; std::forward<Enemy * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PAVEnemy@@AAPAV1@@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@AAPAV2@@Z ; std::allocator<Enemy *>::construct<Enemy *,Enemy * &>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@PAVEnemy@@AAPAV1@@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SAXAAV?$allocator@PAVEnemy@@@1@PAPAVEnemy@@AAPAV3@@Z ENDP ; std::allocator_traits<std::allocator<Enemy *> >::construct<Enemy *,Enemy * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAVEnemy@@@std@@YAAAPAVEnemy@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVEnemy@@@std@@YAAAPAVEnemy@@AAPAV1@@Z PROC ; std::forward<Enemy * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@AAPAVEnemy@@@std@@YAAAPAVEnemy@@AAPAV1@@Z ENDP ; std::forward<Enemy * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z
_TEXT	SEGMENT
tv66 = -268						; size = 4
tv141 = -264						; size = 4
tv138 = -260						; size = 4
tv144 = -256						; size = 4
$T2 = -248						; size = 4
$T3 = -233						; size = 1
$T4 = -224						; size = 4
$T5 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Dest$ = 32						; size = 4
__Al$ = 36						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >,Enemy * *,std::_Wrap_alloc<std::allocator<Enemy *> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));

	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@AAPAPAVEnemy@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >,Enemy * *>
	add	esp, 8
	mov	BYTE PTR $T3[ebp], al
	movzx	edx, BYTE PTR $T3[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv144[ebp], eax
	mov	eax, DWORD PTR tv144[ebp]
	mov	DWORD PTR tv138[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T5[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv141[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$_Uninit_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@V?$allocator@PAVEnemy@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >,Enemy * *,std::allocator<Enemy *> >
	add	esp, 36					; 00000024H
	mov	DWORD PTR tv66[ebp], eax
	mov	eax, DWORD PTR tv66[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T2[ebp]

; 417  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z$2:
	mov	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-272]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >,Enemy * *,std::_Wrap_alloc<std::allocator<Enemy *> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Move@PAPAVBullet@@PAPAV1@@std@@YAPAPAVBullet@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAPAVBullet@@PAPAV1@@std@@YAPAPAVBullet@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<Bullet * *,Bullet * *>, COMDAT

; 2474 : 	{	// move [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2475 : 	ptrdiff_t _Count = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 2476 : 	_CSTD memmove(&*_Dest, &*_First,
; 2477 : 		_Count * sizeof (*_First));

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2478 : 	return (_Dest + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]

; 2479 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move@PAPAVBullet@@PAPAV1@@std@@YAPAPAVBullet@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<Bullet * *,Bullet * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVBullet@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVBullet@@0@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVBullet@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVBullet@@0@Z PROC ; std::_Ptr_cat<Bullet *,Bullet *>, COMDAT

; 437  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 438  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 439  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 440  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Ptr_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Ptr_cat:
	DD	1
	DD	$LN4@Ptr_cat
$LN4@Ptr_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Ptr_cat
$LN3@Ptr_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Ptr_cat@PAVBullet@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVBullet@@0@Z ENDP ; std::_Ptr_cat<Bullet *,Bullet *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVBullet@@ABQAV1@@?$allocator_traits@V?$allocator@PAVBullet@@@std@@@std@@SAXAAV?$allocator@PAVBullet@@@1@PAPAVBullet@@ABQAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PAVBullet@@ABQAV1@@?$allocator_traits@V?$allocator@PAVBullet@@@std@@@std@@SAXAAV?$allocator@PAVBullet@@@1@PAPAVBullet@@ABQAV3@@Z PROC ; std::allocator_traits<std::allocator<Bullet *> >::construct<Bullet *,Bullet * const &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@ABQAVBullet@@@std@@YAABQAVBullet@@ABQAV1@@Z ; std::forward<Bullet * const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@PAVBullet@@@std@@QAEXPAPAVBullet@@ABQAV3@@Z ; std::allocator<Bullet *>::construct
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@PAVBullet@@ABQAV1@@?$allocator_traits@V?$allocator@PAVBullet@@@std@@@std@@SAXAAV?$allocator@PAVBullet@@@1@PAPAVBullet@@ABQAV3@@Z ENDP ; std::allocator_traits<std::allocator<Bullet *> >::construct<Bullet *,Bullet * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@ABQAVBullet@@@std@@YAABQAVBullet@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVBullet@@@std@@YAABQAVBullet@@ABQAV1@@Z PROC ; std::forward<Bullet * const &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@ABQAVBullet@@@std@@YAABQAVBullet@@ABQAV1@@Z ENDP ; std::forward<Bullet * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVBullet@@AAPAV1@@?$allocator_traits@V?$allocator@PAVBullet@@@std@@@std@@SAXAAV?$allocator@PAVBullet@@@1@PAPAVBullet@@AAPAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PAVBullet@@AAPAV1@@?$allocator_traits@V?$allocator@PAVBullet@@@std@@@std@@SAXAAV?$allocator@PAVBullet@@@1@PAPAVBullet@@AAPAV3@@Z PROC ; std::allocator_traits<std::allocator<Bullet *> >::construct<Bullet *,Bullet * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAVBullet@@@std@@YAAAPAVBullet@@AAPAV1@@Z ; std::forward<Bullet * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PAVBullet@@AAPAV1@@?$allocator@PAVBullet@@@std@@QAEXPAPAVBullet@@AAPAV2@@Z ; std::allocator<Bullet *>::construct<Bullet *,Bullet * &>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@PAVBullet@@AAPAV1@@?$allocator_traits@V?$allocator@PAVBullet@@@std@@@std@@SAXAAV?$allocator@PAVBullet@@@1@PAPAVBullet@@AAPAV3@@Z ENDP ; std::allocator_traits<std::allocator<Bullet *> >::construct<Bullet *,Bullet * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAVBullet@@@std@@YAAAPAVBullet@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVBullet@@@std@@YAAAPAVBullet@@AAPAV1@@Z PROC ; std::forward<Bullet * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@AAPAVBullet@@@std@@YAAAPAVBullet@@AAPAV1@@Z ENDP ; std::forward<Bullet * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Move@PAPAVLivingEntity@@PAPAV1@@std@@YAPAPAVLivingEntity@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAPAVLivingEntity@@PAPAV1@@std@@YAPAPAVLivingEntity@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<LivingEntity * *,LivingEntity * *>, COMDAT

; 2474 : 	{	// move [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2475 : 	ptrdiff_t _Count = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 2476 : 	_CSTD memmove(&*_Dest, &*_First,
; 2477 : 		_Count * sizeof (*_First));

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2478 : 	return (_Dest + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]

; 2479 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move@PAPAVLivingEntity@@PAPAV1@@std@@YAPAPAVLivingEntity@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<LivingEntity * *,LivingEntity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVLivingEntity@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVLivingEntity@@0@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVLivingEntity@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVLivingEntity@@0@Z PROC ; std::_Ptr_cat<LivingEntity *,LivingEntity *>, COMDAT

; 437  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 438  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 439  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 440  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Ptr_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Ptr_cat:
	DD	1
	DD	$LN4@Ptr_cat
$LN4@Ptr_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Ptr_cat
$LN3@Ptr_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Ptr_cat@PAVLivingEntity@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVLivingEntity@@0@Z ENDP ; std::_Ptr_cat<LivingEntity *,LivingEntity *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVLivingEntity@@ABQAV1@@?$allocator_traits@V?$allocator@PAVLivingEntity@@@std@@@std@@SAXAAV?$allocator@PAVLivingEntity@@@1@PAPAVLivingEntity@@ABQAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PAVLivingEntity@@ABQAV1@@?$allocator_traits@V?$allocator@PAVLivingEntity@@@std@@@std@@SAXAAV?$allocator@PAVLivingEntity@@@1@PAPAVLivingEntity@@ABQAV3@@Z PROC ; std::allocator_traits<std::allocator<LivingEntity *> >::construct<LivingEntity *,LivingEntity * const &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@ABQAVLivingEntity@@@std@@YAABQAVLivingEntity@@ABQAV1@@Z ; std::forward<LivingEntity * const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@PAVLivingEntity@@@std@@QAEXPAPAVLivingEntity@@ABQAV3@@Z ; std::allocator<LivingEntity *>::construct
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@PAVLivingEntity@@ABQAV1@@?$allocator_traits@V?$allocator@PAVLivingEntity@@@std@@@std@@SAXAAV?$allocator@PAVLivingEntity@@@1@PAPAVLivingEntity@@ABQAV3@@Z ENDP ; std::allocator_traits<std::allocator<LivingEntity *> >::construct<LivingEntity *,LivingEntity * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@ABQAVLivingEntity@@@std@@YAABQAVLivingEntity@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVLivingEntity@@@std@@YAABQAVLivingEntity@@ABQAV1@@Z PROC ; std::forward<LivingEntity * const &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@ABQAVLivingEntity@@@std@@YAABQAVLivingEntity@@ABQAV1@@Z ENDP ; std::forward<LivingEntity * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVLivingEntity@@AAPAV1@@?$allocator_traits@V?$allocator@PAVLivingEntity@@@std@@@std@@SAXAAV?$allocator@PAVLivingEntity@@@1@PAPAVLivingEntity@@AAPAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PAVLivingEntity@@AAPAV1@@?$allocator_traits@V?$allocator@PAVLivingEntity@@@std@@@std@@SAXAAV?$allocator@PAVLivingEntity@@@1@PAPAVLivingEntity@@AAPAV3@@Z PROC ; std::allocator_traits<std::allocator<LivingEntity *> >::construct<LivingEntity *,LivingEntity * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAVLivingEntity@@@std@@YAAAPAVLivingEntity@@AAPAV1@@Z ; std::forward<LivingEntity * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PAVLivingEntity@@AAPAV1@@?$allocator@PAVLivingEntity@@@std@@QAEXPAPAVLivingEntity@@AAPAV2@@Z ; std::allocator<LivingEntity *>::construct<LivingEntity *,LivingEntity * &>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@PAVLivingEntity@@AAPAV1@@?$allocator_traits@V?$allocator@PAVLivingEntity@@@std@@@std@@SAXAAV?$allocator@PAVLivingEntity@@@1@PAPAVLivingEntity@@AAPAV3@@Z ENDP ; std::allocator_traits<std::allocator<LivingEntity *> >::construct<LivingEntity *,LivingEntity * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAVLivingEntity@@@std@@YAAAPAVLivingEntity@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVLivingEntity@@@std@@YAAAPAVLivingEntity@@AAPAV1@@Z PROC ; std::forward<LivingEntity * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@AAPAVLivingEntity@@@std@@YAAAPAVLivingEntity@@AAPAV1@@Z ENDP ; std::forward<LivingEntity * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Move@PAPAVOnScreen@@PAPAV1@@std@@YAPAPAVOnScreen@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAPAVOnScreen@@PAPAV1@@std@@YAPAPAVOnScreen@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<OnScreen * *,OnScreen * *>, COMDAT

; 2474 : 	{	// move [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2475 : 	ptrdiff_t _Count = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 2476 : 	_CSTD memmove(&*_Dest, &*_First,
; 2477 : 		_Count * sizeof (*_First));

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2478 : 	return (_Dest + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]

; 2479 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move@PAPAVOnScreen@@PAPAV1@@std@@YAPAPAVOnScreen@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<OnScreen * *,OnScreen * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAVOnScreen@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVOnScreen@@0@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVOnScreen@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVOnScreen@@0@Z PROC ; std::_Ptr_cat<OnScreen *,OnScreen *>, COMDAT

; 437  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 438  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 439  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 440  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Ptr_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Ptr_cat:
	DD	1
	DD	$LN4@Ptr_cat
$LN4@Ptr_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Ptr_cat
$LN3@Ptr_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Ptr_cat@PAVOnScreen@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVOnScreen@@0@Z ENDP ; std::_Ptr_cat<OnScreen *,OnScreen *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVOnScreen@@ABQAV1@@?$allocator_traits@V?$allocator@PAVOnScreen@@@std@@@std@@SAXAAV?$allocator@PAVOnScreen@@@1@PAPAVOnScreen@@ABQAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PAVOnScreen@@ABQAV1@@?$allocator_traits@V?$allocator@PAVOnScreen@@@std@@@std@@SAXAAV?$allocator@PAVOnScreen@@@1@PAPAVOnScreen@@ABQAV3@@Z PROC ; std::allocator_traits<std::allocator<OnScreen *> >::construct<OnScreen *,OnScreen * const &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@ABQAVOnScreen@@@std@@YAABQAVOnScreen@@ABQAV1@@Z ; std::forward<OnScreen * const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@PAVOnScreen@@@std@@QAEXPAPAVOnScreen@@ABQAV3@@Z ; std::allocator<OnScreen *>::construct
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@PAVOnScreen@@ABQAV1@@?$allocator_traits@V?$allocator@PAVOnScreen@@@std@@@std@@SAXAAV?$allocator@PAVOnScreen@@@1@PAPAVOnScreen@@ABQAV3@@Z ENDP ; std::allocator_traits<std::allocator<OnScreen *> >::construct<OnScreen *,OnScreen * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@ABQAVOnScreen@@@std@@YAABQAVOnScreen@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVOnScreen@@@std@@YAABQAVOnScreen@@ABQAV1@@Z PROC ; std::forward<OnScreen * const &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@ABQAVOnScreen@@@std@@YAABQAVOnScreen@@ABQAV1@@Z ENDP ; std::forward<OnScreen * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVOnScreen@@AAPAV1@@?$allocator_traits@V?$allocator@PAVOnScreen@@@std@@@std@@SAXAAV?$allocator@PAVOnScreen@@@1@PAPAVOnScreen@@AAPAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PAVOnScreen@@AAPAV1@@?$allocator_traits@V?$allocator@PAVOnScreen@@@std@@@std@@SAXAAV?$allocator@PAVOnScreen@@@1@PAPAVOnScreen@@AAPAV3@@Z PROC ; std::allocator_traits<std::allocator<OnScreen *> >::construct<OnScreen *,OnScreen * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAVOnScreen@@@std@@YAAAPAVOnScreen@@AAPAV1@@Z ; std::forward<OnScreen * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PAVOnScreen@@AAPAV1@@?$allocator@PAVOnScreen@@@std@@QAEXPAPAVOnScreen@@AAPAV2@@Z ; std::allocator<OnScreen *>::construct<OnScreen *,OnScreen * &>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@PAVOnScreen@@AAPAV1@@?$allocator_traits@V?$allocator@PAVOnScreen@@@std@@@std@@SAXAAV?$allocator@PAVOnScreen@@@1@PAPAVOnScreen@@AAPAV3@@Z ENDP ; std::allocator_traits<std::allocator<OnScreen *> >::construct<OnScreen *,OnScreen * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAVOnScreen@@@std@@YAAAPAVOnScreen@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAVOnScreen@@@std@@YAAAPAVOnScreen@@AAPAV1@@Z PROC ; std::forward<OnScreen * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@AAPAVOnScreen@@@std@@YAAAPAVOnScreen@@AAPAV1@@Z ENDP ; std::forward<OnScreen * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator==<char,char>, COMDAT

; 676  : 	{	// test for allocator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 677  : 	return (true);

	mov	al, 1

; 678  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator==<char,char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
$T2 = -197						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator==<std::allocator<char>,std::allocator<char> >, COMDAT

; 922  : 	{	// test for allocator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 923  : 	return (static_cast<_Ty>(_Left) == static_cast<_Other>(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>
	push	eax
	call	??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z	; std::operator==<char,char>
	add	esp, 8

; 924  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator==<std::allocator<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$_To_xtime@_JU?$ratio@$00$0DOI@@std@@@std@@YA?AUxtime@@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@0@@Z
_TEXT	SEGMENT
$T1 = -344						; size = 8
$T2 = -328						; size = 8
$T3 = -312						; size = 8
$T4 = -296						; size = 8
$T5 = -280						; size = 8
$T6 = -264						; size = 8
$T7 = -248						; size = 8
__T0$8 = -40						; size = 8
__Xt$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
$T9 = 8							; size = 4
__Rel_time$ = 12					; size = 4
??$_To_xtime@_JU?$ratio@$00$0DOI@@std@@@std@@YA?AUxtime@@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@0@@Z PROC ; std::_To_xtime<__int64,std::ratio<1,1000> >, COMDAT

; 738  : 	{	// convert duration to xtime

	push	ebp
	mov	ebp, esp
	sub	esp, 348				; 0000015cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-348]
	mov	ecx, 87					; 00000057H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 739  : 	xtime _Xt;
; 740  : 	if (_Rel_time <= chrono::duration<_Rep, _Period>::zero())

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?zero@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@SA?AV123@XZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::zero
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Rel_time$[ebp]
	push	ecx
	call	??$?N_JU?$ratio@$00$0DOI@@std@@_JU01@@chrono@std@@YA_NABV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@0@Z ; std::chrono::operator<=<__int64,std::ratio<1,1000>,__int64,std::ratio<1,1000> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@To_xtime

; 741  : 		{	// negative or zero relative time, return zero
; 742  : 		_Xt.sec = 0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR __Xt$[ebp], xmm0

; 743  : 		_Xt.nsec = 0;

	mov	DWORD PTR __Xt$[ebp+8], 0

; 744  : 		}
; 745  : 	else

	jmp	$LN1@To_xtime
$LN2@To_xtime:

; 746  : 		{	// positive relative time, convert
; 747  : 		chrono::nanoseconds _T0 =
; 748  : 			chrono::system_clock::now().time_since_epoch();

	push	0
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ; std::chrono::system_clock::now
	add	esp, 4
	mov	ecx, eax
	call	?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch
	push	eax
	lea	ecx, DWORD PTR __T0$8[ebp]
	call	??$?0_JU?$ratio@$00$0JIJGIA@@std@@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@PAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,10000000> >

; 749  : 		_T0 += _Rel_time;

	push	0
	mov	eax, DWORD PTR __Rel_time$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	call	??$?0_JU?$ratio@$00$0DOI@@std@@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@12@PAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1000> >
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	lea	ecx, DWORD PTR __T0$8[ebp]
	call	??Y?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator+=

; 750  : 		_Xt.sec = chrono::duration_cast<chrono::seconds>(_T0).count();

	lea	eax, DWORD PTR __T0$8[ebp]
	push	eax
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	call	??$duration_cast@V?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$00@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1> >,__int64,std::ratio<1,1000000000> >
	add	esp, 8
	mov	ecx, eax
	call	?count@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1> >::count
	mov	DWORD PTR __Xt$[ebp], eax
	mov	DWORD PTR __Xt$[ebp+4], edx

; 751  : 		_T0 -= chrono::seconds(_Xt.sec);

	push	0
	push	0
	lea	eax, DWORD PTR __Xt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T7[ebp]
	call	??$?0_J@?$duration@_JU?$ratio@$00$00@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1> >::duration<__int64,std::ratio<1,1> ><__int64>
	push	eax
	lea	ecx, DWORD PTR $T6[ebp]
	call	??$?0_JU?$ratio@$00$00@std@@@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$00@std@@@12@PAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,std::ratio<1,1> >
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	lea	ecx, DWORD PTR __T0$8[ebp]
	call	??Z?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAEAAV012@ABV012@@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::operator-=

; 752  : 		_Xt.nsec = (long)_T0.count();

	lea	ecx, DWORD PTR __T0$8[ebp]
	call	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
	mov	DWORD PTR __Xt$[ebp+8], eax
$LN1@To_xtime:

; 753  : 		}
; 754  : 	return (_Xt);

	mov	eax, DWORD PTR $T9[ebp]
	mov	ecx, DWORD PTR __Xt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Xt$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Xt$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Xt$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T9[ebp]

; 755  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@To_xtime
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 348				; 0000015cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN8@To_xtime:
	DD	2
	DD	$LN7@To_xtime
$LN7@To_xtime:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN5@To_xtime
	DD	-40					; ffffffd8H
	DD	8
	DD	$LN6@To_xtime
$LN6@To_xtime:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	48					; 00000030H
	DB	0
$LN5@To_xtime:
	DB	95					; 0000005fH
	DB	88					; 00000058H
	DB	116					; 00000074H
	DB	0
??$_To_xtime@_JU?$ratio@$00$0DOI@@std@@@std@@YA?AUxtime@@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@0@@Z ENDP ; std::_To_xtime<__int64,std::ratio<1,1000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 666  : 	_System_error_category _Error_objects<_Cat>::_System_object;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 664  : 	_Iostream_error_category _Error_objects<_Cat>::_Iostream_object;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 662  : 	_Generic_error_category _Error_objects<_Cat>::_Generic_object;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	mov	esi, esp
	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAVBullet@@@std@@YAPAPAVBullet@@IPAPAV1@@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVBullet@@@std@@YAPAPAVBullet@@IPAPAV1@@Z PROC ; std::_Allocate<Bullet *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	mov	esi, esp
	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVBullet@@@std@@YAPAPAVBullet@@IPAPAV1@@Z ENDP ; std::_Allocate<Bullet *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAVLivingEntity@@@std@@YAPAPAVLivingEntity@@IPAPAV1@@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVLivingEntity@@@std@@YAPAPAVLivingEntity@@IPAPAV1@@Z PROC ; std::_Allocate<LivingEntity *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	mov	esi, esp
	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVLivingEntity@@@std@@YAPAPAVLivingEntity@@IPAPAV1@@Z ENDP ; std::_Allocate<LivingEntity *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAVOnScreen@@@std@@YAPAPAVOnScreen@@IPAPAV1@@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVOnScreen@@@std@@YAPAPAVOnScreen@@IPAPAV1@@Z PROC ; std::_Allocate<OnScreen *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	mov	esi, esp
	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVOnScreen@@@std@@YAPAPAVOnScreen@@IPAPAV1@@Z ENDP ; std::_Allocate<OnScreen *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z PROC ; std::_Allocate<std::_Container_proxy>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 536870911	; 1fffffffH
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	mov	esi, esp
	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ENDP ; std::_Allocate<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAVEnemy@@@std@@YAPAPAVEnemy@@IPAPAV1@@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVEnemy@@@std@@YAPAPAVEnemy@@IPAPAV1@@Z PROC ; std::_Allocate<Enemy *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	mov	esi, esp
	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVEnemy@@@std@@YAPAPAVEnemy@@IPAPAV1@@Z ENDP ; std::_Allocate<Enemy *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVEnemy@@@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEPAPAVEnemy@@PAPAV2@00@Z
_TEXT	SEGMENT
__Alval$ = -17						; size = 1
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVEnemy@@@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEPAPAVEnemy@@PAPAV2@00@Z PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::_Umove<Enemy * *>, COMDAT
; _this$ = ecx

; 1557 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1558 : 		{	// move initializing [_First, _Last), using allocator
; 1559 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Getal

; 1560 : 		return (_Uninitialized_move(_First, _Last,
; 1561 : 			_Ptr, _Alval));

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Uninitialized_move@PAPAVEnemy@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@@std@@YAPAPAVEnemy@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z ; std::_Uninitialized_move<Enemy * *,Enemy * *,std::_Wrap_alloc<std::allocator<Enemy *> > >
	add	esp, 16					; 00000010H

; 1562 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Umove
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	2
$LN5@Umove:
	DD	1
	DD	$LN4@Umove
$LN4@Umove:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Umove
$LN3@Umove:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
??$_Umove@PAPAVEnemy@@@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEPAPAVEnemy@@PAPAV2@00@Z ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::_Umove<Enemy * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVBullet@@@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEPAPAVBullet@@PAPAV2@00@Z
_TEXT	SEGMENT
__Alval$ = -17						; size = 1
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVBullet@@@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEPAPAVBullet@@PAPAV2@00@Z PROC ; std::vector<Bullet *,std::allocator<Bullet *> >::_Umove<Bullet * *>, COMDAT
; _this$ = ecx

; 1557 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1558 : 		{	// move initializing [_First, _Last), using allocator
; 1559 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Getal

; 1560 : 		return (_Uninitialized_move(_First, _Last,
; 1561 : 			_Ptr, _Alval));

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Uninitialized_move@PAPAVBullet@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@@std@@YAPAPAVBullet@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@0@@Z ; std::_Uninitialized_move<Bullet * *,Bullet * *,std::_Wrap_alloc<std::allocator<Bullet *> > >
	add	esp, 16					; 00000010H

; 1562 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Umove
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	2
$LN5@Umove:
	DD	1
	DD	$LN4@Umove
$LN4@Umove:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Umove
$LN3@Umove:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
??$_Umove@PAPAVBullet@@@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEPAPAVBullet@@PAPAV2@00@Z ENDP ; std::vector<Bullet *,std::allocator<Bullet *> >::_Umove<Bullet * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVLivingEntity@@@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEPAPAVLivingEntity@@PAPAV2@00@Z
_TEXT	SEGMENT
__Alval$ = -17						; size = 1
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVLivingEntity@@@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEPAPAVLivingEntity@@PAPAV2@00@Z PROC ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Umove<LivingEntity * *>, COMDAT
; _this$ = ecx

; 1557 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1558 : 		{	// move initializing [_First, _Last), using allocator
; 1559 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Getal

; 1560 : 		return (_Uninitialized_move(_First, _Last,
; 1561 : 			_Ptr, _Alval));

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Uninitialized_move@PAPAVLivingEntity@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@YAPAPAVLivingEntity@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@0@@Z ; std::_Uninitialized_move<LivingEntity * *,LivingEntity * *,std::_Wrap_alloc<std::allocator<LivingEntity *> > >
	add	esp, 16					; 00000010H

; 1562 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Umove
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	2
$LN5@Umove:
	DD	1
	DD	$LN4@Umove
$LN4@Umove:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Umove
$LN3@Umove:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
??$_Umove@PAPAVLivingEntity@@@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEPAPAVLivingEntity@@PAPAV2@00@Z ENDP ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Umove<LivingEntity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVOnScreen@@@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEPAPAVOnScreen@@PAPAV2@00@Z
_TEXT	SEGMENT
__Alval$ = -17						; size = 1
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVOnScreen@@@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEPAPAVOnScreen@@PAPAV2@00@Z PROC ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Umove<OnScreen * *>, COMDAT
; _this$ = ecx

; 1557 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1558 : 		{	// move initializing [_First, _Last), using allocator
; 1559 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Getal

; 1560 : 		return (_Uninitialized_move(_First, _Last,
; 1561 : 			_Ptr, _Alval));

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Uninitialized_move@PAPAVOnScreen@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@YAPAPAVOnScreen@@PAPAV1@00AAU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@0@@Z ; std::_Uninitialized_move<OnScreen * *,OnScreen * *,std::_Wrap_alloc<std::allocator<OnScreen *> > >
	add	esp, 16					; 00000010H

; 1562 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Umove
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	2
$LN5@Umove:
	DD	1
	DD	$LN4@Umove
$LN4@Umove:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Umove
$LN3@Umove:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
??$_Umove@PAPAVOnScreen@@@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEPAPAVOnScreen@@PAPAV2@00@Z ENDP ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Umove<OnScreen * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z PROC ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ENDP ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
tv74 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv74[ebp], 0
$LN4@construct:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>
	add	esp, 8

; 592  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ PROC	; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ENDP	; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@@std@@YAXPAPAVEnemy@@0AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@@std@@YAXPAPAVEnemy@@0AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Enemy *> > >, COMDAT

; 79   : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAVEnemy@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVEnemy@@0@Z ; std::_Ptr_cat<Enemy *,Enemy *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@@std@@YAXPAPAVEnemy@@0AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Enemy *> > >
	add	esp, 16					; 00000010H

; 81   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@@std@@YAXPAPAVEnemy@@0AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Enemy *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@@std@@YAXPAPAVBullet@@0AAU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@@std@@YAXPAPAVBullet@@0AAU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Bullet *> > >, COMDAT

; 79   : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAVBullet@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVBullet@@0@Z ; std::_Ptr_cat<Bullet *,Bullet *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@@std@@YAXPAPAVBullet@@0AAU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Bullet *> > >
	add	esp, 16					; 00000010H

; 81   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@@std@@YAXPAPAVBullet@@0AAU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Bullet *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@YAXPAPAVLivingEntity@@0AAU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@YAXPAPAVLivingEntity@@0AAU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<LivingEntity *> > >, COMDAT

; 79   : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAVLivingEntity@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVLivingEntity@@0@Z ; std::_Ptr_cat<LivingEntity *,LivingEntity *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@YAXPAPAVLivingEntity@@0AAU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<LivingEntity *> > >
	add	esp, 16					; 00000010H

; 81   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@YAXPAPAVLivingEntity@@0AAU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<LivingEntity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@YAXPAPAVOnScreen@@0AAU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@YAXPAPAVOnScreen@@0AAU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<OnScreen *> > >, COMDAT

; 79   : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAVOnScreen@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVOnScreen@@0@Z ; std::_Ptr_cat<OnScreen *,OnScreen *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@YAXPAPAVOnScreen@@0AAU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<OnScreen *> > >
	add	esp, 16					; 00000010H

; 81   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@YAXPAPAVOnScreen@@0AAU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<OnScreen *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Move@PAPAVEnemy@@PAPAV1@@std@@YAPAPAVEnemy@@PAPAV1@00@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAPAVEnemy@@PAPAV1@@std@@YAPAPAVEnemy@@PAPAV1@00@Z PROC ; std::_Move<Enemy * *,Enemy * *>, COMDAT

; 2485 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2486 : 	return (_Move(_First, _Last,
; 2487 : 		_Dest, _Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAVEnemy@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVEnemy@@0@Z ; std::_Ptr_cat<Enemy *,Enemy *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Move@PAPAVEnemy@@PAPAV1@@std@@YAPAPAVEnemy@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<Enemy * *,Enemy * *>
	add	esp, 16					; 00000010H

; 2488 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move@PAPAVEnemy@@PAPAV1@@std@@YAPAPAVEnemy@@PAPAV1@00@Z ENDP ; std::_Move<Enemy * *,Enemy * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVEnemy@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEXPAPAVEnemy@@ABQAV2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PAVEnemy@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEXPAPAVEnemy@@ABQAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<Enemy *> >::construct<Enemy *,Enemy * const &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@ABQAVEnemy@@@std@@YAABQAVEnemy@@ABQAV1@@Z ; std::forward<Enemy * const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PAVEnemy@@ABQAV1@@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SAXAAV?$allocator@PAVEnemy@@@1@PAPAVEnemy@@ABQAV3@@Z ; std::allocator_traits<std::allocator<Enemy *> >::construct<Enemy *,Enemy * const &>
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAVEnemy@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEXPAPAVEnemy@@ABQAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Enemy *> >::construct<Enemy *,Enemy * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVEnemy@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEXPAPAVEnemy@@AAPAV2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PAVEnemy@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEXPAPAVEnemy@@AAPAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<Enemy *> >::construct<Enemy *,Enemy * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAVEnemy@@@std@@YAAAPAVEnemy@@AAPAV1@@Z ; std::forward<Enemy * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PAVEnemy@@AAPAV1@@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SAXAAV?$allocator@PAVEnemy@@@1@PAPAVEnemy@@AAPAV3@@Z ; std::allocator_traits<std::allocator<Enemy *> >::construct<Enemy *,Enemy * &>
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAVEnemy@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEXPAPAVEnemy@@AAPAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Enemy *> >::construct<Enemy *,Enemy * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@QAVEnemy@@@std@@YAPBQAVEnemy@@ABQAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAVEnemy@@@std@@YAPBQAVEnemy@@ABQAV1@@Z PROC ; std::addressof<Enemy * const>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@QAVEnemy@@@std@@YAPBQAVEnemy@@ABQAV1@@Z ENDP ; std::addressof<Enemy * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@YA$$QAV?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@YA$$QAV?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@0@AAV10@@Z PROC ; std::forward<std::vector<Enemy *,std::allocator<Enemy *> > >, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@YA$$QAV?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::vector<Enemy *,std::allocator<Enemy *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@1@0PAPAV2@@Z
_TEXT	SEGMENT
tv71 = -280						; size = 4
tv142 = -276						; size = 4
tv139 = -272						; size = 4
tv145 = -268						; size = 4
$T2 = -260						; size = 4
$T3 = -248						; size = 4
$T4 = -236						; size = 4
__Alval$ = -29						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Ptr$ = 32						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@1@0PAPAV2@@Z PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > > >, COMDAT
; _this$ = ecx

; 1549 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@1@0PAPAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1550 : 		{	// copy initializing [_First, _Last), using allocator
; 1551 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Getal

; 1552 : 		return (_Uninitialized_copy(_First, _Last,
; 1553 : 			_Ptr, _Alval));

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv145[ebp], eax
	mov	eax, DWORD PTR tv145[ebp]
	mov	DWORD PTR tv139[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv142[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@PAPAVEnemy@@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@@std@@YAPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >,Enemy * *,std::_Wrap_alloc<std::allocator<Enemy *> > >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv71[ebp], eax
	mov	eax, DWORD PTR tv71[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T2[ebp]

; 1554 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@Ucopy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 280				; 00000118H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
	npad	2
$LN10@Ucopy:
	DD	1
	DD	$LN9@Ucopy
$LN9@Ucopy:
	DD	-29					; ffffffe3H
	DD	1
	DD	$LN7@Ucopy
$LN7@Ucopy:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@1@0PAPAV2@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@1@0PAPAV2@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@1@0PAPAV2@@Z$2:
	mov	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@1@0PAPAV2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-284]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@1@0PAPAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@1@0PAPAV2@@Z ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Move@PAPAVBullet@@PAPAV1@@std@@YAPAPAVBullet@@PAPAV1@00@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAPAVBullet@@PAPAV1@@std@@YAPAPAVBullet@@PAPAV1@00@Z PROC ; std::_Move<Bullet * *,Bullet * *>, COMDAT

; 2485 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2486 : 	return (_Move(_First, _Last,
; 2487 : 		_Dest, _Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAVBullet@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVBullet@@0@Z ; std::_Ptr_cat<Bullet *,Bullet *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Move@PAPAVBullet@@PAPAV1@@std@@YAPAPAVBullet@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<Bullet * *,Bullet * *>
	add	esp, 16					; 00000010H

; 2488 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move@PAPAVBullet@@PAPAV1@@std@@YAPAPAVBullet@@PAPAV1@00@Z ENDP ; std::_Move<Bullet * *,Bullet * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVBullet@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAEXPAPAVBullet@@ABQAV2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PAVBullet@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAEXPAPAVBullet@@ABQAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<Bullet *> >::construct<Bullet *,Bullet * const &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@ABQAVBullet@@@std@@YAABQAVBullet@@ABQAV1@@Z ; std::forward<Bullet * const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PAVBullet@@ABQAV1@@?$allocator_traits@V?$allocator@PAVBullet@@@std@@@std@@SAXAAV?$allocator@PAVBullet@@@1@PAPAVBullet@@ABQAV3@@Z ; std::allocator_traits<std::allocator<Bullet *> >::construct<Bullet *,Bullet * const &>
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAVBullet@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAEXPAPAVBullet@@ABQAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Bullet *> >::construct<Bullet *,Bullet * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVBullet@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAEXPAPAVBullet@@AAPAV2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PAVBullet@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAEXPAPAVBullet@@AAPAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<Bullet *> >::construct<Bullet *,Bullet * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAVBullet@@@std@@YAAAPAVBullet@@AAPAV1@@Z ; std::forward<Bullet * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PAVBullet@@AAPAV1@@?$allocator_traits@V?$allocator@PAVBullet@@@std@@@std@@SAXAAV?$allocator@PAVBullet@@@1@PAPAVBullet@@AAPAV3@@Z ; std::allocator_traits<std::allocator<Bullet *> >::construct<Bullet *,Bullet * &>
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAVBullet@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAEXPAPAVBullet@@AAPAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Bullet *> >::construct<Bullet *,Bullet * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@QAVBullet@@@std@@YAPBQAVBullet@@ABQAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAVBullet@@@std@@YAPBQAVBullet@@ABQAV1@@Z PROC ; std::addressof<Bullet * const>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@QAVBullet@@@std@@YAPBQAVBullet@@ABQAV1@@Z ENDP ; std::addressof<Bullet * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Move@PAPAVLivingEntity@@PAPAV1@@std@@YAPAPAVLivingEntity@@PAPAV1@00@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAPAVLivingEntity@@PAPAV1@@std@@YAPAPAVLivingEntity@@PAPAV1@00@Z PROC ; std::_Move<LivingEntity * *,LivingEntity * *>, COMDAT

; 2485 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2486 : 	return (_Move(_First, _Last,
; 2487 : 		_Dest, _Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAVLivingEntity@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVLivingEntity@@0@Z ; std::_Ptr_cat<LivingEntity *,LivingEntity *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Move@PAPAVLivingEntity@@PAPAV1@@std@@YAPAPAVLivingEntity@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<LivingEntity * *,LivingEntity * *>
	add	esp, 16					; 00000010H

; 2488 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move@PAPAVLivingEntity@@PAPAV1@@std@@YAPAPAVLivingEntity@@PAPAV1@00@Z ENDP ; std::_Move<LivingEntity * *,LivingEntity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVLivingEntity@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEXPAPAVLivingEntity@@ABQAV2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PAVLivingEntity@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEXPAPAVLivingEntity@@ABQAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::construct<LivingEntity *,LivingEntity * const &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@ABQAVLivingEntity@@@std@@YAABQAVLivingEntity@@ABQAV1@@Z ; std::forward<LivingEntity * const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PAVLivingEntity@@ABQAV1@@?$allocator_traits@V?$allocator@PAVLivingEntity@@@std@@@std@@SAXAAV?$allocator@PAVLivingEntity@@@1@PAPAVLivingEntity@@ABQAV3@@Z ; std::allocator_traits<std::allocator<LivingEntity *> >::construct<LivingEntity *,LivingEntity * const &>
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAVLivingEntity@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEXPAPAVLivingEntity@@ABQAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::construct<LivingEntity *,LivingEntity * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVLivingEntity@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEXPAPAVLivingEntity@@AAPAV2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PAVLivingEntity@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEXPAPAVLivingEntity@@AAPAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::construct<LivingEntity *,LivingEntity * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAVLivingEntity@@@std@@YAAAPAVLivingEntity@@AAPAV1@@Z ; std::forward<LivingEntity * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PAVLivingEntity@@AAPAV1@@?$allocator_traits@V?$allocator@PAVLivingEntity@@@std@@@std@@SAXAAV?$allocator@PAVLivingEntity@@@1@PAPAVLivingEntity@@AAPAV3@@Z ; std::allocator_traits<std::allocator<LivingEntity *> >::construct<LivingEntity *,LivingEntity * &>
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAVLivingEntity@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEXPAPAVLivingEntity@@AAPAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::construct<LivingEntity *,LivingEntity * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@QAVLivingEntity@@@std@@YAPBQAVLivingEntity@@ABQAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAVLivingEntity@@@std@@YAPBQAVLivingEntity@@ABQAV1@@Z PROC ; std::addressof<LivingEntity * const>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@QAVLivingEntity@@@std@@YAPBQAVLivingEntity@@ABQAV1@@Z ENDP ; std::addressof<LivingEntity * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Move@PAPAVOnScreen@@PAPAV1@@std@@YAPAPAVOnScreen@@PAPAV1@00@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAPAVOnScreen@@PAPAV1@@std@@YAPAPAVOnScreen@@PAPAV1@00@Z PROC ; std::_Move<OnScreen * *,OnScreen * *>, COMDAT

; 2485 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2486 : 	return (_Move(_First, _Last,
; 2487 : 		_Dest, _Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAVOnScreen@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVOnScreen@@0@Z ; std::_Ptr_cat<OnScreen *,OnScreen *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Move@PAPAVOnScreen@@PAPAV1@@std@@YAPAPAVOnScreen@@PAPAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<OnScreen * *,OnScreen * *>
	add	esp, 16					; 00000010H

; 2488 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move@PAPAVOnScreen@@PAPAV1@@std@@YAPAPAVOnScreen@@PAPAV1@00@Z ENDP ; std::_Move<OnScreen * *,OnScreen * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVOnScreen@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAEXPAPAVOnScreen@@ABQAV2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PAVOnScreen@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAEXPAPAVOnScreen@@ABQAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<OnScreen *> >::construct<OnScreen *,OnScreen * const &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@ABQAVOnScreen@@@std@@YAABQAVOnScreen@@ABQAV1@@Z ; std::forward<OnScreen * const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PAVOnScreen@@ABQAV1@@?$allocator_traits@V?$allocator@PAVOnScreen@@@std@@@std@@SAXAAV?$allocator@PAVOnScreen@@@1@PAPAVOnScreen@@ABQAV3@@Z ; std::allocator_traits<std::allocator<OnScreen *> >::construct<OnScreen *,OnScreen * const &>
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAVOnScreen@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAEXPAPAVOnScreen@@ABQAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<OnScreen *> >::construct<OnScreen *,OnScreen * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVOnScreen@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAEXPAPAVOnScreen@@AAPAV2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PAVOnScreen@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAEXPAPAVOnScreen@@AAPAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<OnScreen *> >::construct<OnScreen *,OnScreen * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAVOnScreen@@@std@@YAAAPAVOnScreen@@AAPAV1@@Z ; std::forward<OnScreen * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PAVOnScreen@@AAPAV1@@?$allocator_traits@V?$allocator@PAVOnScreen@@@std@@@std@@SAXAAV?$allocator@PAVOnScreen@@@1@PAPAVOnScreen@@AAPAV3@@Z ; std::allocator_traits<std::allocator<OnScreen *> >::construct<OnScreen *,OnScreen * &>
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAVOnScreen@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAEXPAPAVOnScreen@@AAPAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<OnScreen *> >::construct<OnScreen *,OnScreen * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@QAVOnScreen@@@std@@YAPBQAVOnScreen@@ABQAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAVOnScreen@@@std@@YAPBQAVOnScreen@@ABQAV1@@Z PROC ; std::addressof<OnScreen * const>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@QAVOnScreen@@@std@@YAPBQAVOnScreen@@ABQAV1@@Z ENDP ; std::addressof<OnScreen * const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBEPQ?$_Bool_struct@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@2@HXZ
_TEXT	SEGMENT
tv67 = -208						; size = 4
_this$ = -8						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBEPQ?$_Bool_struct@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@2@HXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator int std::_Bool_struct<std::basic_ostream<char,std::char_traits<char> > >::*, COMDAT
; _this$ = ecx

; 146  : 			{	// test if stream state okay

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 			return (_Ok ? _CONVERTIBLE_TO_TRUE : 0);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN3@
	mov	DWORD PTR tv67[ebp], 0
	jmp	SHORT $LN4@
$LN3@:
	mov	DWORD PTR tv67[ebp], -1
$LN4@:
	mov	eax, DWORD PTR tv67[ebp]

; 148  : 			}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBEPQ?$_Bool_struct@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@2@HXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator int std::_Bool_struct<std::basic_ostream<char,std::char_traits<char> > >::*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 133  : 			{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 134  :  #if _HAS_EXCEPTIONS
; 135  : 			if (!_XSTD uncaught_exception())

	mov	esi, esp
	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@sentry

; 136  : 				this->_Myostr._Osfx();

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@sentry:

; 137  : 
; 138  :  #else /* _HAS_EXCEPTIONS */
; 139  : 			this->_Myostr._Osfx();
; 140  :  #endif /* _HAS_EXCEPTIONS */
; 141  : 			}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 126  : 			{	// construct locking and testing stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 127  : 			if (_Ostr.good() && _Ostr.tie() != 0)

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@sentry
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN1@sentry

; 128  : 				_Ostr.tie()->flush();

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	ecx, eax
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@sentry:

; 129  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], al

; 130  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv92 = -212						; size = 4
tv86 = -208						; size = 4
tv72 = -208						; size = 4
_this$ = -8						; size = 4
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 109  : 			{	// destroy after unlocking

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-212]
	mov	ecx, 53					; 00000035H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 110  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv72[ebp], ecx
	mov	edx, DWORD PTR tv72[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv72[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN2@Sentry_bas

; 111  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv86[ebp], ecx
	mov	edx, DWORD PTR tv86[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv86[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv92[ebp], eax
	mov	ecx, DWORD PTR tv92[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	ecx, DWORD PTR tv92[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Sentry_bas:

; 112  : 			}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 212				; 000000d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv93 = -212						; size = 4
tv87 = -208						; size = 4
tv73 = -208						; size = 4
_this$ = -8						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 103  : 			{	// lock the stream buffer, if there

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-212]
	mov	ecx, 53					; 00000035H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR [eax], ecx

; 104  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR tv73[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv73[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN2@Sentry_bas

; 105  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv87[ebp], ecx
	mov	edx, DWORD PTR tv87[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv87[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv93[ebp], eax
	mov	ecx, DWORD PTR tv93[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	ecx, DWORD PTR tv93[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Sentry_bas:

; 106  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 212				; 000000d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator!=<std::allocator<char>,std::allocator<char> >, COMDAT

; 930  : 	{	// test for allocator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 931  : 	return (!(_Left == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	call	??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::operator==<std::allocator<char>,std::allocator<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 932  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT _main
_TEXT	SEGMENT
tv92 = -524						; size = 4
tv208 = -520						; size = 4
tv70 = -520						; size = 4
tv251 = -516						; size = 4
tv241 = -516						; size = 4
tv185 = -516						; size = 4
tv176 = -516						; size = 4
tv163 = -516						; size = 4
tv150 = -516						; size = 4
tv137 = -516						; size = 4
$T2 = -508						; size = 4
$T3 = -496						; size = 4
$T4 = -484						; size = 4
$T5 = -472						; size = 4
$T6 = -460						; size = 4
$T7 = -448						; size = 4
$T8 = -436						; size = 4
$T9 = -424						; size = 4
$T10 = -412						; size = 4
$T11 = -400						; size = 4
$T12 = -388						; size = 4
$T13 = -376						; size = 4
$T14 = -364						; size = 4
$T15 = -349						; size = 1
$T16 = -340						; size = 16
$T17 = -316						; size = 8
$T18 = -300						; size = 4
$T19 = -288						; size = 4
_aiThread$ = -84					; size = 8
_soldier4$ = -68					; size = 4
_soldier3$ = -56					; size = 4
_soldier2$ = -44					; size = 4
_soldier$ = -32						; size = 4
_player$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_main	PROC						; COMDAT

; 510  : int main(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$_main
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 512				; 00000200H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-524]
	mov	ecx, 128				; 00000080H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T19[ebp], 0

; 511  : 	
; 512  : 	mainMenu();

	call	?mainMenu@@YAXXZ			; mainMenu

; 513  : 
; 514  : 	Player *player = new Player(5, 5, 100.0, 10, 0, 1);

	push	64					; 00000040H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN7@main
	push	1
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	push	OFFSET ??_C@_08IDPINFPD@Player?51?$AA@
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv241[ebp], eax
	push	1
	push	0
	push	10					; 0000000aH
	push	ecx
	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR [esp], xmm0
	push	5
	push	5
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0Player@@QAE@HHMHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Directions@@@Z ; Player::Player
	mov	DWORD PTR tv70[ebp], eax
	mov	eax, DWORD PTR tv70[ebp]
	mov	DWORD PTR tv92[ebp], eax
	jmp	SHORT $LN8@main
$LN7@main:
	mov	DWORD PTR tv92[ebp], 0
$LN8@main:
	mov	ecx, DWORD PTR tv92[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _player$[ebp], edx

; 515  : 	EnemySoldier *soldier = new EnemySoldier(8, 17, 10);

	push	32					; 00000020H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN9@main
	push	1
	push	1
	push	1
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	push	17					; 00000011H
	push	8
	mov	ecx, DWORD PTR $T6[ebp]
	call	??0EnemySoldier@@QAE@HHMHHH@Z		; EnemySoldier::EnemySoldier
	mov	DWORD PTR tv137[ebp], eax
	jmp	SHORT $LN10@main
$LN9@main:
	mov	DWORD PTR tv137[ebp], 0
$LN10@main:
	mov	eax, DWORD PTR tv137[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR _soldier$[ebp], ecx

; 516  : 	EnemySoldier *soldier2 = new EnemySoldier(10, 5, 10);

	push	32					; 00000020H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T8[ebp], 0
	je	SHORT $LN11@main
	push	1
	push	1
	push	1
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	push	5
	push	10					; 0000000aH
	mov	ecx, DWORD PTR $T8[ebp]
	call	??0EnemySoldier@@QAE@HHMHHH@Z		; EnemySoldier::EnemySoldier
	mov	DWORD PTR tv150[ebp], eax
	jmp	SHORT $LN12@main
$LN11@main:
	mov	DWORD PTR tv150[ebp], 0
$LN12@main:
	mov	eax, DWORD PTR tv150[ebp]
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T7[ebp]
	mov	DWORD PTR _soldier2$[ebp], ecx

; 517  : 	EnemySoldier *soldier3 = new EnemySoldier(20, 8, 10);

	push	32					; 00000020H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T10[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T10[ebp], 0
	je	SHORT $LN13@main
	push	1
	push	1
	push	1
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	push	8
	push	20					; 00000014H
	mov	ecx, DWORD PTR $T10[ebp]
	call	??0EnemySoldier@@QAE@HHMHHH@Z		; EnemySoldier::EnemySoldier
	mov	DWORD PTR tv163[ebp], eax
	jmp	SHORT $LN14@main
$LN13@main:
	mov	DWORD PTR tv163[ebp], 0
$LN14@main:
	mov	eax, DWORD PTR tv163[ebp]
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T9[ebp]
	mov	DWORD PTR _soldier3$[ebp], ecx

; 518  : 	EnemySoldier *soldier4 = new EnemySoldier(2, 2, 10);

	push	32					; 00000020H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T12[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T12[ebp], 0
	je	SHORT $LN15@main
	push	1
	push	1
	push	1
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	push	2
	push	2
	mov	ecx, DWORD PTR $T12[ebp]
	call	??0EnemySoldier@@QAE@HHMHHH@Z		; EnemySoldier::EnemySoldier
	mov	DWORD PTR tv176[ebp], eax
	jmp	SHORT $LN16@main
$LN15@main:
	mov	DWORD PTR tv176[ebp], 0
$LN16@main:
	mov	eax, DWORD PTR tv176[ebp]
	mov	DWORD PTR $T11[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T11[ebp]
	mov	DWORD PTR _soldier4$[ebp], ecx

; 519  : 	gameView = new Screen('-', player);

	push	912					; 00000390H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T14[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	cmp	DWORD PTR $T14[ebp], 0
	je	SHORT $LN17@main
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	push	45					; 0000002dH
	mov	ecx, DWORD PTR $T14[ebp]
	call	??0Screen@@QAE@DPAVPlayer@@@Z		; Screen::Screen
	mov	DWORD PTR tv185[ebp], eax
	jmp	SHORT $LN18@main
$LN17@main:
	mov	DWORD PTR tv185[ebp], 0
$LN18@main:
	mov	ecx, DWORD PTR tv185[ebp]
	mov	DWORD PTR $T13[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T13[ebp]
	mov	DWORD PTR ?gameView@@3PAVScreen@@A, edx	; gameView

; 520  : 
; 521  : 	pthread_t aiThread;
; 522  : 	/*cout << typeid(player).name() << endl;
; 523  : 	system("pause");*/
; 524  : 	//pthread_create(&aiThread, NULL, processaiwhole, player);
; 525  : 	pthread_create(&aiThread, NULL, processaibysingle, player);

	mov	esi, esp
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	push	OFFSET ?processaibysingle@@YAPAXPAX@Z	; processaibysingle
	push	0
	lea	ecx, DWORD PTR _aiThread$[ebp]
	push	ecx
	call	DWORD PTR __imp__pthread_create
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 526  : 	srand(time(NULL));

	push	0
	call	_time
	add	esp, 4
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__srand
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@main:

; 527  : 	while (player->isAlive() && Enemy::getEnemies().size()>0){

	mov	ecx, DWORD PTR _player$[ebp]
	call	?isAlive@LivingEntity@@QAE_NXZ		; LivingEntity::isAlive
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@main
	lea	ecx, DWORD PTR $T16[ebp]
	push	ecx
	call	?getEnemies@Enemy@@SA?AV?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@XZ ; Enemy::getEnemies
	add	esp, 4
	mov	DWORD PTR tv251[ebp], eax
	mov	edx, DWORD PTR $T19[ebp]
	or	edx, 1
	mov	DWORD PTR $T19[ebp], edx
	mov	ecx, DWORD PTR tv251[ebp]
	call	?size@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ; std::vector<Enemy *,std::allocator<Enemy *> >::size
	test	eax, eax
	jbe	SHORT $LN19@main
	mov	DWORD PTR tv208[ebp], 1
	jmp	SHORT $LN20@main
$LN19@main:
	mov	DWORD PTR tv208[ebp], 0
$LN20@main:
	mov	al, BYTE PTR tv208[ebp]
	mov	BYTE PTR $T15[ebp], al
	mov	ecx, DWORD PTR $T19[ebp]
	and	ecx, 1
	je	SHORT $LN30@main
	and	DWORD PTR $T19[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T16[ebp]
	call	??1?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@XZ ; std::vector<Enemy *,std::allocator<Enemy *> >::~vector<Enemy *,std::allocator<Enemy *> >
$LN30@main:
	movzx	edx, BYTE PTR $T15[ebp]
	test	edx, edx
	je	SHORT $LN3@main

; 528  : 		pthread_mutex_lock(&ai_player_mutex);

	mov	esi, esp
	push	OFFSET ?ai_player_mutex@@3PAUpthread_mutex_t_@@A ; ai_player_mutex
	call	DWORD PTR __imp__pthread_mutex_lock
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 529  : 		levelOne(gameView);

	mov	eax, DWORD PTR ?gameView@@3PAVScreen@@A	; gameView
	push	eax
	call	?levelOne@@YAXPAVScreen@@@Z		; levelOne
	add	esp, 4

; 530  : 		getInput(player);

	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	call	?getInput@@YAXPAVPlayer@@@Z		; getInput
	add	esp, 4

; 531  : 		gameView->render();

	mov	ecx, DWORD PTR ?gameView@@3PAVScreen@@A	; gameView
	call	?render@Screen@@QAEXXZ			; Screen::render

; 532  : 		pthread_mutex_unlock(&ai_player_mutex);

	mov	esi, esp
	push	OFFSET ?ai_player_mutex@@3PAUpthread_mutex_t_@@A ; ai_player_mutex
	call	DWORD PTR __imp__pthread_mutex_unlock
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 533  : 		this_thread::sleep_for(chrono::milliseconds(1)); // just enough time to allow for processai

	mov	DWORD PTR $T18[ebp], 1
	push	0
	lea	eax, DWORD PTR $T18[ebp]
	push	eax
	lea	ecx, DWORD PTR $T17[ebp]
	call	??$?0H@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@ABHPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><int>
	push	eax
	call	??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z ; std::this_thread::sleep_for<__int64,std::ratio<1,1000> >
	add	esp, 4

; 534  : 	}

	jmp	$LN4@main
$LN3@main:

; 535  : 	system("cls");

	mov	esi, esp
	push	OFFSET ??_C@_03LCPHGAHP@cls?$AA@
	call	DWORD PTR __imp__system
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 536  : 	if(player->isAlive()){

	mov	ecx, DWORD PTR _player$[ebp]
	call	?isAlive@LivingEntity@@QAE_NXZ		; LivingEntity::isAlive
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@main

; 537  : 		cout << "you win!";

	push	OFFSET ??_C@_08DGMLKBON@you?5win?$CB?$AA@
	mov	eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 538  : 	}
; 539  : 	else{

	jmp	SHORT $LN1@main
$LN2@main:

; 540  : 		cout << "you lose!";

	push	OFFSET ??_C@_09GBKDONCB@you?5lose?$CB?$AA@
	mov	eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
$LN1@main:

; 541  : 	}
; 542  : 	cout << endl;

	mov	esi, esp
	mov	eax, DWORD PTR __imp_?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
	push	eax
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 543  : 	system("pause");

	mov	esi, esp
	push	OFFSET ??_C@_05PDJBBECF@pause?$AA@
	call	DWORD PTR __imp__system
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 544  : 	//pthread_join(aiThread, NULL); don't do, AI never stops
; 545  : 	return 0;

	xor	eax, eax

; 546  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN34@main
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 524				; 0000020cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN34@main:
	DD	1
	DD	$LN33@main
$LN33@main:
	DD	-84					; ffffffacH
	DD	8
	DD	$LN31@main
$LN31@main:
	DB	97					; 00000061H
	DB	105					; 00000069H
	DB	84					; 00000054H
	DB	104					; 00000068H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_main$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$_main$2:
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$_main$3:
	mov	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$_main$4:
	mov	eax, DWORD PTR $T10[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$_main$5:
	mov	eax, DWORD PTR $T12[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$_main$6:
	mov	eax, DWORD PTR $T14[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$_main:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-528]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$_main
	jmp	___CxxFrameHandler3
text$x	ENDS
_main	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?mainMenu@@YAXXZ
_TEXT	SEGMENT
?mainMenu@@YAXXZ PROC					; mainMenu, COMDAT

; 504  : void mainMenu(){

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 505  : 	cout << "A little (glitchy) game that I made just for you. Hope you like it!" << endl << "Now, do you want (0) no colors and no lag or (1) colors and lag?" << endl << "Anything else, and it'll just be random" << endl;

	mov	esi, esp
	mov	eax, DWORD PTR __imp_?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
	push	eax
	push	OFFSET ??_C@_0CI@FIKJMPDF@Anything?5else?0?5and?5it?8ll?5just?5be@
	mov	edi, esp
	mov	ecx, DWORD PTR __imp_?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
	push	ecx
	push	OFFSET ??_C@_0EB@EJGMMLCB@Now?0?5do?5you?5want?5?$CI0?$CJ?5no?5colors?5a@
	mov	ebx, esp
	mov	edx, DWORD PTR __imp_?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
	push	edx
	push	OFFSET ??_C@_0EE@NEGOOMNL@A?5little?5?$CIglitchy?$CJ?5game?5that?5I?5m@
	mov	eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	ebx, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 506  : 	cin >> colorsEnabled;

	mov	esi, esp
	push	OFFSET ?colorsEnabled@@3_NA		; colorsEnabled
	mov	ecx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
	call	DWORD PTR __imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AA_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 507  : 	system("cls");

	mov	esi, esp
	push	OFFSET ??_C@_03LCPHGAHP@cls?$AA@
	call	DWORD PTR __imp__system
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 508  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?mainMenu@@YAXXZ ENDP					; mainMenu
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?levelOne@@YAXPAVScreen@@@Z
_TEXT	SEGMENT
tv89 = -256						; size = 4
$T2 = -248						; size = 4
$T3 = -236						; size = 4
_newsoldier$4 = -32					; size = 4
_randcoordinates$5 = -20				; size = 4
__$EHRec$ = -12						; size = 12
_screen$ = 8						; size = 4
?levelOne@@YAXPAVScreen@@@Z PROC			; levelOne, COMDAT

; 493  : void levelOne(Screen* screen){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?levelOne@@YAXPAVScreen@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 494  : 
; 495  : 	if(rand()%100 == 0){

	mov	esi, esp
	call	DWORD PTR __imp__rand
	cmp	esi, esp
	call	__RTC_CheckEsp
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	test	edx, edx
	jne	$LN4@levelOne

; 496  : 		int randcoordinates = 0;

	mov	DWORD PTR _randcoordinates$5[ebp], 0
$LN3@levelOne:

; 497  : 		do{
; 498  : 			randcoordinates = rand()%20+1;

	mov	esi, esp
	call	DWORD PTR __imp__rand
	cmp	esi, esp
	call	__RTC_CheckEsp
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	add	edx, 1
	mov	DWORD PTR _randcoordinates$5[ebp], edx

; 499  : 		}while(screen->stuffAt(randcoordinates, 1));

	push	1
	mov	eax, DWORD PTR _randcoordinates$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _screen$[ebp]
	call	?stuffAt@Screen@@QAE_NHH@Z		; Screen::stuffAt
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@levelOne

; 500  : 		EnemySoldier *newsoldier = new EnemySoldier(randcoordinates, 1, 10);

	push	32					; 00000020H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN7@levelOne
	push	1
	push	1
	push	1
	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	eax, DWORD PTR _randcoordinates$5[ebp]
	push	eax
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0EnemySoldier@@QAE@HHMHHH@Z		; EnemySoldier::EnemySoldier
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN8@levelOne
$LN7@levelOne:
	mov	DWORD PTR tv89[ebp], 0
$LN8@levelOne:
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newsoldier$4[ebp], edx
$LN4@levelOne:

; 501  : 	}
; 502  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?levelOne@@YAXPAVScreen@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?levelOne@@YAXPAVScreen@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?levelOne@@YAXPAVScreen@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?levelOne@@YAXPAVScreen@@@Z ENDP			; levelOne
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?processaibysingle@@YAPAXPAX@Z
_TEXT	SEGMENT
tv143 = -372						; size = 4
tv79 = -372						; size = 4
tv144 = -368						; size = 4
tv141 = -368						; size = 4
tv139 = -368						; size = 4
$T2 = -360						; size = 16
$T3 = -333						; size = 1
$T4 = -324						; size = 16
$T5 = -300						; size = 16
$T6 = -276						; size = 8
$T7 = -260						; size = 4
_enemy$8 = -56						; size = 4
_i$9 = -44						; size = 4
_numberOfEnemies$10 = -32				; size = 4
_p$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_args$ = 8						; size = 4
?processaibysingle@@YAPAXPAX@Z PROC			; processaibysingle, COMDAT

; 478  : void* processaibysingle(void* args){ // multithread wrapper

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?processaibysingle@@YAPAXPAX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 360				; 00000168H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-372]
	mov	ecx, 90					; 0000005aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 479  : 	Player *p = reinterpret_cast<Player*>(args);

	mov	eax, DWORD PTR _args$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN5@processaib:

; 480  : 	while(true){

	mov	eax, 1
	test	eax, eax
	je	$LN4@processaib

; 481  : 		int numberOfEnemies = Enemy::getEnemies().size();

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?getEnemies@Enemy@@SA?AV?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@XZ ; Enemy::getEnemies
	add	esp, 4
	mov	DWORD PTR tv139[ebp], eax
	mov	ecx, DWORD PTR tv139[ebp]
	call	?size@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ; std::vector<Enemy *,std::allocator<Enemy *> >::size
	mov	DWORD PTR _numberOfEnemies$10[ebp], eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@XZ ; std::vector<Enemy *,std::allocator<Enemy *> >::~vector<Enemy *,std::allocator<Enemy *> >

; 482  : 		for(int i = 0; i < Enemy::getEnemies().size(); i++){

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN3@processaib
$LN2@processaib:
	mov	eax, DWORD PTR _i$9[ebp]
	add	eax, 1
	mov	DWORD PTR _i$9[ebp], eax
$LN3@processaib:
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?getEnemies@Enemy@@SA?AV?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@XZ ; Enemy::getEnemies
	add	esp, 4
	mov	DWORD PTR tv141[ebp], eax
	mov	ecx, DWORD PTR tv141[ebp]
	call	?size@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ; std::vector<Enemy *,std::allocator<Enemy *> >::size
	cmp	DWORD PTR _i$9[ebp], eax
	jae	SHORT $LN8@processaib
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN9@processaib
$LN8@processaib:
	mov	DWORD PTR tv79[ebp], 0
$LN9@processaib:
	mov	cl, BYTE PTR tv79[ebp]
	mov	BYTE PTR $T3[ebp], cl
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@XZ ; std::vector<Enemy *,std::allocator<Enemy *> >::~vector<Enemy *,std::allocator<Enemy *> >
	movzx	edx, BYTE PTR $T3[ebp]
	test	edx, edx
	je	$LN1@processaib

; 483  : 			pthread_mutex_lock(&ai_player_mutex);

	mov	esi, esp
	push	OFFSET ?ai_player_mutex@@3PAUpthread_mutex_t_@@A ; ai_player_mutex
	call	DWORD PTR __imp__pthread_mutex_lock
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 484  : 			Enemy* enemy = Enemy::getEnemies()[i];	

	mov	eax, DWORD PTR _i$9[ebp]
	push	eax
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	call	?getEnemies@Enemy@@SA?AV?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@XZ ; Enemy::getEnemies
	add	esp, 4
	mov	DWORD PTR tv144[ebp], eax
	mov	edx, DWORD PTR tv144[ebp]
	mov	DWORD PTR tv143[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv143[ebp]
	call	??A?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAEAAPAVEnemy@@I@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _enemy$8[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T5[ebp]
	call	??1?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@XZ ; std::vector<Enemy *,std::allocator<Enemy *> >::~vector<Enemy *,std::allocator<Enemy *> >

; 485  : 			enemy->processAndAct(p);

	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _enemy$8[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _enemy$8[ebp]
	mov	eax, DWORD PTR [edx+20]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 486  : 			pthread_mutex_unlock(&ai_player_mutex);

	mov	esi, esp
	push	OFFSET ?ai_player_mutex@@3PAUpthread_mutex_t_@@A ; ai_player_mutex
	call	DWORD PTR __imp__pthread_mutex_unlock
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 487  : 			this_thread::sleep_for(chrono::milliseconds(AI_MILLISECOND_SPEED/numberOfEnemies));

	mov	eax, 1000				; 000003e8H
	cdq
	idiv	DWORD PTR _numberOfEnemies$10[ebp]
	mov	DWORD PTR $T7[ebp], eax
	push	0
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	lea	ecx, DWORD PTR $T6[ebp]
	call	??$?0H@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@ABHPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><int>
	push	eax
	call	??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z ; std::this_thread::sleep_for<__int64,std::ratio<1,1000> >
	add	esp, 4

; 488  : 		}

	jmp	$LN2@processaib
$LN1@processaib:

; 489  : 	}

	jmp	$LN5@processaib
$LN4@processaib:

; 490  : 	return NULL;

	xor	eax, eax

; 491  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 372				; 00000174H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?processaibysingle@@YAPAXPAX@Z$2:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@XZ ; std::vector<Enemy *,std::allocator<Enemy *> >::~vector<Enemy *,std::allocator<Enemy *> >
__ehhandler$?processaibysingle@@YAPAXPAX@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-376]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?processaibysingle@@YAPAXPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?processaibysingle@@YAPAXPAX@Z ENDP			; processaibysingle
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z
_TEXT	SEGMENT
$T1 = -264						; size = 16
$T2 = -240						; size = 16
__Tgt$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
__Rel_time$ = 8						; size = 4
??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z PROC ; std::this_thread::sleep_for<__int64,std::ratio<1,1000> >, COMDAT

; 163  : 	{	// sleep for duration

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 164  : 	stdext::threads::xtime _Tgt = _To_xtime(_Rel_time);

	mov	eax, DWORD PTR __Rel_time$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$_To_xtime@_JU?$ratio@$00$0DOI@@std@@@std@@YA?AUxtime@@ABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@0@@Z ; std::_To_xtime<__int64,std::ratio<1,1000> >
	add	esp, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T2[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T2[ebp+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR $T2[ebp+12], eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR __Tgt$[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR __Tgt$[ebp+4], edx
	mov	eax, DWORD PTR $T2[ebp+8]
	mov	DWORD PTR __Tgt$[ebp+8], eax
	mov	ecx, DWORD PTR $T2[ebp+12]
	mov	DWORD PTR __Tgt$[ebp+12], ecx

; 165  : 	sleep_until(&_Tgt);

	lea	eax, DWORD PTR __Tgt$[ebp]
	push	eax
	call	?sleep_until@this_thread@std@@YAXPBUxtime@@@Z ; std::this_thread::sleep_until
	add	esp, 4

; 166  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@sleep_for
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@sleep_for:
	DD	1
	DD	$LN4@sleep_for
$LN4@sleep_for:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN3@sleep_for
$LN3@sleep_for:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	103					; 00000067H
	DB	116					; 00000074H
	DB	0
??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z ENDP ; std::this_thread::sleep_for<__int64,std::ratio<1,1000> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$?0H@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@ABHPAPAX@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?0H@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@ABHPAPAX@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><int>, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from representation

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [eax]
	cdq
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0H@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@ABHPAPAX@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ?zero@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@SA?AV123@XZ
_TEXT	SEGMENT
$T1 = -204						; size = 8
___$ReturnUdt$ = 8					; size = 4
?zero@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@SA?AV123@XZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000> >::zero, COMDAT

; 203  : 		{	// get zero value

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 204  : 		return (_Myt(duration_values<_Rep>::zero()));

	call	?zero@?$duration_values@_J@chrono@std@@SA_JXZ ; std::chrono::duration_values<__int64>::zero
	mov	DWORD PTR $T1[ebp], eax
	mov	DWORD PTR $T1[ebp+4], edx
	push	0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0_J@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><__int64>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 205  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?zero@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@SA?AV123@XZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000> >::zero
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000> >::count, COMDAT
; _this$ = ecx

; 130  : 		{	// get stored rep

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 131  : 		return (_MyRep);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+4]

; 132  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?processaiwhole@@YAPAXPAX@Z
_TEXT	SEGMENT
$T1 = -228						; size = 8
$T2 = -212						; size = 4
_p$ = -8						; size = 4
_args$ = 8						; size = 4
?processaiwhole@@YAPAXPAX@Z PROC			; processaiwhole, COMDAT

; 467  : void* processaiwhole(void* args){ // multithread wrapper

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 468  : 	Player *p = reinterpret_cast<Player*>(args);

	mov	eax, DWORD PTR _args$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN2@processaiw:

; 469  : 	while(true){

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN1@processaiw

; 470  : 		pthread_mutex_lock(&ai_player_mutex);

	mov	esi, esp
	push	OFFSET ?ai_player_mutex@@3PAUpthread_mutex_t_@@A ; ai_player_mutex
	call	DWORD PTR __imp__pthread_mutex_lock
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 471  : 		Enemy::aiTurn(p);

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	?aiTurn@Enemy@@SAXPAVLivingEntity@@@Z	; Enemy::aiTurn
	add	esp, 4

; 472  : 		pthread_mutex_unlock(&ai_player_mutex);

	mov	esi, esp
	push	OFFSET ?ai_player_mutex@@3PAUpthread_mutex_t_@@A ; ai_player_mutex
	call	DWORD PTR __imp__pthread_mutex_unlock
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 473  : 		this_thread::sleep_for(chrono::milliseconds(AI_MILLISECOND_SPEED));

	mov	DWORD PTR $T2[ebp], 1000		; 000003e8H
	push	0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	??$?0H@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@ABHPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><int>
	push	eax
	call	??$sleep_for@_JU?$ratio@$00$0DOI@@std@@@this_thread@std@@YAXABV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@1@@Z ; std::this_thread::sleep_for<__int64,std::ratio<1,1000> >
	add	esp, 4

; 474  : 	}

	jmp	SHORT $LN2@processaiw
$LN1@processaiw:

; 475  : 	return NULL;

	xor	eax, eax

; 476  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?processaiwhole@@YAPAXPAX@Z ENDP			; processaiwhole
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?getInput@@YAXPAVPlayer@@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_input$1 = -5						; size = 1
_player$ = 8						; size = 4
?getInput@@YAXPAVPlayer@@@Z PROC			; getInput, COMDAT

; 436  : void getInput(Player* player){

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 437  : 	if(kbhit()){

	mov	esi, esp
	call	DWORD PTR __imp__kbhit
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	$LN10@getInput

; 438  : 		char input = getch();

	mov	esi, esp
	call	DWORD PTR __imp__getch
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR _input$1[ebp], al

; 439  : 		switch (input){

	movsx	eax, BYTE PTR _input$1[ebp]
	mov	DWORD PTR tv69[ebp], eax
	mov	ecx, DWORD PTR tv69[ebp]
	sub	ecx, 32					; 00000020H
	mov	DWORD PTR tv69[ebp], ecx
	cmp	DWORD PTR tv69[ebp], 87			; 00000057H
	ja	SHORT $LN10@getInput
	mov	edx, DWORD PTR tv69[ebp]
	movzx	eax, BYTE PTR $LN12@getInput[edx]
	jmp	DWORD PTR $LN13@getInput[eax*4]
$LN6@getInput:

; 440  : 		case 'w':
; 441  : 		case 'W':
; 442  : 			player->move(Directions::UP);

	push	2
	mov	ecx, DWORD PTR _player$[ebp]
	call	?move@Player@@QAEXW4Directions@@@Z	; Player::move

; 443  : 			break;

	jmp	SHORT $LN10@getInput
$LN5@getInput:

; 444  : 		case 's':
; 445  : 		case 'S':
; 446  : 			player->move(Directions::DOWN);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _player$[ebp]
	call	?move@Player@@QAEXW4Directions@@@Z	; Player::move

; 447  : 			break;

	jmp	SHORT $LN10@getInput
$LN4@getInput:

; 448  : 		case 'a':
; 449  : 		case 'A':
; 450  : 			player->move(Directions::LEFT);

	push	-1
	mov	ecx, DWORD PTR _player$[ebp]
	call	?move@Player@@QAEXW4Directions@@@Z	; Player::move

; 451  : 			break;

	jmp	SHORT $LN10@getInput
$LN3@getInput:

; 452  : 		case 'd':
; 453  : 		case 'D':
; 454  : 			player->move(Directions::RIGHT);

	push	1
	mov	ecx, DWORD PTR _player$[ebp]
	call	?move@Player@@QAEXW4Directions@@@Z	; Player::move

; 455  : 			break;

	jmp	SHORT $LN10@getInput
$LN2@getInput:

; 456  : 		case ' ':
; 457  : 			player->shoot(player->facing);

	mov	esi, esp
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _player$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@getInput:

; 458  : 			break;
; 459  : 		default:
; 460  : 			break;
; 461  : 		}
; 462  : 	}
; 463  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN13@getInput:
	DD	$LN2@getInput
	DD	$LN4@getInput
	DD	$LN3@getInput
	DD	$LN5@getInput
	DD	$LN6@getInput
	DD	$LN10@getInput
$LN12@getInput:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	5
	DB	5
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	5
	DB	5
	DB	5
	DB	4
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	5
	DB	5
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	5
	DB	5
	DB	5
	DB	4
?getInput@@YAXPAVPlayer@@@Z ENDP			; getInput
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\string
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
tv410 = -340						; size = 8
tv293 = -332						; size = 4
tv290 = -332						; size = 8
tv288 = -332						; size = 4
tv136 = -332						; size = 4
tv328 = -328						; size = 8
tv292 = -328						; size = 4
tv287 = -328						; size = 4
tv289 = -324						; size = 4
tv138 = -324						; size = 4
tv291 = -321						; size = 1
tv286 = -321						; size = 1
$T2 = -316						; size = 4
$T3 = -304						; size = 4
$T4 = -292						; size = 4
$T5 = -280						; size = 4
$T6 = -268						; size = 4
__Ok$ = -64						; size = 8
__Pad$ = -48						; size = 4
__Size$ = -36						; size = 4
__State$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 494  : 	{	// insert a string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 324				; 00000144H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-340]
	mov	ecx, 81					; 00000051H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 495  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 496  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 497  : 	typedef typename _Mystr::size_type _Mysizt;
; 498  : 
; 499  : 	ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 500  : 	_Mysizt _Size = _Str.size();

	mov	ecx, DWORD PTR __Str$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	DWORD PTR __Size$[ebp], eax

; 501  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
; 502  : 		? 0 : (_Mysizt)_Ostr.width() - _Size;

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv328[ebp], eax
	mov	DWORD PTR tv328[ebp+4], edx
	cmp	DWORD PTR tv328[ebp+4], 0
	jl	SHORT $LN17@operator
	jg	SHORT $LN24@operator
	cmp	DWORD PTR tv328[ebp], 0
	jbe	SHORT $LN17@operator
$LN24@operator:
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, DWORD PTR __Size$[ebp]
	jbe	SHORT $LN17@operator
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	sub	eax, DWORD PTR __Size$[ebp]
	mov	DWORD PTR tv136[ebp], eax
	jmp	SHORT $LN18@operator
$LN17@operator:
	mov	DWORD PTR tv136[ebp], 0
$LN18@operator:
	mov	eax, DWORD PTR tv136[ebp]
	mov	DWORD PTR __Pad$[ebp], eax

; 503  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 504  : 
; 505  : 	if (!_Ok)

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBEPQ?$_Bool_struct@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@2@HXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator int std::_Bool_struct<std::basic_ostream<char,std::char_traits<char> > >::*
	cmp	eax, -1
	jne	SHORT $LN14@operator

; 506  : 		_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 507  : 	else

	jmp	$LN13@operator
$LN14@operator:

; 508  : 		{	// state okay, insert characters
; 509  : 	_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 510  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv138[ebp], eax
	mov	eax, DWORD PTR tv138[ebp]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN11@operator

; 511  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	jmp	SHORT $LN10@operator
$LN9@operator:
	mov	eax, DWORD PTR __Pad$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Pad$[ebp], eax
$LN10@operator:
	cmp	DWORD PTR __Pad$[ebp], 0
	jbe	$LN11@operator

; 512  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 513  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv286[ebp], al
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv287[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR tv286[ebp]
	push	eax
	mov	ecx, DWORD PTR tv287[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv288[ebp], eax
	mov	ecx, DWORD PTR tv288[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T3[ebp], eax
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@operator

; 514  : 					{	// insertion failed, quit
; 515  : 					_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 516  : 					break;

	jmp	SHORT $LN11@operator
$LN7@operator:

; 517  : 					}
; 518  : 
; 519  : 		if (_State == ios_base::goodbit

	jmp	$LN9@operator
$LN11@operator:

; 520  : 			&& _Ostr.rdbuf()->sputn(_Str.c_str(), (streamsize)_Size)
; 521  : 				!= (streamsize)_Size)

	cmp	DWORD PTR __State$[ebp], 0
	jne	$LN6@operator
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv289[ebp], eax
	mov	eax, DWORD PTR __Size$[ebp]
	xor	ecx, ecx
	mov	esi, esp
	push	ecx
	push	eax
	mov	ecx, DWORD PTR __Str$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	ecx, DWORD PTR tv289[ebp]
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv290[ebp], eax
	mov	DWORD PTR tv290[ebp+4], edx
	mov	edx, DWORD PTR __Size$[ebp]
	xor	eax, eax
	mov	DWORD PTR tv410[ebp], edx
	mov	DWORD PTR tv410[ebp+4], eax
	mov	ecx, DWORD PTR tv290[ebp]
	cmp	ecx, DWORD PTR tv410[ebp]
	jne	SHORT $LN25@operator
	mov	edx, DWORD PTR tv290[ebp+4]
	cmp	edx, DWORD PTR tv410[ebp+4]
	je	SHORT $LN6@operator
$LN25@operator:

; 522  : 				_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 523  : 		else

	jmp	$LN5@operator
$LN6@operator:

; 524  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	eax, DWORD PTR __Pad$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Pad$[ebp], eax
$LN4@operator:
	cmp	DWORD PTR __Pad$[ebp], 0
	jbe	$LN5@operator

; 525  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 526  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv291[ebp], al
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv292[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR tv291[ebp]
	push	eax
	mov	ecx, DWORD PTR tv292[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv293[ebp], eax
	mov	ecx, DWORD PTR tv293[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T5[ebp], eax
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@operator

; 527  : 					{	// insertion failed, quit
; 528  : 					_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 529  : 					break;

	jmp	SHORT $LN5@operator
$LN1@operator:

; 530  : 					}

	jmp	$LN3@operator
$LN5@operator:

; 531  : 		_Ostr.width(0);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QAE_J_J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN19@operator
__catch$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0:

; 532  : 		_CATCH_IO_(_Ostr)

	mov	esi, esp
	push	1
	push	4
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, $LN23@operator
	ret	0
$LN19@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN13@operator
$LN23@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN13@operator:

; 533  : 		}
; 534  : 
; 535  : 	_Ostr.setstate(_State);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 536  : 	return (_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T6[ebp]

; 537  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN29@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 340				; 00000154H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@operator:
	DD	1
	DD	$LN28@operator
$LN28@operator:
	DD	-64					; ffffffc0H
	DD	8
	DD	$LN26@operator
$LN26@operator:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-344]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?setColor@Screen@@QAEXE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_color$ = 8						; size = 1
?setColor@Screen@@QAEXE@Z PROC				; Screen::setColor, COMDAT
; _this$ = ecx

; 417  : 	void setColor(unsigned char color){

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 418  : 		this->color = color;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _color$[ebp]
	mov	BYTE PTR [eax+908], cl

; 419  : 		colorChangedFlag = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+909], 1

; 420  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setColor@Screen@@QAEXE@Z ENDP				; Screen::setColor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?render@Screen@@QAEXXZ
_TEXT	SEGMENT
tv251 = -448						; size = 4
tv247 = -448						; size = 4
tv192 = -444						; size = 4
tv188 = -444						; size = 4
$T2 = -436						; size = 12
$T3 = -413						; size = 1
$T4 = -404						; size = 12
$T5 = -384						; size = 8
$T6 = -368						; size = 8
$T7 = -352						; size = 28
_c$8 = -124						; size = 4
_r$9 = -112						; size = 4
_item$10 = -100						; size = 4
_iter$11 = -88						; size = 12
_firstNum$12 = -68					; size = 4
_secondNum$13 = -56					; size = 4
_lColor$14 = -44					; size = 9
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?render@Screen@@QAEXXZ PROC				; Screen::render, COMDAT
; _this$ = ecx

; 366  : 	void render(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?render@Screen@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 436				; 000001b4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-448]
	mov	ecx, 109				; 0000006dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 367  : 		system("cls");

	mov	esi, esp
	push	OFFSET ??_C@_03LCPHGAHP@cls?$AA@
	call	DWORD PTR __imp__system
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 368  : 		if(colorsEnabled){

	movzx	eax, BYTE PTR ?colorsEnabled@@3_NA	; colorsEnabled
	test	eax, eax
	je	$LN10@render

; 369  : 			if(colorChangedFlag){

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+909]
	test	ecx, ecx
	je	$LN10@render

; 370  : 				if(color){

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+908]
	test	ecx, ecx
	je	$LN15@render

; 371  : 					char lColor[] = "Color @@";

	mov	eax, DWORD PTR ??_C@_08OBFFCDMO@Color?5?$EA?$EA?$AA@
	mov	DWORD PTR _lColor$14[ebp], eax
	mov	ecx, DWORD PTR ??_C@_08OBFFCDMO@Color?5?$EA?$EA?$AA@+4
	mov	DWORD PTR _lColor$14[ebp+4], ecx
	mov	dl, BYTE PTR ??_C@_08OBFFCDMO@Color?5?$EA?$EA?$AA@+8
	mov	BYTE PTR _lColor$14[ebp+8], dl

; 372  : 					// split hex number doesn't work correctly
; 373  : 					int secondNum = color%0x10; // maybe need to change it to 0x10 (0xF is like 9 for dec)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+908]
	and	ecx, -2147483633			; 8000000fH
	jns	SHORT $LN29@render
	dec	ecx
	or	ecx, -16				; fffffff0H
	inc	ecx
$LN29@render:
	mov	DWORD PTR _secondNum$13[ebp], ecx

; 374  : 					color/= 0x10;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+908]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+908], al

; 375  : 					int firstNum = color;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+908]
	mov	DWORD PTR _firstNum$12[ebp], ecx

; 376  : 
; 377  : 					if(firstNum <= 9){

	cmp	DWORD PTR _firstNum$12[ebp], 9
	jg	SHORT $LN14@render

; 378  : 						lColor[6] = firstNum+48; // add ASCII offset

	mov	eax, DWORD PTR _firstNum$12[ebp]
	add	eax, 48					; 00000030H
	mov	ecx, 1
	imul	ecx, 6
	mov	BYTE PTR _lColor$14[ebp+ecx], al

; 379  : 					}
; 380  : 					else{

	jmp	SHORT $LN13@render
$LN14@render:

; 381  : 						lColor[6] = firstNum+55; // add ascii offset (A+55 = 65, character code for 'A')

	mov	eax, DWORD PTR _firstNum$12[ebp]
	add	eax, 55					; 00000037H
	mov	ecx, 1
	imul	ecx, 6
	mov	BYTE PTR _lColor$14[ebp+ecx], al
$LN13@render:

; 382  : 					}
; 383  : 
; 384  : 					if(secondNum <= 9){

	cmp	DWORD PTR _secondNum$13[ebp], 9
	jg	SHORT $LN12@render

; 385  : 						lColor[7] = secondNum+48; // add ASCII offset

	mov	eax, DWORD PTR _secondNum$13[ebp]
	add	eax, 48					; 00000030H
	mov	ecx, 1
	imul	ecx, 7
	mov	BYTE PTR _lColor$14[ebp+ecx], al

; 386  : 					}
; 387  : 					else{

	jmp	SHORT $LN11@render
$LN12@render:

; 388  : 						lColor[7] = secondNum+55; // add ascii odffset (A+55 = 65, character code for 'A')

	mov	eax, DWORD PTR _secondNum$13[ebp]
	add	eax, 55					; 00000037H
	mov	ecx, 1
	imul	ecx, 7
	mov	BYTE PTR _lColor$14[ebp+ecx], al
$LN11@render:

; 389  : 					}
; 390  : 				
; 391  : 					system(lColor);

	mov	esi, esp
	lea	eax, DWORD PTR _lColor$14[ebp]
	push	eax
	call	DWORD PTR __imp__system
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 392  : 					color = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+908], 0

; 393  : 				}
; 394  : 				else{

	jmp	SHORT $LN10@render
$LN15@render:

; 395  : 					system("Color 07"); // bit 0, 1, 2

	mov	esi, esp
	push	OFFSET ??_C@_08NFNKKEKP@Color?507?$AA@
	call	DWORD PTR __imp__system
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 396  : 					colorChangedFlag = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+909], 0
$LN10@render:

; 397  : 				}
; 398  : 			}
; 399  : 		}
; 400  : 
; 401  : 		memset(&screen[0][0], this->blank, sizeof(screen)); // reset screen

	push	900					; 00000384H
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+900]
	push	ecx
	mov	edx, 45					; 0000002dH
	imul	edx, 0
	add	edx, DWORD PTR _this$[ebp]
	mov	eax, 1
	imul	eax, 0
	add	edx, eax
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 402  : 		cout << mainPlayer->getName() << ":  Ammo:  " << mainPlayer->ammo << " Health: " << mainPlayer->health << endl; // playerinfo

	mov	esi, esp
	mov	eax, DWORD PTR __imp_?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+904]
	mov	edi, esp
	push	ecx
	movss	xmm0, DWORD PTR [edx+16]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_09LCCGMOOO@?5Health?3?5?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+904]
	mov	ebx, esp
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	push	OFFSET ??_C@_0L@BBALFDB@?3?5?5Ammo?3?5?5?$AA@
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+904]
	call	?getName@Player@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Player::getName
	mov	DWORD PTR tv192[ebp], eax
	mov	edx, DWORD PTR tv192[ebp]
	mov	DWORD PTR tv247[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR tv247[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	cmp	ebx, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T7[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 403  : 		Bullet::renderBullets();

	call	?renderBullets@Bullet@@SAXXZ		; Bullet::renderBullets

; 404  : 		for(vector<OnScreen*>::iterator iter = OnScreen::visibleItems.begin(); iter != OnScreen::visibleItems.end(); iter++){

	lea	eax, DWORD PTR _iter$11[ebp]
	push	eax
	mov	ecx, OFFSET ?visibleItems@OnScreen@@2V?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@A ; OnScreen::visibleItems
	call	?begin@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@XZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::begin
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	jmp	SHORT $LN9@render
$LN8@render:
	push	0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _iter$11[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator++
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ
$LN9@render:
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, OFFSET ?visibleItems@OnScreen@@2V?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@A ; OnScreen::visibleItems
	call	?end@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@XZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::end
	mov	DWORD PTR tv188[ebp], eax
	mov	ecx, DWORD PTR tv188[ebp]
	mov	DWORD PTR tv251[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR tv251[ebp]
	push	edx
	lea	ecx, DWORD PTR _iter$11[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator!=
	mov	BYTE PTR $T3[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T3[ebp]
	test	eax, eax
	je	SHORT $LN7@render

; 405  : 			OnScreen *item = *iter;

	lea	ecx, DWORD PTR _iter$11[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBEAAPAVOnScreen@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator*
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _item$10[ebp], eax

; 406  : 			screen[item->getLocation().y][item->getLocation().x] = item->toChar();

	mov	eax, DWORD PTR _item$10[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _item$10[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	bl, al
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	mov	ecx, DWORD PTR _item$10[ebp]
	call	?getLocation@OnScreen@@QAE?AVPoint@@XZ	; OnScreen::getLocation
	mov	esi, DWORD PTR [eax+4]
	imul	esi, 45					; 0000002dH
	add	esi, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	mov	ecx, DWORD PTR _item$10[ebp]
	call	?getLocation@OnScreen@@QAE?AVPoint@@XZ	; OnScreen::getLocation
	mov	eax, DWORD PTR [eax]
	mov	BYTE PTR [esi+eax], bl
	jmp	$LN8@render
$LN7@render:

; 407  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _iter$11[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ

; 408  : 
; 409  : 		for(int r = 0; r < NUM_OF_ROWS; r++){ // render screen

	mov	DWORD PTR _r$9[ebp], 0
	jmp	SHORT $LN6@render
$LN5@render:
	mov	eax, DWORD PTR _r$9[ebp]
	add	eax, 1
	mov	DWORD PTR _r$9[ebp], eax
$LN6@render:
	cmp	DWORD PTR _r$9[ebp], 20			; 00000014H
	jge	SHORT $LN4@render

; 410  : 			for(int c = 0; c < NUM_OF_COLS; c++){

	mov	DWORD PTR _c$8[ebp], 0
	jmp	SHORT $LN3@render
$LN2@render:
	mov	eax, DWORD PTR _c$8[ebp]
	add	eax, 1
	mov	DWORD PTR _c$8[ebp], eax
$LN3@render:
	cmp	DWORD PTR _c$8[ebp], 45			; 0000002dH
	jge	SHORT $LN1@render

; 411  : 				cout << this->screen[r][c];

	mov	eax, DWORD PTR _r$9[ebp]
	imul	eax, 45					; 0000002dH
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _c$8[ebp]
	movzx	edx, BYTE PTR [eax+ecx]
	push	edx
	mov	eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 412  : 			}

	jmp	SHORT $LN2@render
$LN1@render:

; 413  : 			cout << "\n";

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 414  : 		}	

	jmp	SHORT $LN5@render
$LN4@render:

; 415  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN28@render
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 448				; 000001c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@render:
	DD	2
	DD	$LN27@render
$LN27@render:
	DD	-44					; ffffffd4H
	DD	9
	DD	$LN24@render
	DD	-88					; ffffffa8H
	DD	12					; 0000000cH
	DD	$LN25@render
$LN25@render:
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN24@render:
	DB	108					; 0000006cH
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?render@Screen@@QAEXXZ$0:
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?render@Screen@@QAEXXZ$1:
	lea	ecx, DWORD PTR _iter$11[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?render@Screen@@QAEXXZ$3:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?render@Screen@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-452]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?render@Screen@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?render@Screen@@QAEXXZ ENDP				; Screen::render
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?stuffAt@Screen@@QAE_NHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_r$ = 8							; size = 4
_c$ = 12						; size = 4
?stuffAt@Screen@@QAE_NHH@Z PROC				; Screen::stuffAt, COMDAT
; _this$ = ecx

; 360  : 	bool stuffAt(int r, int c){

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 361  : 		if(screen[r][c] == '-'){ 

	mov	eax, DWORD PTR _r$[ebp]
	imul	eax, 45					; 0000002dH
	add	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	movsx	edx, BYTE PTR [eax+ecx]
	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN1@stuffAt

; 362  : 			return false;

	xor	al, al
	jmp	SHORT $LN2@stuffAt
$LN1@stuffAt:

; 363  : 		}
; 364  : 		return true;

	mov	al, 1
$LN2@stuffAt:

; 365  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?stuffAt@Screen@@QAE_NHH@Z ENDP				; Screen::stuffAt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ??0Screen@@QAE@DPAVPlayer@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_initial$ = 8						; size = 1
_mainPlayer$ = 12					; size = 4
??0Screen@@QAE@DPAVPlayer@@@Z PROC			; Screen::Screen, COMDAT
; _this$ = ecx

; 353  : 	Screen(char initial, Player *mainPlayer){

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 354  : 		this->color = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+908], 0

; 355  : 		this->colorChangedFlag = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+909], 0

; 356  : 		this->blank = initial;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _initial$[ebp]
	mov	BYTE PTR [eax+900], cl

; 357  : 		this->mainPlayer = mainPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _mainPlayer$[ebp]
	mov	DWORD PTR [eax+904], ecx

; 358  : 		memset(&screen[0][0], initial, sizeof(screen)); // in lieu of double for

	push	900					; 00000384H
	movsx	eax, BYTE PTR _initial$[ebp]
	push	eax
	mov	ecx, 45					; 0000002dH
	imul	ecx, 0
	add	ecx, DWORD PTR _this$[ebp]
	mov	edx, 1
	imul	edx, 0
	add	ecx, edx
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 359  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0Screen@@QAE@DPAVPlayer@@@Z ENDP			; Screen::Screen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GEnemySoldier@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GEnemySoldier@@UAEPAXI@Z PROC			; EnemySoldier::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1EnemySoldier@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GEnemySoldier@@UAEPAXI@Z ENDP			; EnemySoldier::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1EnemySoldier@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1EnemySoldier@@UAE@XZ PROC				; EnemySoldier::~EnemySoldier, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Enemy@@UAE@XZ			; Enemy::~Enemy
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1EnemySoldier@@UAE@XZ ENDP				; EnemySoldier::~EnemySoldier
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?toChar@EnemySoldier@@MAEDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?toChar@EnemySoldier@@MAEDXZ PROC			; EnemySoldier::toChar, COMDAT
; _this$ = ecx

; 345  : 	virtual char toChar(){

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 346  : 		return 'E';

	mov	al, 69					; 00000045H

; 347  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?toChar@EnemySoldier@@MAEDXZ ENDP			; EnemySoldier::toChar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?processAndAct@EnemySoldier@@UAEXPAVLivingEntity@@@Z
_TEXT	SEGMENT
$T1 = -228						; size = 8
_targetLocation$ = -20					; size = 4
_this$ = -8						; size = 4
_target$ = 8						; size = 4
?processAndAct@EnemySoldier@@UAEXPAVLivingEntity@@@Z PROC ; EnemySoldier::processAndAct, COMDAT
; _this$ = ecx

; 309  : 	void processAndAct(LivingEntity *target){

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 310  : 		Point* targetLocation = &target->getLocation();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _target$[ebp]
	call	?getLocation@OnScreen@@QAE?AVPoint@@XZ	; OnScreen::getLocation
	mov	DWORD PTR _targetLocation$[ebp], eax

; 311  : 		if(targetLocation->x != this->location.x){

	mov	eax, DWORD PTR _targetLocation$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+4]
	je	$LN14@processAnd

; 312  : 			if(targetLocation->y > this->location.y){ // move

	mov	eax, DWORD PTR _targetLocation$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jle	SHORT $LN13@processAnd

; 313  : 				this->move(Directions::DOWN, this->speed);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	push	-2					; fffffffeH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN12@processAnd
$LN13@processAnd:

; 314  : 			}
; 315  : 			else if(targetLocation->y < this->location.y){ // move

	mov	eax, DWORD PTR _targetLocation$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jge	SHORT $LN11@processAnd

; 316  : 				this->move(Directions::UP, this->speed);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN12@processAnd
$LN11@processAnd:

; 317  : 			}
; 318  : 			else if(ammo == 0){ // no ammo

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN9@processAnd

; 319  : 				ammo = magSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+24], edx

; 320  : 			}
; 321  : 			else{ // turn and shoot

	jmp	SHORT $LN12@processAnd
$LN9@processAnd:

; 322  : 				if(targetLocation->x > this->location.x){

	mov	eax, DWORD PTR _targetLocation$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN7@processAnd

; 323  : 					this->facing = Directions::RIGHT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 1

; 324  : 				}
; 325  : 				else{

	jmp	SHORT $LN6@processAnd
$LN7@processAnd:

; 326  : 					this->facing = Directions::LEFT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], -1
$LN6@processAnd:

; 327  : 				}
; 328  : 				this->shoot(this->facing);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@processAnd:

; 329  : 			}

	jmp	SHORT $LN15@processAnd
$LN14@processAnd:

; 330  : 		}
; 331  : 		else if(ammo == 0){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN4@processAnd

; 332  : 			ammo = magSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+24], edx

; 333  : 		}
; 334  : 		else{ // turn and shoot

	jmp	SHORT $LN15@processAnd
$LN4@processAnd:

; 335  : 			if(targetLocation->y > this->location.y){

	mov	eax, DWORD PTR _targetLocation$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jle	SHORT $LN2@processAnd

; 336  : 				this->facing = Directions::DOWN;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], -2			; fffffffeH

; 337  : 			}
; 338  : 			else{

	jmp	SHORT $LN1@processAnd
$LN2@processAnd:

; 339  : 				this->facing = Directions::UP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 2
$LN1@processAnd:

; 340  : 			}
; 341  : 			this->shoot(this->facing);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@processAnd:

; 342  : 		}
; 343  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?processAndAct@EnemySoldier@@UAEXPAVLivingEntity@@@Z ENDP ; EnemySoldier::processAndAct
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?shoot@EnemySoldier@@UAEXW4Directions@@@Z
_TEXT	SEGMENT
tv93 = -256						; size = 4
$T2 = -248						; size = 4
$T3 = -236						; size = 4
_shot$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_dir$ = 8						; size = 4
?shoot@EnemySoldier@@UAEXW4Directions@@@Z PROC		; EnemySoldier::shoot, COMDAT
; _this$ = ecx

; 305  : 	void shoot(Directions dir){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?shoot@EnemySoldier@@UAEXW4Directions@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 306  : 		Bullet *shot = new Bullet(1, facing, this->location.x, this->location.y);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@shoot
	push	10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0Bullet@@QAE@HW4Directions@@HHH@Z	; Bullet::Bullet
	mov	DWORD PTR tv93[ebp], eax
	jmp	SHORT $LN4@shoot
$LN3@shoot:
	mov	DWORD PTR tv93[ebp], 0
$LN4@shoot:
	mov	eax, DWORD PTR tv93[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _shot$[ebp], ecx

; 307  : 		ammo--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 308  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?shoot@EnemySoldier@@UAEXW4Directions@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?shoot@EnemySoldier@@UAEXW4Directions@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?shoot@EnemySoldier@@UAEXW4Directions@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?shoot@EnemySoldier@@UAEXW4Directions@@@Z ENDP		; EnemySoldier::shoot
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ??0EnemySoldier@@QAE@HHMHHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_row$ = 8						; size = 4
_col$ = 12						; size = 4
_health$ = 16						; size = 4
_ammo$ = 20						; size = 4
_magsize$ = 24						; size = 4
_speed$ = 28						; size = 4
??0EnemySoldier@@QAE@HHMHHH@Z PROC			; EnemySoldier::EnemySoldier, COMDAT
; _this$ = ecx

; 297  : 	EnemySoldier(int row, int col, float health = 100.0, int ammo = 1, int magsize = 1, int speed = 1){

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Enemy@@QAE@XZ			; Enemy::Enemy
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7EnemySoldier@@6B@

; 298  : 		this->location.x = col;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 299  : 		this->location.y = row;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _row$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 300  : 		this->health = health;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _health$[ebp]
	movss	DWORD PTR [eax+16], xmm0

; 301  : 		this->ammo = ammo;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ammo$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 302  : 		this->speed = speed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _speed$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 303  : 		this->magSize = magSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx

; 304  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??0EnemySoldier@@QAE@HHMHHH@Z ENDP			; EnemySoldier::EnemySoldier
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?enemies@Enemy@@1V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@A@@YAXXZ
text$yd	SEGMENT
??__F?enemies@Enemy@@1V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'Enemy::enemies'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?enemies@Enemy@@1V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@A ; Enemy::enemies
	call	??1?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@XZ ; std::vector<Enemy *,std::allocator<Enemy *> >::~vector<Enemy *,std::allocator<Enemy *> >
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__F?enemies@Enemy@@1V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'Enemy::enemies''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ??__E?enemies@Enemy@@1V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@A@@YAXXZ
text$yc	SEGMENT
??__E?enemies@Enemy@@1V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@A@@YAXXZ PROC ; `dynamic initializer for 'Enemy::enemies'', COMDAT

; 293  : vector<Enemy*> Enemy::enemies;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?enemies@Enemy@@1V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@A ; Enemy::enemies
	call	??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@XZ ; std::vector<Enemy *,std::allocator<Enemy *> >::vector<Enemy *,std::allocator<Enemy *> >
	push	OFFSET ??__F?enemies@Enemy@@1V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@A@@YAXXZ ; `dynamic atexit destructor for 'Enemy::enemies''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?enemies@Enemy@@1V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@A@@YAXXZ ENDP ; `dynamic initializer for 'Enemy::enemies''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
$T2 = -244						; size = 4
__Tmp$ = -40						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator++, COMDAT
; _this$ = ecx

; 339  : 		{	// postincrement

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE?AV01@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0

; 340  : 		_Myiter _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 341  : 		++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator++

; 342  : 		return (_Tmp);

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 343  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN9@operator:
	DD	1
	DD	$LN8@operator
$LN8@operator:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN6@operator
$LN6@operator:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE?AV01@H@Z$0:
	lea	ecx, DWORD PTR __Tmp$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE?AV01@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE?AV01@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator++
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator++, COMDAT
; _this$ = ecx

; 333  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 334  : 		++*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator++

; 335  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 336  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBEAAPAVEnemy@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBEAAPAVEnemy@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator*, COMDAT
; _this$ = ecx

; 323  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 324  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBEABQAVEnemy@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator*

; 325  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBEAAPAVEnemy@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@PAPAVEnemy@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@PAPAVEnemy@@PBU_Container_base12@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@PAPAVEnemy@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >

; 307  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@PAPAVEnemy@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEnemy@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEnemy@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::_Compat, COMDAT
; _this$ = ecx

; 236  : 		{	// test for compatible iterator pair

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 237  : 		if (this->_Getcont() == 0
; 238  : 			|| this->_Getcont() != _Right._Getcont())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	test	eax, eax
	je	SHORT $LN1@Compat
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	cmp	esi, eax
	je	$LN3@Compat
$LN1@Compat:

; 239  : 			{	// report error
; 240  : 			_DEBUG_ERROR("vector iterators incompatible");

	mov	esi, esp
	push	240					; 000000f0H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 241  : 			_SCL_SECURE_INVALID_ARGUMENT;

	mov	eax, OFFSET ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
	test	eax, eax
	je	SHORT $LN5@Compat
	xor	ecx, ecx
	jne	SHORT $LN6@Compat
$LN5@Compat:
	mov	esi, esp
	push	OFFSET ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	241					; 000000f1H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@Compat
	int	3
$LN6@Compat:
	mov	esi, esp
	push	0
	push	241					; 000000f1H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1NC@HPHJKDBI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Compat:

; 242  : 			}
; 243  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator<, COMDAT
; _this$ = ecx

; 214  : 		{	// test if this < _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 215  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::_Compat

; 216  : 		return (this->_Ptr < _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 217  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator<
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator!=, COMDAT
; _this$ = ecx

; 209  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 210  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 211  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::_Compat

; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 206  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator++, COMDAT
; _this$ = ecx

; 95   : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	test	eax, eax
	je	SHORT $LN1@operator
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN1@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@operator
$LN1@operator:

; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");

	mov	esi, esp
	push	101					; 00000065H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 102  : 			_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	102					; 00000066H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	102					; 00000066H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1NK@FOJADKHE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 113  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 114  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBEABQAVEnemy@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBEABQAVEnemy@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator*, COMDAT
; _this$ = ecx

; 65   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	test	eax, eax
	je	SHORT $LN1@operator
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN1@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@operator
$LN1@operator:

; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");

	mov	esi, esp
	push	72					; 00000048H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 73   : 			_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	73					; 00000049H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	73					; 00000049H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1NI@JDFLGOO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 87   : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBEABQAVEnemy@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@PAPAVEnemy@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@PAPAVEnemy@@PBU_Container_base12@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@PAPAVEnemy@@PBU_Container_base12@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEnemy@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 48   : 		this->_Adopt(_Pvector);

	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 49   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@PAPAVEnemy@@PBU_Container_base12@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEnemy@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@PAPAVEnemy@@PBU_Container_base12@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@PAPAVEnemy@@PBU_Container_base12@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@PAPAVEnemy@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEnemy@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEnemy@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z PROC ; std::_Iterator012<std::random_access_iterator_tag,Enemy *,int,Enemy * const *,Enemy * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Enemy *,int,Enemy * const *,Enemy * const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@ABU01@@Z	; std::_Iterator_base12::_Iterator_base12
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEnemy@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ENDP ; std::_Iterator012<std::random_access_iterator_tag,Enemy *,int,Enemy * const *,Enemy * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Enemy *,int,Enemy * const *,Enemy * const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEnemy@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEnemy@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,Enemy *,int,Enemy * const *,Enemy * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,Enemy *,int,Enemy * const *,Enemy * const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::~_Iterator_base12
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEnemy@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,Enemy *,int,Enemy * const *,Enemy * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,Enemy *,int,Enemy * const *,Enemy * const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEnemy@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEnemy@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,Enemy *,int,Enemy * const *,Enemy * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Enemy *,int,Enemy * const *,Enemy * const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::_Iterator_base12
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVEnemy@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,Enemy *,int,Enemy * const *,Enemy * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Enemy *,int,Enemy * const *,Enemy * const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GEnemy@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GEnemy@@UAEPAXI@Z PROC				; Enemy::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Enemy@@UAE@XZ			; Enemy::~Enemy
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GEnemy@@UAEPAXI@Z ENDP				; Enemy::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEXPAPAVEnemy@@0@Z
_TEXT	SEGMENT
__Pnext$ = -44						; size = 4
__Lock$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEXPAPAVEnemy@@0@Z PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1677 : 		{	// orphan iterators within specified (inclusive) range

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Orphan_range@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEXPAPAVEnemy@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1678 : 		_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1679 : 		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Pnext$[ebp], eax

; 1680 : 		if (_Pnext != 0)

	cmp	DWORD PTR __Pnext$[ebp], 0
	je	SHORT $LN6@Orphan_ran
$LN5@Orphan_ran:

; 1681 : 			while (*_Pnext != 0)

	mov	eax, DWORD PTR __Pnext$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@Orphan_ran

; 1682 : 				if ((*_Pnext)->_Ptr < _First || _Last < (*_Pnext)->_Ptr)

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR __First$[ebp]
	jb	SHORT $LN2@Orphan_ran
	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Last$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN3@Orphan_ran
$LN2@Orphan_ran:

; 1683 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
	mov	DWORD PTR __Pnext$[ebp], eax

; 1684 : 				else

	jmp	SHORT $LN1@Orphan_ran
$LN3@Orphan_ran:

; 1685 : 					{	// orphan the iterator
; 1686 : 					(*_Pnext)->_Clrcont();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Clrcont@_Iterator_base12@std@@QAEXXZ	; std::_Iterator_base12::_Clrcont

; 1687 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
	mov	ecx, DWORD PTR __Pnext$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
$LN1@Orphan_ran:

; 1688 : 					}

	jmp	SHORT $LN5@Orphan_ran
$LN6@Orphan_ran:

; 1689 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@Orphan_ran
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN13@Orphan_ran:
	DD	1
	DD	$LN12@Orphan_ran
$LN12@Orphan_ran:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN10@Orphan_ran
$LN10@Orphan_ran:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_range@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEXPAPAVEnemy@@0@Z$0:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$?_Orphan_range@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEXPAPAVEnemy@@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Orphan_range@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEXPAPAVEnemy@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Orphan_range@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEXPAPAVEnemy@@0@Z ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::_Orphan_range
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xlen@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEXXZ PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::_Xlen, COMDAT
; _this$ = ecx

; 1666 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1667 : 		_Xlength_error("vector<T> too long");

	mov	esi, esp
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Xlen:

; 1668 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEXXZ ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
?_Tidy@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXXZ PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::_Tidy, COMDAT
; _this$ = ecx

; 1535 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1536 : 		if (this->_Myfirst != pointer())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN2@Tidy

; 1537 : 			{	// something to free, destroy and deallocate it
; 1538 : 			this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1539 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXPAPAVEnemy@@0@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Destroy

; 1540 : 			this->_Getal().deallocate(this->_Myfirst,
; 1541 : 				this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEXPAPAVEnemy@@I@Z ; std::_Wrap_alloc<std::allocator<Enemy *> >::deallocate

; 1542 : 			this->_Myfirst = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1543 : 			this->_Mylast = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 1544 : 			this->_Myend = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
$LN2@Tidy:

; 1545 : 			}
; 1546 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXXZ ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::_Reserve, COMDAT
; _this$ = ecx

; 1525 : 		{	// ensure room for _Count new elements, grow exponentially

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1526 : 		if (_Unused_capacity() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Unused_capacity@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ; std::vector<Enemy *,std::allocator<Enemy *> >::_Unused_capacity
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN4@Reserve

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ; std::vector<Enemy *,std::allocator<Enemy *> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ; std::vector<Enemy *,std::allocator<Enemy *> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Reserve

; 1529 : 				_Xlen();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEXXZ ; std::vector<Enemy *,std::allocator<Enemy *> >::_Xlen
$LN1@Reserve:

; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ; std::vector<Enemy *,std::allocator<Enemy *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow_to@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEII@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Grow_to
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reallocate@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Reallocate
$LN4@Reserve:

; 1531 : 			}
; 1532 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Reserve@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T2 = -273						; size = 1
$T3 = -261						; size = 1
$T4 = -249						; size = 1
__Size$ = -48						; size = 4
__Ptr$ = -36						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1500 : 		{	// move to array of exactly _Count elements

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEPAPAVEnemy@@I@Z ; std::_Wrap_alloc<std::allocator<Enemy *> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 1502 : 
; 1503 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVEnemy@@@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEPAPAVEnemy@@PAPAV2@00@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Umove<Enemy * *>
	jmp	SHORT $LN5@Reallocate
__catch$?_Reallocate@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z$0:

; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEXPAPAVEnemy@@I@Z ; std::_Wrap_alloc<std::allocator<Enemy *> >::deallocate

; 1507 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1508 : 		_CATCH_END

	mov	eax, $LN8@Reallocate
	ret	0
$LN5@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Reallocate@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z$1
$LN8@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z$1:

; 1509 : 
; 1510 : 		size_type _Size = size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ; std::vector<Enemy *,std::allocator<Enemy *> >::size
	mov	DWORD PTR __Size$[ebp], eax

; 1511 : 		if (this->_Myfirst != pointer())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Reallocate

; 1512 : 			{	// destroy and deallocate old array
; 1513 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXPAPAVEnemy@@0@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Destroy

; 1514 : 			this->_Getal().deallocate(this->_Myfirst,
; 1515 : 				this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEXPAPAVEnemy@@I@Z ; std::_Wrap_alloc<std::allocator<Enemy *> >::deallocate
$LN1@Reallocate:

; 1516 : 			}
; 1517 : 
; 1518 : 		this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1519 : 		this->_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1520 : 		this->_Mylast = _Ptr + _Size;

	mov	eax, DWORD PTR __Size$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1521 : 		this->_Myfirst = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN4@Reallocate:

; 1522 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 280				; 00000118H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-284]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::_Reallocate
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBE_NPBQAVEnemy@@@Z
_TEXT	SEGMENT
tv76 = -208						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBE_NPBQAVEnemy@@@Z PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::_Inside, COMDAT
; _this$ = ecx

; 1495 : 		{	// test if _Ptr points inside vector

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN3@Inside
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN4@Inside
$LN3@Inside:
	mov	DWORD PTR tv76[ebp], 0
$LN4@Inside:
	mov	al, BYTE PTR tv76[ebp]

; 1497 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBE_NPBQAVEnemy@@@Z ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -220						; size = 4
__Capacity$ = -20					; size = 4
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEII@Z PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1484 : 		{	// grow by 50% or at least to _Count

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1485 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ; std::vector<Enemy *,std::allocator<Enemy *> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ; std::vector<Enemy *,std::allocator<Enemy *> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN4@Grow_to
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN5@Grow_to
$LN4@Grow_to:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1489 : 		if (_Capacity < _Count)

	mov	eax, DWORD PTR __Capacity$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Grow_to

; 1490 : 			_Capacity = _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to:

; 1491 : 		return (_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]

; 1492 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Grow_to@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEII@Z ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXPAPAVEnemy@@0@Z
_TEXT	SEGMENT
__Alval$ = -17						; size = 1
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXPAPAVEnemy@@0@Z PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::_Destroy, COMDAT
; _this$ = ecx

; 1478 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1479 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Getal

; 1480 : 		_Destroy_range(_First, _Last, _Alval);

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@@std@@YAXPAPAVEnemy@@0AAU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Enemy *> > >
	add	esp, 12					; 0000000cH

; 1481 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Destroy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN5@Destroy:
	DD	1
	DD	$LN4@Destroy
$LN4@Destroy:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Destroy
$LN3@Destroy:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
?_Destroy@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXPAPAVEnemy@@0@Z ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::_Buy, COMDAT
; _this$ = ecx

; 1459 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1460 : 		this->_Myfirst = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1461 : 		this->_Mylast = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 1462 : 		this->_Myend = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 1463 : 
; 1464 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1465 : 			return (false);

	xor	al, al
	jmp	SHORT $LN6@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1466 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ; std::vector<Enemy *,std::allocator<Enemy *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy

; 1467 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEXXZ ; std::vector<Enemy *,std::allocator<Enemy *> >::_Xlen

; 1468 : 		else

	jmp	SHORT $LN3@Buy
$LN2@Buy:

; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEPAPAVEnemy@@I@Z ; std::_Wrap_alloc<std::allocator<Enemy *> >::allocate
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1471 : 			this->_Mylast = this->_Myfirst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx

; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Capacity$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax
$LN3@Buy:

; 1473 : 			}
; 1474 : 		return (true);

	mov	al, 1
$LN6@Buy:

; 1475 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::_Buy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?erase@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv182 = -248						; size = 4
tv181 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
?erase@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::erase, COMDAT
; _this$ = ecx

; 1356 : 		{	// erase element at where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T3[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $LN1@erase
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+8]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@erase
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR __Where$[ebp+8]
	ja	SHORT $LN2@erase
$LN1@erase:

; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");

	mov	esi, esp
	push	1360					; 00000550H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@erase:

; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));

	mov	eax, DWORD PTR __Where$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+8]
	add	eax, 4
	push	eax
	call	??$_Move@PAPAVEnemy@@PAPAV1@@std@@YAPAPAVEnemy@@PAPAV1@00@Z ; std::_Move<Enemy * *,Enemy * *>
	add	esp, 12					; 0000000cH

; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXPAPAVEnemy@@0@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Destroy

; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEXPAPAVEnemy@@0@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Orphan_range

; 1364 : 		--this->_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1365 : 		return (_Make_iter(_Where));

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	lea	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv181[ebp], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Make_iter
	mov	DWORD PTR tv182[ebp], eax
	mov	edx, DWORD PTR $T3[ebp]
	or	edx, 1
	mov	DWORD PTR $T3[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1366 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z$0:
	lea	ecx, DWORD PTR __Where$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?erase@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::erase
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAEXABQAVEnemy@@@Z
_TEXT	SEGMENT
$T1 = -233						; size = 1
$T2 = -221						; size = 1
__Idx$3 = -20						; size = 4
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAEXABQAVEnemy@@@Z PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::push_back, COMDAT
; _this$ = ecx

; 1184 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1185 : 		if (_Inside(_STD addressof(_Val)))

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@QAVEnemy@@@std@@YAPBQAVEnemy@@ABQAV1@@Z ; std::addressof<Enemy * const>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBE_NPBQAVEnemy@@@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@push_back

; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@QAVEnemy@@@std@@YAPBQAVEnemy@@ABQAV1@@Z ; std::addressof<Enemy * const>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2
	mov	DWORD PTR __Idx$3[ebp], eax

; 1188 : 			if (this->_Mylast == this->_Myend)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN3@push_back

; 1189 : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Reserve
$LN3@push_back:

; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEXPAPAVEnemy@@0@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Orphan_range

; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Idx$3[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Getal
	mov	ecx, eax
	call	??$construct@PAVEnemy@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEXPAPAVEnemy@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<Enemy *> >::construct<Enemy *,Enemy * &>

; 1193 : 			++this->_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1194 : 			}
; 1195 : 		else

	jmp	SHORT $LN5@push_back
$LN4@push_back:

; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN1@push_back

; 1198 : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXI@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Reserve
$LN1@push_back:

; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IBEXPAPAVEnemy@@0@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Orphan_range

; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Getal
	mov	ecx, eax
	call	??$construct@PAVEnemy@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEXPAPAVEnemy@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<Enemy *> >::construct<Enemy *,Enemy * const &>

; 1202 : 			++this->_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN5@push_back:

; 1203 : 			}
; 1204 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAEXABQAVEnemy@@@Z ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??A?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAEAAPAVEnemy@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAEAAPAVEnemy@@I@Z PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::operator[], COMDAT
; _this$ = ecx

; 1136 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ; std::vector<Enemy *,std::allocator<Enemy *> >::size
	cmp	eax, DWORD PTR __Pos$[ebp]
	ja	$LN1@operator

; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");

	mov	esi, esp
	push	1140					; 00000474H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN4@operator
	xor	ecx, ecx
	jne	SHORT $LN5@operator
$LN4@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	1141					; 00000475H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@operator
	int	3
$LN5@operator:
	mov	esi, esp
	push	0
	push	1141					; 00000475H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1JK@MCCMGKDA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAE?$AAn?$AAe?$AAm?$AAy?$AA?5?$AA?$CK?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@operator:

; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 1149 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAEAAPAVEnemy@@I@Z ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
?max_size@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::max_size, COMDAT
; _this$ = ecx

; 1091 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1092 : 		return (this->_Getal().max_size());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<Enemy *> >::max_size

; 1093 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::size, COMDAT
; _this$ = ecx

; 1086 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1087 : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 1088 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
$T2 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
?_Make_iter@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::_Make_iter, COMDAT
; _this$ = ecx

; 1001 : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Make_iter@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1002 : 		return (iterator(_Where._Ptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+8]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@PAPAVEnemy@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 1
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1003 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Make_iter@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z$0:
	lea	ecx, DWORD PTR __Where$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?_Make_iter@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Make_iter@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Make_iter@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::_Make_iter
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?end@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@XZ PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::end, COMDAT
; _this$ = ecx

; 996  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 997  : 		return (const_iterator(this->_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@PAPAVEnemy@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@XZ ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?end@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@XZ PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::end, COMDAT
; _this$ = ecx

; 991  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 992  : 		return (iterator(this->_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@PAPAVEnemy@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 993  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@XZ ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@XZ PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::begin, COMDAT
; _this$ = ecx

; 986  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 987  : 		return (const_iterator(this->_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@PAPAVEnemy@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 988  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@XZ ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@XZ PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::begin, COMDAT
; _this$ = ecx

; 981  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 982  : 		return (iterator(this->_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@PAPAVEnemy@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 983  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@XZ ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Unused_capacity@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 971  : 		{	// micro-optimization for capacity() - size()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 972  : 		return (this->_Myend - this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+8]
	sar	eax, 2

; 973  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Unused_capacity@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?capacity@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::capacity, COMDAT
; _this$ = ecx

; 966  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 967  : 		return (this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 968  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??1?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@XZ PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::~vector<Enemy *,std::allocator<Enemy *> >, COMDAT
; _this$ = ecx

; 899  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 900  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXXZ ; std::vector<Enemy *,std::allocator<Enemy *> >::_Tidy

; 901  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::~_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@XZ ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::~vector<Enemy *,std::allocator<Enemy *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Assign_rv@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Assign_rv@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAEX$$QAV12@@Z PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::_Assign_rv, COMDAT
; _this$ = ecx

; 824  : 		{	// assign by moving _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 825  : 		this->_Swap_all((_Myt&)_Right);

	mov	esi, esp
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 826  : 		this->_Myfirst = _Right._Myfirst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 827  : 		this->_Mylast = _Right._Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 828  : 		this->_Myend = _Right._Myend;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 829  : 
; 830  : 		_Right._Myfirst = pointer();

	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR [eax+4], 0

; 831  : 		_Right._Mylast = pointer();

	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR [eax+8], 0

; 832  : 		_Right._Myend = pointer();

	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR [eax+12], 0

; 833  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Assign_rv@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAEX$$QAV12@@Z ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::vector<Enemy *,std::allocator<Enemy *> >, COMDAT
; _this$ = ecx

; 788  : 		{	// construct by moving _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@$$QAV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Getal
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEnemy@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 789  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$forward@V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@YA$$QAV?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@0@AAV10@@Z ; std::forward<std::vector<Enemy *,std::allocator<Enemy *> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Assign_rv@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAEX$$QAV12@@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Assign_rv

; 790  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@$$QAV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::~_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >
__ehhandler$??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@$$QAV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@$$QAV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::vector<Enemy *,std::allocator<Enemy *> >
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv135 = -280						; size = 4
tv178 = -276						; size = 4
tv175 = -272						; size = 4
$T2 = -261						; size = 1
$T3 = -249						; size = 1
$T4 = -240						; size = 4
$T5 = -228						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::vector<Enemy *,std::allocator<Enemy *> >, COMDAT
; _this$ = ecx

; 720  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Getal
	mov	ecx, eax
	call	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<Enemy *> >::select_on_container_copy_construction
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEnemy@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 721  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ; std::vector<Enemy *,std::allocator<Enemy *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAE_NI@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	$LN3@vector

; 722  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 723  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 724  : 				this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T4[ebp], esp
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@XZ ; std::vector<Enemy *,std::allocator<Enemy *> >::end
	mov	DWORD PTR tv175[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T5[ebp], esp
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@XZ ; std::vector<Enemy *,std::allocator<Enemy *> >::begin
	mov	DWORD PTR tv178[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEPAPAVEnemy@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@1@0PAPAV2@@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > > >
	mov	DWORD PTR tv135[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv135[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN5@vector
__catch$??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV01@@Z$0:

; 725  : 			_CATCH_ALL
; 726  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@IAEXXZ ; std::vector<Enemy *,std::allocator<Enemy *> >::_Tidy

; 727  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 728  : 			_CATCH_END

	mov	eax, $LN11@vector
	ret	0
$LN5@vector:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN3@vector
$LN11@vector:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector:

; 729  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 280				; 00000118H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::~_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >
__ehhandler$??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-284]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::vector<Enemy *,std::allocator<Enemy *> >
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@XZ PROC ; std::vector<Enemy *,std::allocator<Enemy *> >::vector<Enemy *,std::allocator<Enemy *> >, COMDAT
; _this$ = ecx

; 685  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@PAVEnemy@@@std@@QAE@XZ	; std::allocator<Enemy *>::allocator<Enemy *>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEnemy@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >

; 686  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@XZ ENDP ; std::vector<Enemy *,std::allocator<Enemy *> >::vector<Enemy *,std::allocator<Enemy *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Getal, COMDAT
; _this$ = ecx

; 646  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 647  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<Enemy *> >::_Wrap_alloc<std::allocator<Enemy *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 648  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 635  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 636  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 637  : 			_Alproxy;

	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>

; 638  : 		this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 639  : 		_Alproxy.destroy(this->_Myproxy);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>

; 640  : 		_Alproxy.deallocate(this->_Myproxy, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate

; 641  : 		this->_Myproxy = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 642  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Free_proxy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Free_proxy:
	DD	1
	DD	$LN4@Free_proxy
$LN4@Free_proxy:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Free_proxy
$LN3@Free_proxy:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -228						; size = 8
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 626  : 		{	// construct proxy from _Alval

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 627  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 628  : 			_Alproxy;

	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>

; 629  : 		this->_Myproxy = _Alproxy.allocate(1);

	push	1
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 630  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0_Container_proxy@std@@QAE@XZ		; std::_Container_proxy::_Container_proxy
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>

; 631  : 		this->_Myproxy->_Mycont = this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], edx

; 632  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Alloc_prox
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Alloc_prox:
	DD	1
	DD	$LN4@Alloc_prox
$LN4@Alloc_prox:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Alloc_prox
$LN3@Alloc_prox:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::~_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >, COMDAT
; _this$ = ecx

; 612  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 613  : 		_Free_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Free_proxy

; 614  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::~_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEnemy@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEnemy@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >, COMDAT
; _this$ = ecx

; 606  : 	_Vector_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEnemy@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Enemy *> >::_Vector_val<std::_Simple_types<Enemy *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 607  : 		{	// construct allocator from _Al
; 608  : 		_Alloc_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Alloc_proxy

; 609  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEnemy@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEnemy@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEnemy@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVEnemy@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >::_Vector_alloc<0,std::_Vec_base_types<Enemy *,std::allocator<Enemy *> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<Enemy *> >::~_Vector_val<std::_Simple_types<Enemy *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1_Container_base12@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<Enemy *> >::~_Vector_val<std::_Simple_types<Enemy *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<Enemy *> >::_Vector_val<std::_Simple_types<Enemy *> >, COMDAT
; _this$ = ecx

; 484  : 	_Vector_val()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0_Container_base12@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 485  : 		{	// initialize values
; 486  : 		_Myfirst = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 487  : 		_Mylast = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 488  : 		_Myend = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 489  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<Enemy *> >::_Vector_val<std::_Simple_types<Enemy *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<Enemy *> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SAIABV?$allocator@PAVEnemy@@@2@@Z ; std::allocator_traits<std::allocator<Enemy *> >::max_size
	add	esp, 4

; 915  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<Enemy *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEXPAPAVEnemy@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEXPAPAVEnemy@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Enemy *> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@I@Z ; std::allocator<Enemy *>::deallocate

; 888  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEXPAPAVEnemy@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Enemy *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEPAPAVEnemy@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEPAPAVEnemy@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Enemy *> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@PAVEnemy@@@std@@QAEPAPAVEnemy@@I@Z ; std::allocator<Enemy *>::allocate

; 877  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAEPAPAVEnemy@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Enemy *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV?$allocator@PAVEnemy@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV?$allocator@PAVEnemy@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<Enemy *> >::_Wrap_alloc<std::allocator<Enemy *> >, COMDAT
; _this$ = ecx

; 835  : 		{	// construct by copying base

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@PAVEnemy@@@std@@QAE@ABV01@@Z ; std::allocator<Enemy *>::allocator<Enemy *>

; 836  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV?$allocator@PAVEnemy@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<Enemy *> >::_Wrap_alloc<std::allocator<Enemy *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<Enemy *> >::_Wrap_alloc<std::allocator<Enemy *> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@PAVEnemy@@@std@@QAE@XZ	; std::allocator<Enemy *>::allocator<Enemy *>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<Enemy *> >::_Wrap_alloc<std::allocator<Enemy *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AU12@XZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AU12@XZ PROC ; std::_Wrap_alloc<std::allocator<Enemy *> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 806  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 807  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SA?AV?$allocator@PAVEnemy@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<Enemy *> >::select_on_container_copy_construction
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV?$allocator@PAVEnemy@@@1@@Z ; std::_Wrap_alloc<std::allocator<Enemy *> >::_Wrap_alloc<std::allocator<Enemy *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 808  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVEnemy@@@std@@@std@@QBE?AU12@XZ ENDP ; std::_Wrap_alloc<std::allocator<Enemy *> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SA?AV?$allocator@PAVEnemy@@@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SA?AV?$allocator@PAVEnemy@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<Enemy *> >::select_on_container_copy_construction, COMDAT

; 767  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 768  : 		return (_Al.select_on_container_copy_construction());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?select_on_container_copy_construction@?$allocator@PAVEnemy@@@std@@QBE?AV12@XZ ; std::allocator<Enemy *>::select_on_container_copy_construction
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 769  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SA?AV?$allocator@PAVEnemy@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<Enemy *> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SAIABV?$allocator@PAVEnemy@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SAIABV?$allocator@PAVEnemy@@@2@@Z PROC ; std::allocator_traits<std::allocator<Enemy *> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@PAVEnemy@@@std@@QBEIXZ ; std::allocator<Enemy *>::max_size

; 763  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@PAVEnemy@@@std@@@std@@SAIABV?$allocator@PAVEnemy@@@2@@Z ENDP ; std::allocator_traits<std::allocator<Enemy *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVEnemy@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$allocator@PAVEnemy@@@std@@QBEIXZ PROC	; std::allocator<Enemy *>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 1073741823				; 3fffffffH

; 629  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVEnemy@@@std@@QBEIXZ ENDP	; std::allocator<Enemy *>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@ABQAV3@@Z
_TEXT	SEGMENT
tv68 = -220						; size = 4
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@ABQAV3@@Z PROC ; std::allocator<Enemy *>::construct, COMDAT
; _this$ = ecx

; 605  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR $T1[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv68[ebp], 0
$LN1@construct:

; 607  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@ABQAV3@@Z ENDP ; std::allocator<Enemy *>::construct
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVEnemy@@@std@@QAEPAPAVEnemy@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVEnemy@@@std@@QAEPAPAVEnemy@@I@Z PROC ; std::allocator<Enemy *>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVEnemy@@@std@@YAPAPAVEnemy@@IPAPAV1@@Z ; std::_Allocate<Enemy *>
	add	esp, 8

; 592  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVEnemy@@@std@@QAEPAPAVEnemy@@I@Z ENDP ; std::allocator<Enemy *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@I@Z PROC ; std::allocator<Enemy *>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVEnemy@@@std@@QAEXPAPAVEnemy@@I@Z ENDP ; std::allocator<Enemy *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVEnemy@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVEnemy@@@std@@QAE@ABV01@@Z PROC	; std::allocator<Enemy *>::allocator<Enemy *>, COMDAT
; _this$ = ecx

; 569  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 570  : 		{	// construct by copying (do nothing)
; 571  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVEnemy@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<Enemy *>::allocator<Enemy *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVEnemy@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@PAVEnemy@@@std@@QAE@XZ PROC		; std::allocator<Enemy *>::allocator<Enemy *>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAVEnemy@@@std@@QAE@XZ ENDP		; std::allocator<Enemy *>::allocator<Enemy *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator@PAVEnemy@@@std@@QBE?AV12@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$allocator@PAVEnemy@@@std@@QBE?AV12@XZ PROC ; std::allocator<Enemy *>::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 544  : 		{	// return this allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 545  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$allocator@PAVEnemy@@@std@@QAE@ABV01@@Z ; std::allocator<Enemy *>::allocator<Enemy *>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 546  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?select_on_container_copy_construction@?$allocator@PAVEnemy@@@std@@QBE?AV12@XZ ENDP ; std::allocator<Enemy *>::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?getEnemies@Enemy@@SA?AV?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@XZ
_TEXT	SEGMENT
$T2 = -236						; size = 4
_retval$ = -32						; size = 16
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getEnemies@Enemy@@SA?AV?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@XZ PROC ; Enemy::getEnemies, COMDAT

; 284  : 	static vector<Enemy*> getEnemies(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getEnemies@Enemy@@SA?AV?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0

; 285  : 		vector<Enemy*> retval = enemies;

	push	OFFSET ?enemies@Enemy@@1V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@A ; Enemy::enemies
	lea	ecx, DWORD PTR _retval$[ebp]
	call	??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::vector<Enemy *,std::allocator<Enemy *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 286  : 		return retval;

	lea	eax, DWORD PTR _retval$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@$$QAV01@@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::vector<Enemy *,std::allocator<Enemy *> >
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _retval$[ebp]
	call	??1?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@XZ ; std::vector<Enemy *,std::allocator<Enemy *> >::~vector<Enemy *,std::allocator<Enemy *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 287  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@getEnemies
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@getEnemies:
	DD	1
	DD	$LN8@getEnemies
$LN8@getEnemies:
	DD	-32					; ffffffe0H
	DD	16					; 00000010H
	DD	$LN6@getEnemies
$LN6@getEnemies:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getEnemies@Enemy@@SA?AV?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@XZ$0:
	lea	ecx, DWORD PTR _retval$[ebp]
	jmp	??1?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE@XZ ; std::vector<Enemy *,std::allocator<Enemy *> >::~vector<Enemy *,std::allocator<Enemy *> >
__ehhandler$?getEnemies@Enemy@@SA?AV?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getEnemies@Enemy@@SA?AV?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?getEnemies@Enemy@@SA?AV?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@XZ ENDP ; Enemy::getEnemies
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?aiTurn@Enemy@@SAXPAVLivingEntity@@@Z
_TEXT	SEGMENT
tv132 = -296						; size = 4
tv65 = -292						; size = 4
$T2 = -284						; size = 12
$T3 = -261						; size = 1
$T4 = -252						; size = 12
_item$5 = -40						; size = 4
_iter$6 = -28						; size = 12
__$EHRec$ = -12						; size = 12
_target$ = 8						; size = 4
?aiTurn@Enemy@@SAXPAVLivingEntity@@@Z PROC		; Enemy::aiTurn, COMDAT

; 278  : 	static void aiTurn(LivingEntity *target){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?aiTurn@Enemy@@SAXPAVLivingEntity@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 284				; 0000011cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-296]
	mov	ecx, 71					; 00000047H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 279  : 		for(vector<Enemy*>::iterator iter = enemies.begin(); iter != enemies.end(); iter++){

	lea	eax, DWORD PTR _iter$6[ebp]
	push	eax
	mov	ecx, OFFSET ?enemies@Enemy@@1V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@A ; Enemy::enemies
	call	?begin@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@XZ ; std::vector<Enemy *,std::allocator<Enemy *> >::begin
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	jmp	SHORT $LN3@aiTurn
$LN2@aiTurn:
	push	0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _iter$6[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator++
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
$LN3@aiTurn:
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, OFFSET ?enemies@Enemy@@1V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@A ; Enemy::enemies
	call	?end@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@XZ ; std::vector<Enemy *,std::allocator<Enemy *> >::end
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	mov	DWORD PTR tv132[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR tv132[ebp]
	push	edx
	lea	ecx, DWORD PTR _iter$6[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator!=
	mov	BYTE PTR $T3[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T3[ebp]
	test	eax, eax
	je	SHORT $LN1@aiTurn

; 280  : 			Enemy *item = *iter;

	lea	ecx, DWORD PTR _iter$6[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBEAAPAVEnemy@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator*
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _item$5[ebp], eax

; 281  : 			item->processAndAct(target);

	mov	esi, esp
	mov	eax, DWORD PTR _target$[ebp]
	push	eax
	mov	ecx, DWORD PTR _item$5[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _item$5[ebp]
	mov	eax, DWORD PTR [edx+20]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN2@aiTurn
$LN1@aiTurn:

; 282  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _iter$6[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ

; 283  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@aiTurn
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 296				; 00000128H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN12@aiTurn:
	DD	1
	DD	$LN11@aiTurn
$LN11@aiTurn:
	DD	-28					; ffffffe4H
	DD	12					; 0000000cH
	DD	$LN9@aiTurn
$LN9@aiTurn:
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?aiTurn@Enemy@@SAXPAVLivingEntity@@@Z$0:
	lea	ecx, DWORD PTR _iter$6[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?aiTurn@Enemy@@SAXPAVLivingEntity@@@Z$2:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?aiTurn@Enemy@@SAXPAVLivingEntity@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-300]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?aiTurn@Enemy@@SAXPAVLivingEntity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?aiTurn@Enemy@@SAXPAVLivingEntity@@@Z ENDP		; Enemy::aiTurn
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ??1Enemy@@UAE@XZ
_TEXT	SEGMENT
tv165 = -340						; size = 4
tv162 = -340						; size = 4
tv164 = -336						; size = 4
tv75 = -336						; size = 4
$T2 = -328						; size = 12
$T3 = -305						; size = 1
$T4 = -296						; size = 12
$T5 = -276						; size = 4
$T6 = -264						; size = 12
_item$7 = -52						; size = 4
_iter$8 = -40						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1Enemy@@UAE@XZ PROC					; Enemy::~Enemy, COMDAT
; _this$ = ecx

; 269  : 	~Enemy(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1Enemy@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 328				; 00000148H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-340]
	mov	ecx, 82					; 00000052H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Enemy@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 270  : 		for(vector<Enemy*>::iterator iter = enemies.begin(); iter != enemies.end(); iter++){

	lea	eax, DWORD PTR _iter$8[ebp]
	push	eax
	mov	ecx, OFFSET ?enemies@Enemy@@1V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@A ; Enemy::enemies
	call	?begin@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@XZ ; std::vector<Enemy *,std::allocator<Enemy *> >::begin
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	jmp	SHORT $LN4@Enemy
$LN3@Enemy:
	push	0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _iter$8[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator++
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
$LN4@Enemy:
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, OFFSET ?enemies@Enemy@@1V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@A ; Enemy::enemies
	call	?end@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@XZ ; std::vector<Enemy *,std::allocator<Enemy *> >::end
	mov	DWORD PTR tv75[ebp], eax
	mov	ecx, DWORD PTR tv75[ebp]
	mov	DWORD PTR tv162[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR tv162[ebp]
	push	edx
	lea	ecx, DWORD PTR _iter$8[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator!=
	mov	BYTE PTR $T3[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T3[ebp]
	test	eax, eax
	je	SHORT $LN2@Enemy

; 271  : 			Enemy *item = *iter;

	lea	ecx, DWORD PTR _iter$8[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QBEAAPAVEnemy@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Enemy *> > >::operator*
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _item$7[ebp], eax

; 272  : 			if(item == this){

	mov	eax, DWORD PTR _item$7[ebp]
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $LN1@Enemy

; 273  : 				enemies.erase(iter);

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T5[ebp], esp
	lea	eax, DWORD PTR _iter$8[ebp]
	push	eax
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv164[ebp], eax
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	ecx, OFFSET ?enemies@Enemy@@1V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@A ; Enemy::enemies
	call	?erase@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@2@@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::erase
	mov	DWORD PTR tv165[ebp], eax
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ

; 274  : 				break;

	jmp	SHORT $LN2@Enemy
$LN1@Enemy:

; 275  : 			}

	jmp	$LN3@Enemy
$LN2@Enemy:

; 276  : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _iter$8[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ

; 277  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FightingEntity@@UAE@XZ
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@Enemy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 340				; 00000154H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN16@Enemy:
	DD	1
	DD	$LN15@Enemy
$LN15@Enemy:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN13@Enemy
$LN13@Enemy:
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1Enemy@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1FightingEntity@@UAE@XZ
__unwindfunclet$??1Enemy@@UAE@XZ$1:
	lea	ecx, DWORD PTR _iter$8[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??1Enemy@@UAE@XZ$3:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEnemy@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??1Enemy@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-344]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1Enemy@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1Enemy@@UAE@XZ ENDP					; Enemy::~Enemy
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ??0Enemy@@QAE@XZ
_TEXT	SEGMENT
$T2 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0Enemy@@QAE@XZ PROC					; Enemy::Enemy, COMDAT
; _this$ = ecx

; 266  : 	Enemy(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Enemy@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0FightingEntity@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Enemy@@6B@

; 267  : 		enemies.push_back(this);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, OFFSET ?enemies@Enemy@@1V?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@A ; Enemy::enemies
	call	?push_back@?$vector@PAVEnemy@@V?$allocator@PAVEnemy@@@std@@@std@@QAEXABQAVEnemy@@@Z ; std::vector<Enemy *,std::allocator<Enemy *> >::push_back

; 268  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Enemy@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1FightingEntity@@UAE@XZ
__ehhandler$??0Enemy@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Enemy@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Enemy@@QAE@XZ ENDP					; Enemy::Enemy
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GPlayer@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GPlayer@@UAEPAXI@Z PROC				; Player::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Player@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GPlayer@@UAEPAXI@Z ENDP				; Player::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1Player@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1Player@@UAE@XZ PROC					; Player::~Player, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FightingEntity@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1Player@@UAE@XZ ENDP					; Player::~Player
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?toChar@Player@@MAEDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?toChar@Player@@MAEDXZ PROC				; Player::toChar, COMDAT
; _this$ = ecx

; 259  : 	virtual char toChar(){

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 260  : 		return 'P';

	mov	al, 80					; 00000050H

; 261  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?toChar@Player@@MAEDXZ ENDP				; Player::toChar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?subHealth@Player@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_amount$ = 8						; size = 4
?subHealth@Player@@UAEXH@Z PROC				; Player::subHealth, COMDAT
; _this$ = ecx

; 431  : void Player::subHealth(int amount){

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	gameView->setColor(0x84); //1000 0100, or foreground red, background intense

	push	132					; 00000084H
	mov	ecx, DWORD PTR ?gameView@@3PAVScreen@@A	; gameView
	call	?setColor@Screen@@QAEXE@Z		; Screen::setColor

; 433  : 	FightingEntity::subHealth(amount);

	mov	eax, DWORD PTR _amount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?subHealth@LivingEntity@@UAEXH@Z	; LivingEntity::subHealth

; 434  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?subHealth@Player@@UAEXH@Z ENDP				; Player::subHealth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?shoot@Player@@UAEXW4Directions@@@Z
_TEXT	SEGMENT
tv131 = -256						; size = 4
$T2 = -248						; size = 4
$T3 = -236						; size = 4
_shot$4 = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_dir$ = 8						; size = 4
?shoot@Player@@UAEXW4Directions@@@Z PROC		; Player::shoot, COMDAT
; _this$ = ecx

; 245  : 	void shoot(Directions dir){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?shoot@Player@@UAEXW4Directions@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 246  : 		if(this->ammo > 0){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jle	$LN2@shoot

; 247  : 			Bullet *shot = new Bullet(1, facing, this->location.x, this->location.y);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN5@shoot
	push	10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0Bullet@@QAE@HW4Directions@@HHH@Z	; Bullet::Bullet
	mov	DWORD PTR tv131[ebp], eax
	jmp	SHORT $LN6@shoot
$LN5@shoot:
	mov	DWORD PTR tv131[ebp], 0
$LN6@shoot:
	mov	eax, DWORD PTR tv131[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _shot$4[ebp], ecx

; 248  : 			ammo--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 249  : 		}
; 250  : 		else{

	jmp	SHORT $LN3@shoot
$LN2@shoot:

; 251  : 			ammo = magSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+24], edx
$LN3@shoot:

; 252  : 		}
; 253  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?shoot@Player@@UAEXW4Directions@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?shoot@Player@@UAEXW4Directions@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?shoot@Player@@UAEXW4Directions@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?shoot@Player@@UAEXW4Directions@@@Z ENDP		; Player::shoot
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?move@Player@@QAEXW4Directions@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_dir$ = 8						; size = 4
?move@Player@@QAEXW4Directions@@@Z PROC			; Player::move, COMDAT
; _this$ = ecx

; 241  : 	void move(Directions dir){

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 242  : 		facing = dir;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _dir$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 243  : 		OnScreen::move(facing, speed);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?move@OnScreen@@MAE_NW4Directions@@H@Z	; OnScreen::move

; 244  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?move@Player@@QAEXW4Directions@@@Z ENDP			; Player::move
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?getName@Player@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getName@Player@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Player::getName, COMDAT
; _this$ = ecx

; 238  : 	string getName(){

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 239  : 		return name;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR $T1[ebp]
	or	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 240  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?getName@Player@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Player::getName
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ??0Player@@QAE@HHMHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Directions@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_row$ = 8						; size = 4
_col$ = 12						; size = 4
_health$ = 16						; size = 4
_ammo$ = 20						; size = 4
_score$ = 24						; size = 4
_speed$ = 28						; size = 4
_name$ = 32						; size = 28
_facing$ = 60						; size = 4
??0Player@@QAE@HHMHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Directions@@@Z PROC ; Player::Player, COMDAT
; _this$ = ecx

; 227  : 	Player(int row, int col, float health, int ammo, int score, int speed, string name = "Player 1", Directions facing = Directions::RIGHT){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Player@@QAE@HHMHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Directions@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0FightingEntity@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Player@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 228  : 		this->location.x = col;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 229  : 		this->location.y = row;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _row$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 230  : 		this->health = health;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _health$[ebp]
	movss	DWORD PTR [eax+16], xmm0

; 231  : 		this->score = score;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _score$[ebp]
	mov	DWORD PTR [eax+60], ecx

; 232  : 		this->ammo = ammo;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ammo$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 233  : 		this->speed = speed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _speed$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 234  : 		this->name = name;

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 235  : 		this->facing = facing;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _facing$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 236  : 		this->magSize = ammo;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ammo$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 237  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _name$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	56					; 00000038H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Player@@QAE@HHMHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Directions@@@Z$0:
	lea	ecx, DWORD PTR _name$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0Player@@QAE@HHMHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Directions@@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1FightingEntity@@UAE@XZ
__unwindfunclet$??0Player@@QAE@HHMHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Directions@@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0Player@@QAE@HHMHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Directions@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Player@@QAE@HHMHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Directions@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Player@@QAE@HHMHHHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4Directions@@@Z ENDP ; Player::Player
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GFightingEntity@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GFightingEntity@@UAEPAXI@Z PROC			; FightingEntity::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FightingEntity@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GFightingEntity@@UAEPAXI@Z ENDP			; FightingEntity::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1FightingEntity@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1FightingEntity@@UAE@XZ PROC				; FightingEntity::~FightingEntity, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1LivingEntity@@UAE@XZ			; LivingEntity::~LivingEntity
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1FightingEntity@@UAE@XZ ENDP				; FightingEntity::~FightingEntity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0FightingEntity@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0FightingEntity@@QAE@XZ PROC				; FightingEntity::FightingEntity, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0LivingEntity@@QAE@XZ			; LivingEntity::LivingEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7FightingEntity@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0FightingEntity@@QAE@XZ ENDP				; FightingEntity::FightingEntity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?bullets@Bullet@@1V?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@A@@YAXXZ
text$yd	SEGMENT
??__F?bullets@Bullet@@1V?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'Bullet::bullets'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?bullets@Bullet@@1V?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@A ; Bullet::bullets
	call	??1?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE@XZ ; std::vector<Bullet *,std::allocator<Bullet *> >::~vector<Bullet *,std::allocator<Bullet *> >
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__F?bullets@Bullet@@1V?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'Bullet::bullets''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ??__E?bullets@Bullet@@1V?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@A@@YAXXZ
text$yc	SEGMENT
??__E?bullets@Bullet@@1V?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@A@@YAXXZ PROC ; `dynamic initializer for 'Bullet::bullets'', COMDAT

; 215  : vector<Bullet*> Bullet::bullets;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?bullets@Bullet@@1V?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@A ; Bullet::bullets
	call	??0?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE@XZ ; std::vector<Bullet *,std::allocator<Bullet *> >::vector<Bullet *,std::allocator<Bullet *> >
	push	OFFSET ??__F?bullets@Bullet@@1V?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@A@@YAXXZ ; `dynamic atexit destructor for 'Bullet::bullets''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?bullets@Bullet@@1V?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@A@@YAXXZ ENDP ; `dynamic initializer for 'Bullet::bullets''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
$T2 = -244						; size = 4
__Tmp$ = -40						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator++, COMDAT
; _this$ = ecx

; 339  : 		{	// postincrement

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE?AV01@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0

; 340  : 		_Myiter _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 341  : 		++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator++

; 342  : 		return (_Tmp);

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 343  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN9@operator:
	DD	1
	DD	$LN8@operator
$LN8@operator:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN6@operator
$LN6@operator:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE?AV01@H@Z$0:
	lea	ecx, DWORD PTR __Tmp$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE?AV01@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE?AV01@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator++
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator++, COMDAT
; _this$ = ecx

; 333  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 334  : 		++*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator++

; 335  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 336  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBEAAPAVBullet@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBEAAPAVBullet@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator*, COMDAT
; _this$ = ecx

; 323  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 324  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBEABQAVBullet@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator*

; 325  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBEAAPAVBullet@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@PAPAVBullet@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@PAPAVBullet@@PBU_Container_base12@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@PAPAVBullet@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >

; 307  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@PAPAVBullet@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVBullet@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVBullet@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::_Compat, COMDAT
; _this$ = ecx

; 236  : 		{	// test for compatible iterator pair

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 237  : 		if (this->_Getcont() == 0
; 238  : 			|| this->_Getcont() != _Right._Getcont())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	test	eax, eax
	je	SHORT $LN1@Compat
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	cmp	esi, eax
	je	$LN3@Compat
$LN1@Compat:

; 239  : 			{	// report error
; 240  : 			_DEBUG_ERROR("vector iterators incompatible");

	mov	esi, esp
	push	240					; 000000f0H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 241  : 			_SCL_SECURE_INVALID_ARGUMENT;

	mov	eax, OFFSET ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
	test	eax, eax
	je	SHORT $LN5@Compat
	xor	ecx, ecx
	jne	SHORT $LN6@Compat
$LN5@Compat:
	mov	esi, esp
	push	OFFSET ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	241					; 000000f1H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@Compat
	int	3
$LN6@Compat:
	mov	esi, esp
	push	0
	push	241					; 000000f1H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1NE@PDAEDKHB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Compat:

; 242  : 			}
; 243  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator!=, COMDAT
; _this$ = ecx

; 209  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 210  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 211  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::_Compat

; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 206  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator++, COMDAT
; _this$ = ecx

; 95   : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	test	eax, eax
	je	SHORT $LN1@operator
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN1@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@operator
$LN1@operator:

; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");

	mov	esi, esp
	push	101					; 00000065H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 102  : 			_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	102					; 00000066H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	102					; 00000066H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1NM@CIMOPBIH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 113  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 114  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBEABQAVBullet@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBEABQAVBullet@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator*, COMDAT
; _this$ = ecx

; 65   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	test	eax, eax
	je	SHORT $LN1@operator
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN1@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@operator
$LN1@operator:

; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");

	mov	esi, esp
	push	72					; 00000048H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 73   : 			_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	73					; 00000049H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	73					; 00000049H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1NK@ILKCDHLI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 87   : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBEABQAVBullet@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@PAPAVBullet@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@PAPAVBullet@@PBU_Container_base12@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@PAPAVBullet@@PBU_Container_base12@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVBullet@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 48   : 		this->_Adopt(_Pvector);

	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 49   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@PAPAVBullet@@PBU_Container_base12@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVBullet@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@PAPAVBullet@@PBU_Container_base12@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@PAPAVBullet@@PBU_Container_base12@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@PAPAVBullet@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVBullet@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVBullet@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z PROC ; std::_Iterator012<std::random_access_iterator_tag,Bullet *,int,Bullet * const *,Bullet * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Bullet *,int,Bullet * const *,Bullet * const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@ABU01@@Z	; std::_Iterator_base12::_Iterator_base12
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVBullet@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ENDP ; std::_Iterator012<std::random_access_iterator_tag,Bullet *,int,Bullet * const *,Bullet * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Bullet *,int,Bullet * const *,Bullet * const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVBullet@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVBullet@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,Bullet *,int,Bullet * const *,Bullet * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,Bullet *,int,Bullet * const *,Bullet * const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::~_Iterator_base12
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVBullet@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,Bullet *,int,Bullet * const *,Bullet * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,Bullet *,int,Bullet * const *,Bullet * const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVBullet@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVBullet@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,Bullet *,int,Bullet * const *,Bullet * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Bullet *,int,Bullet * const *,Bullet * const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::_Iterator_base12
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVBullet@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,Bullet *,int,Bullet * const *,Bullet * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Bullet *,int,Bullet * const *,Bullet * const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GBullet@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GBullet@@UAEPAXI@Z PROC				; Bullet::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Bullet@@UAE@XZ			; Bullet::~Bullet
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GBullet@@UAEPAXI@Z ENDP				; Bullet::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?toChar@Bullet@@MAEDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?toChar@Bullet@@MAEDXZ PROC				; Bullet::toChar, COMDAT
; _this$ = ecx

; 210  : 	virtual char toChar(){

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 211  : 		return '*';

	mov	al, 42					; 0000002aH

; 212  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?toChar@Bullet@@MAEDXZ ENDP				; Bullet::toChar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?move@Bullet@@MAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?move@Bullet@@MAE_NXZ PROC				; Bullet::move, COMDAT
; _this$ = ecx

; 207  : 	virtual bool move(){

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 208  : 		return OnScreen::move(direction, speed);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?move@OnScreen@@MAE_NW4Directions@@H@Z	; OnScreen::move

; 209  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?move@Bullet@@MAE_NXZ ENDP				; Bullet::move
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?addBullet@Bullet@@KAXPAV1@@Z
_TEXT	SEGMENT
_bullet$ = 8						; size = 4
?addBullet@Bullet@@KAXPAV1@@Z PROC			; Bullet::addBullet, COMDAT

; 204  : 	static void addBullet(Bullet* bullet){

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 205  : 		bullets.push_back(bullet);

	lea	eax, DWORD PTR _bullet$[ebp]
	push	eax
	mov	ecx, OFFSET ?bullets@Bullet@@1V?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@A ; Bullet::bullets
	call	?push_back@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAEXABQAVBullet@@@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::push_back

; 206  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?addBullet@Bullet@@KAXPAV1@@Z ENDP			; Bullet::addBullet
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEXPAPAVBullet@@0@Z
_TEXT	SEGMENT
__Pnext$ = -44						; size = 4
__Lock$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEXPAPAVBullet@@0@Z PROC ; std::vector<Bullet *,std::allocator<Bullet *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1677 : 		{	// orphan iterators within specified (inclusive) range

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Orphan_range@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEXPAPAVBullet@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1678 : 		_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1679 : 		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Pnext$[ebp], eax

; 1680 : 		if (_Pnext != 0)

	cmp	DWORD PTR __Pnext$[ebp], 0
	je	SHORT $LN6@Orphan_ran
$LN5@Orphan_ran:

; 1681 : 			while (*_Pnext != 0)

	mov	eax, DWORD PTR __Pnext$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@Orphan_ran

; 1682 : 				if ((*_Pnext)->_Ptr < _First || _Last < (*_Pnext)->_Ptr)

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR __First$[ebp]
	jb	SHORT $LN2@Orphan_ran
	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Last$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN3@Orphan_ran
$LN2@Orphan_ran:

; 1683 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
	mov	DWORD PTR __Pnext$[ebp], eax

; 1684 : 				else

	jmp	SHORT $LN1@Orphan_ran
$LN3@Orphan_ran:

; 1685 : 					{	// orphan the iterator
; 1686 : 					(*_Pnext)->_Clrcont();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Clrcont@_Iterator_base12@std@@QAEXXZ	; std::_Iterator_base12::_Clrcont

; 1687 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
	mov	ecx, DWORD PTR __Pnext$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
$LN1@Orphan_ran:

; 1688 : 					}

	jmp	SHORT $LN5@Orphan_ran
$LN6@Orphan_ran:

; 1689 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@Orphan_ran
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN13@Orphan_ran:
	DD	1
	DD	$LN12@Orphan_ran
$LN12@Orphan_ran:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN10@Orphan_ran
$LN10@Orphan_ran:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_range@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEXPAPAVBullet@@0@Z$0:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$?_Orphan_range@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEXPAPAVBullet@@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Orphan_range@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEXPAPAVBullet@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Orphan_range@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEXPAPAVBullet@@0@Z ENDP ; std::vector<Bullet *,std::allocator<Bullet *> >::_Orphan_range
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xlen@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEXXZ PROC ; std::vector<Bullet *,std::allocator<Bullet *> >::_Xlen, COMDAT
; _this$ = ecx

; 1666 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1667 : 		_Xlength_error("vector<T> too long");

	mov	esi, esp
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Xlen:

; 1668 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEXXZ ENDP ; std::vector<Bullet *,std::allocator<Bullet *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
?_Tidy@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXXZ PROC ; std::vector<Bullet *,std::allocator<Bullet *> >::_Tidy, COMDAT
; _this$ = ecx

; 1535 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1536 : 		if (this->_Myfirst != pointer())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN2@Tidy

; 1537 : 			{	// something to free, destroy and deallocate it
; 1538 : 			this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1539 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXPAPAVBullet@@0@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::_Destroy

; 1540 : 			this->_Getal().deallocate(this->_Myfirst,
; 1541 : 				this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAEXPAPAVBullet@@I@Z ; std::_Wrap_alloc<std::allocator<Bullet *> >::deallocate

; 1542 : 			this->_Myfirst = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1543 : 			this->_Mylast = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 1544 : 			this->_Myend = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
$LN2@Tidy:

; 1545 : 			}
; 1546 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXXZ ENDP ; std::vector<Bullet *,std::allocator<Bullet *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z PROC ; std::vector<Bullet *,std::allocator<Bullet *> >::_Reserve, COMDAT
; _this$ = ecx

; 1525 : 		{	// ensure room for _Count new elements, grow exponentially

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1526 : 		if (_Unused_capacity() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Unused_capacity@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ ; std::vector<Bullet *,std::allocator<Bullet *> >::_Unused_capacity
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN4@Reserve

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ ; std::vector<Bullet *,std::allocator<Bullet *> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ ; std::vector<Bullet *,std::allocator<Bullet *> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Reserve

; 1529 : 				_Xlen();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEXXZ ; std::vector<Bullet *,std::allocator<Bullet *> >::_Xlen
$LN1@Reserve:

; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ ; std::vector<Bullet *,std::allocator<Bullet *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow_to@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEII@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::_Grow_to
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reallocate@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::_Reallocate
$LN4@Reserve:

; 1531 : 			}
; 1532 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Reserve@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z ENDP ; std::vector<Bullet *,std::allocator<Bullet *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T2 = -273						; size = 1
$T3 = -261						; size = 1
$T4 = -249						; size = 1
__Size$ = -48						; size = 4
__Ptr$ = -36						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z PROC ; std::vector<Bullet *,std::allocator<Bullet *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1500 : 		{	// move to array of exactly _Count elements

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAEPAPAVBullet@@I@Z ; std::_Wrap_alloc<std::allocator<Bullet *> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 1502 : 
; 1503 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVBullet@@@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEPAPAVBullet@@PAPAV2@00@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::_Umove<Bullet * *>
	jmp	SHORT $LN5@Reallocate
__catch$?_Reallocate@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z$0:

; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAEXPAPAVBullet@@I@Z ; std::_Wrap_alloc<std::allocator<Bullet *> >::deallocate

; 1507 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1508 : 		_CATCH_END

	mov	eax, $LN8@Reallocate
	ret	0
$LN5@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Reallocate@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z$1
$LN8@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z$1:

; 1509 : 
; 1510 : 		size_type _Size = size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ ; std::vector<Bullet *,std::allocator<Bullet *> >::size
	mov	DWORD PTR __Size$[ebp], eax

; 1511 : 		if (this->_Myfirst != pointer())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Reallocate

; 1512 : 			{	// destroy and deallocate old array
; 1513 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXPAPAVBullet@@0@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::_Destroy

; 1514 : 			this->_Getal().deallocate(this->_Myfirst,
; 1515 : 				this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAEXPAPAVBullet@@I@Z ; std::_Wrap_alloc<std::allocator<Bullet *> >::deallocate
$LN1@Reallocate:

; 1516 : 			}
; 1517 : 
; 1518 : 		this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1519 : 		this->_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1520 : 		this->_Mylast = _Ptr + _Size;

	mov	eax, DWORD PTR __Size$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1521 : 		this->_Myfirst = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN4@Reallocate:

; 1522 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 280				; 00000118H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-284]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z ENDP ; std::vector<Bullet *,std::allocator<Bullet *> >::_Reallocate
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBE_NPBQAVBullet@@@Z
_TEXT	SEGMENT
tv76 = -208						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBE_NPBQAVBullet@@@Z PROC ; std::vector<Bullet *,std::allocator<Bullet *> >::_Inside, COMDAT
; _this$ = ecx

; 1495 : 		{	// test if _Ptr points inside vector

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN3@Inside
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN4@Inside
$LN3@Inside:
	mov	DWORD PTR tv76[ebp], 0
$LN4@Inside:
	mov	al, BYTE PTR tv76[ebp]

; 1497 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBE_NPBQAVBullet@@@Z ENDP ; std::vector<Bullet *,std::allocator<Bullet *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -220						; size = 4
__Capacity$ = -20					; size = 4
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEII@Z PROC ; std::vector<Bullet *,std::allocator<Bullet *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1484 : 		{	// grow by 50% or at least to _Count

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1485 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ ; std::vector<Bullet *,std::allocator<Bullet *> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ ; std::vector<Bullet *,std::allocator<Bullet *> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN4@Grow_to
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN5@Grow_to
$LN4@Grow_to:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1489 : 		if (_Capacity < _Count)

	mov	eax, DWORD PTR __Capacity$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Grow_to

; 1490 : 			_Capacity = _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to:

; 1491 : 		return (_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]

; 1492 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Grow_to@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEII@Z ENDP ; std::vector<Bullet *,std::allocator<Bullet *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXPAPAVBullet@@0@Z
_TEXT	SEGMENT
__Alval$ = -17						; size = 1
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXPAPAVBullet@@0@Z PROC ; std::vector<Bullet *,std::allocator<Bullet *> >::_Destroy, COMDAT
; _this$ = ecx

; 1478 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1479 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Getal

; 1480 : 		_Destroy_range(_First, _Last, _Alval);

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@@std@@YAXPAPAVBullet@@0AAU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<Bullet *> > >
	add	esp, 12					; 0000000cH

; 1481 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Destroy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN5@Destroy:
	DD	1
	DD	$LN4@Destroy
$LN4@Destroy:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Destroy
$LN3@Destroy:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
?_Destroy@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXPAPAVBullet@@0@Z ENDP ; std::vector<Bullet *,std::allocator<Bullet *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?erase@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv182 = -248						; size = 4
tv181 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
?erase@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z PROC ; std::vector<Bullet *,std::allocator<Bullet *> >::erase, COMDAT
; _this$ = ecx

; 1356 : 		{	// erase element at where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T3[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $LN1@erase
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+8]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@erase
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR __Where$[ebp+8]
	ja	SHORT $LN2@erase
$LN1@erase:

; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");

	mov	esi, esp
	push	1360					; 00000550H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@erase:

; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));

	mov	eax, DWORD PTR __Where$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+8]
	add	eax, 4
	push	eax
	call	??$_Move@PAPAVBullet@@PAPAV1@@std@@YAPAPAVBullet@@PAPAV1@00@Z ; std::_Move<Bullet * *,Bullet * *>
	add	esp, 12					; 0000000cH

; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXPAPAVBullet@@0@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::_Destroy

; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEXPAPAVBullet@@0@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::_Orphan_range

; 1364 : 		--this->_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1365 : 		return (_Make_iter(_Where));

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	lea	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv181[ebp], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::_Make_iter
	mov	DWORD PTR tv182[ebp], eax
	mov	edx, DWORD PTR $T3[ebp]
	or	edx, 1
	mov	DWORD PTR $T3[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1366 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z$0:
	lea	ecx, DWORD PTR __Where$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?erase@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z ENDP ; std::vector<Bullet *,std::allocator<Bullet *> >::erase
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAEXABQAVBullet@@@Z
_TEXT	SEGMENT
$T1 = -233						; size = 1
$T2 = -221						; size = 1
__Idx$3 = -20						; size = 4
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAEXABQAVBullet@@@Z PROC ; std::vector<Bullet *,std::allocator<Bullet *> >::push_back, COMDAT
; _this$ = ecx

; 1184 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1185 : 		if (_Inside(_STD addressof(_Val)))

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@QAVBullet@@@std@@YAPBQAVBullet@@ABQAV1@@Z ; std::addressof<Bullet * const>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBE_NPBQAVBullet@@@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@push_back

; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@QAVBullet@@@std@@YAPBQAVBullet@@ABQAV1@@Z ; std::addressof<Bullet * const>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2
	mov	DWORD PTR __Idx$3[ebp], eax

; 1188 : 			if (this->_Mylast == this->_Myend)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN3@push_back

; 1189 : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::_Reserve
$LN3@push_back:

; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEXPAPAVBullet@@0@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::_Orphan_range

; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Idx$3[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Getal
	mov	ecx, eax
	call	??$construct@PAVBullet@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAEXPAPAVBullet@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<Bullet *> >::construct<Bullet *,Bullet * &>

; 1193 : 			++this->_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1194 : 			}
; 1195 : 		else

	jmp	SHORT $LN5@push_back
$LN4@push_back:

; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN1@push_back

; 1198 : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXI@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::_Reserve
$LN1@push_back:

; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IBEXPAPAVBullet@@0@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::_Orphan_range

; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Getal
	mov	ecx, eax
	call	??$construct@PAVBullet@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAEXPAPAVBullet@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<Bullet *> >::construct<Bullet *,Bullet * const &>

; 1202 : 			++this->_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN5@push_back:

; 1203 : 			}
; 1204 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAEXABQAVBullet@@@Z ENDP ; std::vector<Bullet *,std::allocator<Bullet *> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??A?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAEAAPAVBullet@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAEAAPAVBullet@@I@Z PROC ; std::vector<Bullet *,std::allocator<Bullet *> >::operator[], COMDAT
; _this$ = ecx

; 1136 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ ; std::vector<Bullet *,std::allocator<Bullet *> >::size
	cmp	eax, DWORD PTR __Pos$[ebp]
	ja	$LN1@operator

; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");

	mov	esi, esp
	push	1140					; 00000474H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN4@operator
	xor	ecx, ecx
	jne	SHORT $LN5@operator
$LN4@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	1141					; 00000475H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@operator
	int	3
$LN5@operator:
	mov	esi, esp
	push	0
	push	1141					; 00000475H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1JO@DMPMMILD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAB?$AAu?$AAl?$AAl?$AAe?$AAt?$AA?5?$AA?$CK?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@operator:

; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 1149 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAEAAPAVBullet@@I@Z ENDP ; std::vector<Bullet *,std::allocator<Bullet *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
?max_size@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ PROC ; std::vector<Bullet *,std::allocator<Bullet *> >::max_size, COMDAT
; _this$ = ecx

; 1091 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1092 : 		return (this->_Getal().max_size());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<Bullet *> >::max_size

; 1093 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ ENDP ; std::vector<Bullet *,std::allocator<Bullet *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ PROC ; std::vector<Bullet *,std::allocator<Bullet *> >::size, COMDAT
; _this$ = ecx

; 1086 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1087 : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 1088 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ ENDP ; std::vector<Bullet *,std::allocator<Bullet *> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
$T2 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
?_Make_iter@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z PROC ; std::vector<Bullet *,std::allocator<Bullet *> >::_Make_iter, COMDAT
; _this$ = ecx

; 1001 : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Make_iter@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1002 : 		return (iterator(_Where._Ptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+8]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@PAPAVBullet@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 1
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1003 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Make_iter@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z$0:
	lea	ecx, DWORD PTR __Where$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?_Make_iter@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Make_iter@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Make_iter@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z ENDP ; std::vector<Bullet *,std::allocator<Bullet *> >::_Make_iter
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?end@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@XZ PROC ; std::vector<Bullet *,std::allocator<Bullet *> >::end, COMDAT
; _this$ = ecx

; 991  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 992  : 		return (iterator(this->_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@PAPAVBullet@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 993  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@XZ ENDP ; std::vector<Bullet *,std::allocator<Bullet *> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@XZ PROC ; std::vector<Bullet *,std::allocator<Bullet *> >::begin, COMDAT
; _this$ = ecx

; 981  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 982  : 		return (iterator(this->_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@PAPAVBullet@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 983  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@XZ ENDP ; std::vector<Bullet *,std::allocator<Bullet *> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Unused_capacity@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ PROC ; std::vector<Bullet *,std::allocator<Bullet *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 971  : 		{	// micro-optimization for capacity() - size()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 972  : 		return (this->_Myend - this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+8]
	sar	eax, 2

; 973  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Unused_capacity@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ ENDP ; std::vector<Bullet *,std::allocator<Bullet *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?capacity@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ PROC ; std::vector<Bullet *,std::allocator<Bullet *> >::capacity, COMDAT
; _this$ = ecx

; 966  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 967  : 		return (this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 968  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ ENDP ; std::vector<Bullet *,std::allocator<Bullet *> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??1?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE@XZ PROC ; std::vector<Bullet *,std::allocator<Bullet *> >::~vector<Bullet *,std::allocator<Bullet *> >, COMDAT
; _this$ = ecx

; 899  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 900  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@IAEXXZ ; std::vector<Bullet *,std::allocator<Bullet *> >::_Tidy

; 901  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::~_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE@XZ ENDP ; std::vector<Bullet *,std::allocator<Bullet *> >::~vector<Bullet *,std::allocator<Bullet *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
??0?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE@XZ PROC ; std::vector<Bullet *,std::allocator<Bullet *> >::vector<Bullet *,std::allocator<Bullet *> >, COMDAT
; _this$ = ecx

; 685  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@PAVBullet@@@std@@QAE@XZ	; std::allocator<Bullet *>::allocator<Bullet *>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVBullet@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >

; 686  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE@XZ ENDP ; std::vector<Bullet *,std::allocator<Bullet *> >::vector<Bullet *,std::allocator<Bullet *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Getal, COMDAT
; _this$ = ecx

; 646  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 647  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<Bullet *> >::_Wrap_alloc<std::allocator<Bullet *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 648  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 635  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 636  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 637  : 			_Alproxy;

	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>

; 638  : 		this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 639  : 		_Alproxy.destroy(this->_Myproxy);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>

; 640  : 		_Alproxy.deallocate(this->_Myproxy, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate

; 641  : 		this->_Myproxy = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 642  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Free_proxy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Free_proxy:
	DD	1
	DD	$LN4@Free_proxy
$LN4@Free_proxy:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Free_proxy
$LN3@Free_proxy:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -228						; size = 8
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 626  : 		{	// construct proxy from _Alval

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 627  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 628  : 			_Alproxy;

	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>

; 629  : 		this->_Myproxy = _Alproxy.allocate(1);

	push	1
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 630  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0_Container_proxy@std@@QAE@XZ		; std::_Container_proxy::_Container_proxy
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>

; 631  : 		this->_Myproxy->_Mycont = this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], edx

; 632  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Alloc_prox
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Alloc_prox:
	DD	1
	DD	$LN4@Alloc_prox
$LN4@Alloc_prox:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Alloc_prox
$LN3@Alloc_prox:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::~_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >, COMDAT
; _this$ = ecx

; 612  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 613  : 		_Free_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Free_proxy

; 614  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::~_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVBullet@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVBullet@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >, COMDAT
; _this$ = ecx

; 606  : 	_Vector_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVBullet@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Bullet *> >::_Vector_val<std::_Simple_types<Bullet *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 607  : 		{	// construct allocator from _Al
; 608  : 		_Alloc_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Alloc_proxy

; 609  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVBullet@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVBullet@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVBullet@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVBullet@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >::_Vector_alloc<0,std::_Vec_base_types<Bullet *,std::allocator<Bullet *> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<Bullet *> >::~_Vector_val<std::_Simple_types<Bullet *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1_Container_base12@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<Bullet *> >::~_Vector_val<std::_Simple_types<Bullet *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<Bullet *> >::_Vector_val<std::_Simple_types<Bullet *> >, COMDAT
; _this$ = ecx

; 484  : 	_Vector_val()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0_Container_base12@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 485  : 		{	// initialize values
; 486  : 		_Myfirst = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 487  : 		_Mylast = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 488  : 		_Myend = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 489  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<Bullet *> >::_Vector_val<std::_Simple_types<Bullet *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<Bullet *> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@PAVBullet@@@std@@@std@@SAIABV?$allocator@PAVBullet@@@2@@Z ; std::allocator_traits<std::allocator<Bullet *> >::max_size
	add	esp, 4

; 915  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<Bullet *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAEXPAPAVBullet@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAEXPAPAVBullet@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Bullet *> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@PAVBullet@@@std@@QAEXPAPAVBullet@@I@Z ; std::allocator<Bullet *>::deallocate

; 888  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAEXPAPAVBullet@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Bullet *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAEPAPAVBullet@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAEPAPAVBullet@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Bullet *> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@PAVBullet@@@std@@QAEPAPAVBullet@@I@Z ; std::allocator<Bullet *>::allocate

; 877  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAEPAPAVBullet@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Bullet *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<Bullet *> >::_Wrap_alloc<std::allocator<Bullet *> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@PAVBullet@@@std@@QAE@XZ	; std::allocator<Bullet *>::allocator<Bullet *>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@PAVBullet@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<Bullet *> >::_Wrap_alloc<std::allocator<Bullet *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVBullet@@@std@@@std@@SAIABV?$allocator@PAVBullet@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAVBullet@@@std@@@std@@SAIABV?$allocator@PAVBullet@@@2@@Z PROC ; std::allocator_traits<std::allocator<Bullet *> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@PAVBullet@@@std@@QBEIXZ ; std::allocator<Bullet *>::max_size

; 763  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@PAVBullet@@@std@@@std@@SAIABV?$allocator@PAVBullet@@@2@@Z ENDP ; std::allocator_traits<std::allocator<Bullet *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVBullet@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$allocator@PAVBullet@@@std@@QBEIXZ PROC	; std::allocator<Bullet *>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 1073741823				; 3fffffffH

; 629  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVBullet@@@std@@QBEIXZ ENDP	; std::allocator<Bullet *>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@PAVBullet@@@std@@QAEXPAPAVBullet@@ABQAV3@@Z
_TEXT	SEGMENT
tv68 = -220						; size = 4
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVBullet@@@std@@QAEXPAPAVBullet@@ABQAV3@@Z PROC ; std::allocator<Bullet *>::construct, COMDAT
; _this$ = ecx

; 605  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR $T1[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv68[ebp], 0
$LN1@construct:

; 607  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@PAVBullet@@@std@@QAEXPAPAVBullet@@ABQAV3@@Z ENDP ; std::allocator<Bullet *>::construct
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVBullet@@@std@@QAEPAPAVBullet@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVBullet@@@std@@QAEPAPAVBullet@@I@Z PROC ; std::allocator<Bullet *>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVBullet@@@std@@YAPAPAVBullet@@IPAPAV1@@Z ; std::_Allocate<Bullet *>
	add	esp, 8

; 592  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVBullet@@@std@@QAEPAPAVBullet@@I@Z ENDP ; std::allocator<Bullet *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVBullet@@@std@@QAEXPAPAVBullet@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVBullet@@@std@@QAEXPAPAVBullet@@I@Z PROC ; std::allocator<Bullet *>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVBullet@@@std@@QAEXPAPAVBullet@@I@Z ENDP ; std::allocator<Bullet *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVBullet@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@PAVBullet@@@std@@QAE@XZ PROC		; std::allocator<Bullet *>::allocator<Bullet *>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAVBullet@@@std@@QAE@XZ ENDP		; std::allocator<Bullet *>::allocator<Bullet *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?renderBullets@Bullet@@SAXXZ
_TEXT	SEGMENT
tv181 = -380						; size = 4
tv177 = -376						; size = 4
tv89 = -376						; size = 4
tv87 = -376						; size = 4
$T2 = -368						; size = 4
$T3 = -356						; size = 4
$T4 = -344						; size = 4
$T5 = -332						; size = 4
$T6 = -320						; size = 12
$T7 = -297						; size = 1
$T8 = -288						; size = 12
_item$9 = -76						; size = 4
_iter$10 = -64						; size = 12
_sucess$11 = -41					; size = 1
_bullet$12 = -32					; size = 4
_i$13 = -20						; size = 4
__$EHRec$ = -12						; size = 12
?renderBullets@Bullet@@SAXXZ PROC			; Bullet::renderBullets, COMDAT

; 181  : 	static void renderBullets(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?renderBullets@Bullet@@SAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 368				; 00000170H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-380]
	mov	ecx, 92					; 0000005cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 182  : 		for(unsigned int i = 0; i < bullets.size(); i++){

	mov	DWORD PTR _i$13[ebp], 0
	jmp	SHORT $LN9@renderBull
$LN8@renderBull:
	mov	eax, DWORD PTR _i$13[ebp]
	add	eax, 1
	mov	DWORD PTR _i$13[ebp], eax
$LN9@renderBull:
	mov	ecx, OFFSET ?bullets@Bullet@@1V?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@A ; Bullet::bullets
	call	?size@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QBEIXZ ; std::vector<Bullet *,std::allocator<Bullet *> >::size
	cmp	DWORD PTR _i$13[ebp], eax
	jae	$LN10@renderBull

; 183  : 			Bullet* bullet = bullets[i];

	mov	eax, DWORD PTR _i$13[ebp]
	push	eax
	mov	ecx, OFFSET ?bullets@Bullet@@1V?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@A ; Bullet::bullets
	call	??A?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAEAAPAVBullet@@I@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _bullet$12[ebp], ecx

; 184  : 			bool sucess = bullet->move(); // bullet cannot move if false

	mov	eax, DWORD PTR _bullet$12[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _bullet$12[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR _sucess$11[ebp], al

; 185  : 			if(!sucess){

	movzx	eax, BYTE PTR _sucess$11[ebp]
	test	eax, eax
	jne	SHORT $LN6@renderBull

; 186  : 				delete bullet;

	mov	eax, DWORD PTR _bullet$12[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN12@renderBull
	mov	esi, esp
	push	1
	mov	edx, DWORD PTR $T4[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T4[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN13@renderBull
$LN12@renderBull:
	mov	DWORD PTR tv87[ebp], 0
$LN13@renderBull:

; 187  : 			}
; 188  : 			else{

	jmp	$LN5@renderBull
$LN6@renderBull:

; 189  : 				for(vector<LivingEntity*>::iterator iter = LivingEntity::livingThings.begin(); iter != LivingEntity::livingThings.end(); iter++){

	lea	eax, DWORD PTR _iter$10[ebp]
	push	eax
	mov	ecx, OFFSET ?livingThings@LivingEntity@@2V?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@A ; LivingEntity::livingThings
	call	?begin@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@XZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::begin
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	jmp	SHORT $LN4@renderBull
$LN3@renderBull:
	push	0
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	lea	ecx, DWORD PTR _iter$10[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator++
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ
$LN4@renderBull:
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	mov	ecx, OFFSET ?livingThings@LivingEntity@@2V?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@A ; LivingEntity::livingThings
	call	?end@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@XZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::end
	mov	DWORD PTR tv89[ebp], eax
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR tv181[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR tv181[ebp]
	push	edx
	lea	ecx, DWORD PTR _iter$10[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator!=
	mov	BYTE PTR $T7[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T8[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T7[ebp]
	test	eax, eax
	je	$LN2@renderBull

; 190  : 					LivingEntity *item = *iter;

	lea	ecx, DWORD PTR _iter$10[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBEAAPAVLivingEntity@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator*
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _item$9[ebp], eax

; 191  : 					if(item->intersects(bullet)){ // player has hit bullet

	mov	eax, DWORD PTR _bullet$12[ebp]
	push	eax
	mov	ecx, DWORD PTR _item$9[ebp]
	call	?intersects@OnScreen@@QAE_NPAV1@@Z	; OnScreen::intersects
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@renderBull

; 192  : 						item->subHealth(bullet->power);

	mov	esi, esp
	mov	eax, DWORD PTR _bullet$12[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _item$9[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _item$9[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 193  : 						delete bullet;

	mov	eax, DWORD PTR _bullet$12[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN14@renderBull
	mov	esi, esp
	push	1
	mov	edx, DWORD PTR $T2[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv177[ebp], eax
	jmp	SHORT $LN15@renderBull
$LN14@renderBull:
	mov	DWORD PTR tv177[ebp], 0
$LN15@renderBull:

; 194  : 						break;

	jmp	SHORT $LN2@renderBull
$LN1@renderBull:

; 195  : 					}

	jmp	$LN3@renderBull
$LN2@renderBull:

; 196  : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _iter$10[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ
$LN5@renderBull:

; 197  : 			}
; 198  : 		}

	jmp	$LN8@renderBull
$LN10@renderBull:

; 199  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN22@renderBull
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 380				; 0000017cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN22@renderBull:
	DD	1
	DD	$LN21@renderBull
$LN21@renderBull:
	DD	-64					; ffffffc0H
	DD	12					; 0000000cH
	DD	$LN19@renderBull
$LN19@renderBull:
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?renderBullets@Bullet@@SAXXZ$0:
	lea	ecx, DWORD PTR _iter$10[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?renderBullets@Bullet@@SAXXZ$2:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?renderBullets@Bullet@@SAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-384]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?renderBullets@Bullet@@SAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?renderBullets@Bullet@@SAXXZ ENDP			; Bullet::renderBullets
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ??1Bullet@@UAE@XZ
_TEXT	SEGMENT
tv173 = -340						; size = 4
tv170 = -340						; size = 4
tv172 = -336						; size = 4
tv75 = -336						; size = 4
$T2 = -328						; size = 12
$T3 = -305						; size = 1
$T4 = -296						; size = 12
$T5 = -276						; size = 4
$T6 = -264						; size = 12
_item$7 = -52						; size = 4
_iter$8 = -40						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1Bullet@@UAE@XZ PROC					; Bullet::~Bullet, COMDAT
; _this$ = ecx

; 171  : 	~Bullet(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1Bullet@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 328				; 00000148H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-340]
	mov	ecx, 82					; 00000052H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Bullet@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 172  : 		for(vector<Bullet*>::iterator iter = bullets.begin(); iter != bullets.end(); iter++){

	lea	eax, DWORD PTR _iter$8[ebp]
	push	eax
	mov	ecx, OFFSET ?bullets@Bullet@@1V?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@A ; Bullet::bullets
	call	?begin@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@XZ ; std::vector<Bullet *,std::allocator<Bullet *> >::begin
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	jmp	SHORT $LN4@Bullet
$LN3@Bullet:
	push	0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _iter$8[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator++
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@XZ
$LN4@Bullet:
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, OFFSET ?bullets@Bullet@@1V?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@A ; Bullet::bullets
	call	?end@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@XZ ; std::vector<Bullet *,std::allocator<Bullet *> >::end
	mov	DWORD PTR tv75[ebp], eax
	mov	ecx, DWORD PTR tv75[ebp]
	mov	DWORD PTR tv170[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR tv170[ebp]
	push	edx
	lea	ecx, DWORD PTR _iter$8[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator!=
	mov	BYTE PTR $T3[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T3[ebp]
	test	eax, eax
	je	SHORT $LN2@Bullet

; 173  : 			OnScreen *item = *iter;

	lea	ecx, DWORD PTR _iter$8[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QBEAAPAVBullet@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Bullet *> > >::operator*
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _item$7[ebp], eax

; 174  : 			if(item == this){

	mov	eax, DWORD PTR _item$7[ebp]
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $LN1@Bullet

; 175  : 				bullets.erase(iter);

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T5[ebp], esp
	lea	eax, DWORD PTR _iter$8[ebp]
	push	eax
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv172[ebp], eax
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	ecx, OFFSET ?bullets@Bullet@@1V?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@A ; Bullet::bullets
	call	?erase@?$vector@PAVBullet@@V?$allocator@PAVBullet@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@2@@Z ; std::vector<Bullet *,std::allocator<Bullet *> >::erase
	mov	DWORD PTR tv173[ebp], eax
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@XZ

; 176  : 				break;

	jmp	SHORT $LN2@Bullet
$LN1@Bullet:

; 177  : 			}

	jmp	$LN3@Bullet
$LN2@Bullet:

; 178  : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _iter$8[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@XZ

; 179  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1OnScreen@@UAE@XZ			; OnScreen::~OnScreen
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@Bullet
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 340				; 00000154H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN16@Bullet:
	DD	1
	DD	$LN15@Bullet
$LN15@Bullet:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN13@Bullet
$LN13@Bullet:
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1Bullet@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OnScreen@@UAE@XZ			; OnScreen::~OnScreen
__unwindfunclet$??1Bullet@@UAE@XZ$1:
	lea	ecx, DWORD PTR _iter$8[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??1Bullet@@UAE@XZ$3:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBullet@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??1Bullet@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-344]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1Bullet@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1Bullet@@UAE@XZ ENDP					; Bullet::~Bullet
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ??0Bullet@@QAE@HW4Directions@@HHH@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_sparg$ = 8						; size = 4
_dir$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_power$ = 24						; size = 4
??0Bullet@@QAE@HW4Directions@@HHH@Z PROC		; Bullet::Bullet, COMDAT
; _this$ = ecx

; 163  : 	Bullet(int sparg, Directions dir, int x, int y, int power = 10){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Bullet@@QAE@HW4Directions@@HHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0OnScreen@@QAE@XZ			; OnScreen::OnScreen
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Bullet@@6B@

; 164  : 		this->speed = sparg;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _sparg$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 165  : 		this->direction = dir;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _dir$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 166  : 		this->location.x = x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 167  : 		this->location.y = y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 168  : 		this->power = power;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _power$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 169  : 		Bullet::addBullet(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?addBullet@Bullet@@KAXPAV1@@Z		; Bullet::addBullet
	add	esp, 4

; 170  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Bullet@@QAE@HW4Directions@@HHH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OnScreen@@UAE@XZ			; OnScreen::~OnScreen
__ehhandler$??0Bullet@@QAE@HW4Directions@@HHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Bullet@@QAE@HW4Directions@@HHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Bullet@@QAE@HW4Directions@@HHH@Z ENDP		; Bullet::Bullet
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?livingThings@LivingEntity@@2V?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@A@@YAXXZ
text$yd	SEGMENT
??__F?livingThings@LivingEntity@@2V?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'LivingEntity::livingThings'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?livingThings@LivingEntity@@2V?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@A ; LivingEntity::livingThings
	call	??1?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE@XZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::~vector<LivingEntity *,std::allocator<LivingEntity *> >
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__F?livingThings@LivingEntity@@2V?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'LivingEntity::livingThings''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ??__E?livingThings@LivingEntity@@2V?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@A@@YAXXZ
text$yc	SEGMENT
??__E?livingThings@LivingEntity@@2V?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@A@@YAXXZ PROC ; `dynamic initializer for 'LivingEntity::livingThings'', COMDAT

; 160  : vector<LivingEntity*> LivingEntity::livingThings;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?livingThings@LivingEntity@@2V?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@A ; LivingEntity::livingThings
	call	??0?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE@XZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::vector<LivingEntity *,std::allocator<LivingEntity *> >
	push	OFFSET ??__F?livingThings@LivingEntity@@2V?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@A@@YAXXZ ; `dynamic atexit destructor for 'LivingEntity::livingThings''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?livingThings@LivingEntity@@2V?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@A@@YAXXZ ENDP ; `dynamic initializer for 'LivingEntity::livingThings''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
$T2 = -244						; size = 4
__Tmp$ = -40						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator++, COMDAT
; _this$ = ecx

; 339  : 		{	// postincrement

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE?AV01@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0

; 340  : 		_Myiter _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 341  : 		++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator++

; 342  : 		return (_Tmp);

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 343  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN9@operator:
	DD	1
	DD	$LN8@operator
$LN8@operator:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN6@operator
$LN6@operator:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE?AV01@H@Z$0:
	lea	ecx, DWORD PTR __Tmp$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE?AV01@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE?AV01@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator++
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator++, COMDAT
; _this$ = ecx

; 333  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 334  : 		++*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator++

; 335  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 336  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBEAAPAVLivingEntity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBEAAPAVLivingEntity@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator*, COMDAT
; _this$ = ecx

; 323  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 324  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBEABQAVLivingEntity@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator*

; 325  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBEAAPAVLivingEntity@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@PAPAVLivingEntity@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@PAPAVLivingEntity@@PBU_Container_base12@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@PAPAVLivingEntity@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >

; 307  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@PAPAVLivingEntity@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVLivingEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVLivingEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::_Compat, COMDAT
; _this$ = ecx

; 236  : 		{	// test for compatible iterator pair

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 237  : 		if (this->_Getcont() == 0
; 238  : 			|| this->_Getcont() != _Right._Getcont())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	test	eax, eax
	je	SHORT $LN1@Compat
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	cmp	esi, eax
	je	$LN3@Compat
$LN1@Compat:

; 239  : 			{	// report error
; 240  : 			_DEBUG_ERROR("vector iterators incompatible");

	mov	esi, esp
	push	240					; 000000f0H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 241  : 			_SCL_SECURE_INVALID_ARGUMENT;

	mov	eax, OFFSET ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
	test	eax, eax
	je	SHORT $LN5@Compat
	xor	ecx, ecx
	jne	SHORT $LN6@Compat
$LN5@Compat:
	mov	esi, esp
	push	OFFSET ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	241					; 000000f1H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@Compat
	int	3
$LN6@Compat:
	mov	esi, esp
	push	0
	push	241					; 000000f1H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1OA@GBDFFJPG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Compat:

; 242  : 			}
; 243  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator!=, COMDAT
; _this$ = ecx

; 209  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 210  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 211  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::_Compat

; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 206  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator++, COMDAT
; _this$ = ecx

; 95   : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	test	eax, eax
	je	SHORT $LN1@operator
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN1@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@operator
$LN1@operator:

; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");

	mov	esi, esp
	push	101					; 00000065H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 102  : 			_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	102					; 00000066H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	102					; 00000066H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1OI@KPIOILEE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 113  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 114  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBEABQAVLivingEntity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBEABQAVLivingEntity@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator*, COMDAT
; _this$ = ecx

; 65   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	test	eax, eax
	je	SHORT $LN1@operator
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN1@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@operator
$LN1@operator:

; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");

	mov	esi, esp
	push	72					; 00000048H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 73   : 			_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	73					; 00000049H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	73					; 00000049H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1OG@OAIFONBP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 87   : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBEABQAVLivingEntity@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@PAPAVLivingEntity@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@PAPAVLivingEntity@@PBU_Container_base12@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@PAPAVLivingEntity@@PBU_Container_base12@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVLivingEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 48   : 		this->_Adopt(_Pvector);

	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 49   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@PAPAVLivingEntity@@PBU_Container_base12@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVLivingEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@PAPAVLivingEntity@@PBU_Container_base12@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@PAPAVLivingEntity@@PBU_Container_base12@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@PAPAVLivingEntity@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVLivingEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVLivingEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z PROC ; std::_Iterator012<std::random_access_iterator_tag,LivingEntity *,int,LivingEntity * const *,LivingEntity * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,LivingEntity *,int,LivingEntity * const *,LivingEntity * const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@ABU01@@Z	; std::_Iterator_base12::_Iterator_base12
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVLivingEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ENDP ; std::_Iterator012<std::random_access_iterator_tag,LivingEntity *,int,LivingEntity * const *,LivingEntity * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,LivingEntity *,int,LivingEntity * const *,LivingEntity * const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVLivingEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVLivingEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,LivingEntity *,int,LivingEntity * const *,LivingEntity * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,LivingEntity *,int,LivingEntity * const *,LivingEntity * const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::~_Iterator_base12
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVLivingEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,LivingEntity *,int,LivingEntity * const *,LivingEntity * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,LivingEntity *,int,LivingEntity * const *,LivingEntity * const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVLivingEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVLivingEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,LivingEntity *,int,LivingEntity * const *,LivingEntity * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,LivingEntity *,int,LivingEntity * const *,LivingEntity * const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::_Iterator_base12
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVLivingEntity@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,LivingEntity *,int,LivingEntity * const *,LivingEntity * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,LivingEntity *,int,LivingEntity * const *,LivingEntity * const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GLivingEntity@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GLivingEntity@@UAEPAXI@Z PROC			; LivingEntity::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1LivingEntity@@UAE@XZ			; LivingEntity::~LivingEntity
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GLivingEntity@@UAEPAXI@Z ENDP			; LivingEntity::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEXPAPAVLivingEntity@@0@Z
_TEXT	SEGMENT
__Pnext$ = -44						; size = 4
__Lock$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEXPAPAVLivingEntity@@0@Z PROC ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1677 : 		{	// orphan iterators within specified (inclusive) range

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Orphan_range@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEXPAPAVLivingEntity@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1678 : 		_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1679 : 		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Pnext$[ebp], eax

; 1680 : 		if (_Pnext != 0)

	cmp	DWORD PTR __Pnext$[ebp], 0
	je	SHORT $LN6@Orphan_ran
$LN5@Orphan_ran:

; 1681 : 			while (*_Pnext != 0)

	mov	eax, DWORD PTR __Pnext$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@Orphan_ran

; 1682 : 				if ((*_Pnext)->_Ptr < _First || _Last < (*_Pnext)->_Ptr)

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR __First$[ebp]
	jb	SHORT $LN2@Orphan_ran
	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Last$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN3@Orphan_ran
$LN2@Orphan_ran:

; 1683 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
	mov	DWORD PTR __Pnext$[ebp], eax

; 1684 : 				else

	jmp	SHORT $LN1@Orphan_ran
$LN3@Orphan_ran:

; 1685 : 					{	// orphan the iterator
; 1686 : 					(*_Pnext)->_Clrcont();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Clrcont@_Iterator_base12@std@@QAEXXZ	; std::_Iterator_base12::_Clrcont

; 1687 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
	mov	ecx, DWORD PTR __Pnext$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
$LN1@Orphan_ran:

; 1688 : 					}

	jmp	SHORT $LN5@Orphan_ran
$LN6@Orphan_ran:

; 1689 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@Orphan_ran
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN13@Orphan_ran:
	DD	1
	DD	$LN12@Orphan_ran
$LN12@Orphan_ran:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN10@Orphan_ran
$LN10@Orphan_ran:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_range@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEXPAPAVLivingEntity@@0@Z$0:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$?_Orphan_range@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEXPAPAVLivingEntity@@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Orphan_range@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEXPAPAVLivingEntity@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Orphan_range@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEXPAPAVLivingEntity@@0@Z ENDP ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Orphan_range
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xlen@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEXXZ PROC ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Xlen, COMDAT
; _this$ = ecx

; 1666 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1667 : 		_Xlength_error("vector<T> too long");

	mov	esi, esp
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Xlen:

; 1668 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEXXZ ENDP ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
?_Tidy@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXXZ PROC ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Tidy, COMDAT
; _this$ = ecx

; 1535 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1536 : 		if (this->_Myfirst != pointer())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN2@Tidy

; 1537 : 			{	// something to free, destroy and deallocate it
; 1538 : 			this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1539 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXPAPAVLivingEntity@@0@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Destroy

; 1540 : 			this->_Getal().deallocate(this->_Myfirst,
; 1541 : 				this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEXPAPAVLivingEntity@@I@Z ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::deallocate

; 1542 : 			this->_Myfirst = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1543 : 			this->_Mylast = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 1544 : 			this->_Myend = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
$LN2@Tidy:

; 1545 : 			}
; 1546 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXXZ ENDP ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z PROC ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Reserve, COMDAT
; _this$ = ecx

; 1525 : 		{	// ensure room for _Count new elements, grow exponentially

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1526 : 		if (_Unused_capacity() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Unused_capacity@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Unused_capacity
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN4@Reserve

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Reserve

; 1529 : 				_Xlen();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEXXZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Xlen
$LN1@Reserve:

; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow_to@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEII@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Grow_to
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reallocate@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Reallocate
$LN4@Reserve:

; 1531 : 			}
; 1532 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Reserve@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z ENDP ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T2 = -273						; size = 1
$T3 = -261						; size = 1
$T4 = -249						; size = 1
__Size$ = -48						; size = 4
__Ptr$ = -36						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z PROC ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1500 : 		{	// move to array of exactly _Count elements

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEPAPAVLivingEntity@@I@Z ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 1502 : 
; 1503 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVLivingEntity@@@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEPAPAVLivingEntity@@PAPAV2@00@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Umove<LivingEntity * *>
	jmp	SHORT $LN5@Reallocate
__catch$?_Reallocate@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z$0:

; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEXPAPAVLivingEntity@@I@Z ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::deallocate

; 1507 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1508 : 		_CATCH_END

	mov	eax, $LN8@Reallocate
	ret	0
$LN5@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Reallocate@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z$1
$LN8@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z$1:

; 1509 : 
; 1510 : 		size_type _Size = size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::size
	mov	DWORD PTR __Size$[ebp], eax

; 1511 : 		if (this->_Myfirst != pointer())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Reallocate

; 1512 : 			{	// destroy and deallocate old array
; 1513 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXPAPAVLivingEntity@@0@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Destroy

; 1514 : 			this->_Getal().deallocate(this->_Myfirst,
; 1515 : 				this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEXPAPAVLivingEntity@@I@Z ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::deallocate
$LN1@Reallocate:

; 1516 : 			}
; 1517 : 
; 1518 : 		this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1519 : 		this->_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1520 : 		this->_Mylast = _Ptr + _Size;

	mov	eax, DWORD PTR __Size$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1521 : 		this->_Myfirst = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN4@Reallocate:

; 1522 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 280				; 00000118H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-284]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z ENDP ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Reallocate
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBE_NPBQAVLivingEntity@@@Z
_TEXT	SEGMENT
tv76 = -208						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBE_NPBQAVLivingEntity@@@Z PROC ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Inside, COMDAT
; _this$ = ecx

; 1495 : 		{	// test if _Ptr points inside vector

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN3@Inside
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN4@Inside
$LN3@Inside:
	mov	DWORD PTR tv76[ebp], 0
$LN4@Inside:
	mov	al, BYTE PTR tv76[ebp]

; 1497 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBE_NPBQAVLivingEntity@@@Z ENDP ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -220						; size = 4
__Capacity$ = -20					; size = 4
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEII@Z PROC ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1484 : 		{	// grow by 50% or at least to _Count

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1485 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN4@Grow_to
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN5@Grow_to
$LN4@Grow_to:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1489 : 		if (_Capacity < _Count)

	mov	eax, DWORD PTR __Capacity$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Grow_to

; 1490 : 			_Capacity = _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to:

; 1491 : 		return (_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]

; 1492 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Grow_to@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEII@Z ENDP ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXPAPAVLivingEntity@@0@Z
_TEXT	SEGMENT
__Alval$ = -17						; size = 1
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXPAPAVLivingEntity@@0@Z PROC ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Destroy, COMDAT
; _this$ = ecx

; 1478 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1479 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Getal

; 1480 : 		_Destroy_range(_First, _Last, _Alval);

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@YAXPAPAVLivingEntity@@0AAU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<LivingEntity *> > >
	add	esp, 12					; 0000000cH

; 1481 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Destroy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN5@Destroy:
	DD	1
	DD	$LN4@Destroy
$LN4@Destroy:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Destroy
$LN3@Destroy:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
?_Destroy@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXPAPAVLivingEntity@@0@Z ENDP ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?erase@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv182 = -248						; size = 4
tv181 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
?erase@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z PROC ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::erase, COMDAT
; _this$ = ecx

; 1356 : 		{	// erase element at where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T3[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $LN1@erase
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+8]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@erase
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR __Where$[ebp+8]
	ja	SHORT $LN2@erase
$LN1@erase:

; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");

	mov	esi, esp
	push	1360					; 00000550H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@erase:

; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));

	mov	eax, DWORD PTR __Where$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+8]
	add	eax, 4
	push	eax
	call	??$_Move@PAPAVLivingEntity@@PAPAV1@@std@@YAPAPAVLivingEntity@@PAPAV1@00@Z ; std::_Move<LivingEntity * *,LivingEntity * *>
	add	esp, 12					; 0000000cH

; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXPAPAVLivingEntity@@0@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Destroy

; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEXPAPAVLivingEntity@@0@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Orphan_range

; 1364 : 		--this->_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1365 : 		return (_Make_iter(_Where));

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	lea	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv181[ebp], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Make_iter
	mov	DWORD PTR tv182[ebp], eax
	mov	edx, DWORD PTR $T3[ebp]
	or	edx, 1
	mov	DWORD PTR $T3[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1366 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z$0:
	lea	ecx, DWORD PTR __Where$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?erase@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z ENDP ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::erase
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEXABQAVLivingEntity@@@Z
_TEXT	SEGMENT
$T1 = -233						; size = 1
$T2 = -221						; size = 1
__Idx$3 = -20						; size = 4
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEXABQAVLivingEntity@@@Z PROC ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::push_back, COMDAT
; _this$ = ecx

; 1184 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1185 : 		if (_Inside(_STD addressof(_Val)))

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@QAVLivingEntity@@@std@@YAPBQAVLivingEntity@@ABQAV1@@Z ; std::addressof<LivingEntity * const>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBE_NPBQAVLivingEntity@@@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@push_back

; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@QAVLivingEntity@@@std@@YAPBQAVLivingEntity@@ABQAV1@@Z ; std::addressof<LivingEntity * const>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2
	mov	DWORD PTR __Idx$3[ebp], eax

; 1188 : 			if (this->_Mylast == this->_Myend)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN3@push_back

; 1189 : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Reserve
$LN3@push_back:

; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEXPAPAVLivingEntity@@0@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Orphan_range

; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Idx$3[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Getal
	mov	ecx, eax
	call	??$construct@PAVLivingEntity@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEXPAPAVLivingEntity@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::construct<LivingEntity *,LivingEntity * &>

; 1193 : 			++this->_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1194 : 			}
; 1195 : 		else

	jmp	SHORT $LN5@push_back
$LN4@push_back:

; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN1@push_back

; 1198 : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXI@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Reserve
$LN1@push_back:

; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IBEXPAPAVLivingEntity@@0@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Orphan_range

; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Getal
	mov	ecx, eax
	call	??$construct@PAVLivingEntity@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEXPAPAVLivingEntity@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::construct<LivingEntity *,LivingEntity * const &>

; 1202 : 			++this->_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN5@push_back:

; 1203 : 			}
; 1204 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEXABQAVLivingEntity@@@Z ENDP ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
?max_size@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ PROC ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::max_size, COMDAT
; _this$ = ecx

; 1091 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1092 : 		return (this->_Getal().max_size());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::max_size

; 1093 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ ENDP ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ PROC ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::size, COMDAT
; _this$ = ecx

; 1086 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1087 : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 1088 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ ENDP ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
$T2 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
?_Make_iter@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z PROC ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Make_iter, COMDAT
; _this$ = ecx

; 1001 : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Make_iter@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1002 : 		return (iterator(_Where._Ptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+8]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@PAPAVLivingEntity@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 1
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1003 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Make_iter@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z$0:
	lea	ecx, DWORD PTR __Where$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?_Make_iter@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Make_iter@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Make_iter@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z ENDP ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Make_iter
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?end@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@XZ PROC ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::end, COMDAT
; _this$ = ecx

; 991  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 992  : 		return (iterator(this->_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@PAPAVLivingEntity@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 993  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@XZ ENDP ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@XZ PROC ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::begin, COMDAT
; _this$ = ecx

; 981  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 982  : 		return (iterator(this->_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@PAPAVLivingEntity@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 983  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@XZ ENDP ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Unused_capacity@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ PROC ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 971  : 		{	// micro-optimization for capacity() - size()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 972  : 		return (this->_Myend - this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+8]
	sar	eax, 2

; 973  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Unused_capacity@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ ENDP ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?capacity@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ PROC ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::capacity, COMDAT
; _this$ = ecx

; 966  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 967  : 		return (this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 968  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ ENDP ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??1?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE@XZ PROC ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::~vector<LivingEntity *,std::allocator<LivingEntity *> >, COMDAT
; _this$ = ecx

; 899  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 900  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@IAEXXZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::_Tidy

; 901  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::~_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE@XZ ENDP ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::~vector<LivingEntity *,std::allocator<LivingEntity *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
??0?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE@XZ PROC ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::vector<LivingEntity *,std::allocator<LivingEntity *> >, COMDAT
; _this$ = ecx

; 685  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@PAVLivingEntity@@@std@@QAE@XZ ; std::allocator<LivingEntity *>::allocator<LivingEntity *>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVLivingEntity@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >

; 686  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE@XZ ENDP ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::vector<LivingEntity *,std::allocator<LivingEntity *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Getal, COMDAT
; _this$ = ecx

; 646  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 647  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::_Wrap_alloc<std::allocator<LivingEntity *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 648  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 635  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 636  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 637  : 			_Alproxy;

	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>

; 638  : 		this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 639  : 		_Alproxy.destroy(this->_Myproxy);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>

; 640  : 		_Alproxy.deallocate(this->_Myproxy, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate

; 641  : 		this->_Myproxy = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 642  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Free_proxy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Free_proxy:
	DD	1
	DD	$LN4@Free_proxy
$LN4@Free_proxy:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Free_proxy
$LN3@Free_proxy:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -228						; size = 8
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 626  : 		{	// construct proxy from _Alval

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 627  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 628  : 			_Alproxy;

	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>

; 629  : 		this->_Myproxy = _Alproxy.allocate(1);

	push	1
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 630  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0_Container_proxy@std@@QAE@XZ		; std::_Container_proxy::_Container_proxy
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>

; 631  : 		this->_Myproxy->_Mycont = this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], edx

; 632  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Alloc_prox
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Alloc_prox:
	DD	1
	DD	$LN4@Alloc_prox
$LN4@Alloc_prox:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Alloc_prox
$LN3@Alloc_prox:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::~_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >, COMDAT
; _this$ = ecx

; 612  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 613  : 		_Free_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Free_proxy

; 614  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::~_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVLivingEntity@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVLivingEntity@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >, COMDAT
; _this$ = ecx

; 606  : 	_Vector_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVLivingEntity@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<LivingEntity *> >::_Vector_val<std::_Simple_types<LivingEntity *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 607  : 		{	// construct allocator from _Al
; 608  : 		_Alloc_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Alloc_proxy

; 609  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVLivingEntity@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVLivingEntity@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVLivingEntity@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVLivingEntity@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >::_Vector_alloc<0,std::_Vec_base_types<LivingEntity *,std::allocator<LivingEntity *> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<LivingEntity *> >::~_Vector_val<std::_Simple_types<LivingEntity *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1_Container_base12@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<LivingEntity *> >::~_Vector_val<std::_Simple_types<LivingEntity *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<LivingEntity *> >::_Vector_val<std::_Simple_types<LivingEntity *> >, COMDAT
; _this$ = ecx

; 484  : 	_Vector_val()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0_Container_base12@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 485  : 		{	// initialize values
; 486  : 		_Myfirst = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 487  : 		_Mylast = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 488  : 		_Myend = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 489  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<LivingEntity *> >::_Vector_val<std::_Simple_types<LivingEntity *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@PAVLivingEntity@@@std@@@std@@SAIABV?$allocator@PAVLivingEntity@@@2@@Z ; std::allocator_traits<std::allocator<LivingEntity *> >::max_size
	add	esp, 4

; 915  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEXPAPAVLivingEntity@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEXPAPAVLivingEntity@@I@Z PROC ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@PAVLivingEntity@@@std@@QAEXPAPAVLivingEntity@@I@Z ; std::allocator<LivingEntity *>::deallocate

; 888  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEXPAPAVLivingEntity@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEPAPAVLivingEntity@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEPAPAVLivingEntity@@I@Z PROC ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@PAVLivingEntity@@@std@@QAEPAPAVLivingEntity@@I@Z ; std::allocator<LivingEntity *>::allocate

; 877  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEPAPAVLivingEntity@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::_Wrap_alloc<std::allocator<LivingEntity *> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@PAVLivingEntity@@@std@@QAE@XZ ; std::allocator<LivingEntity *>::allocator<LivingEntity *>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<LivingEntity *> >::_Wrap_alloc<std::allocator<LivingEntity *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVLivingEntity@@@std@@@std@@SAIABV?$allocator@PAVLivingEntity@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAVLivingEntity@@@std@@@std@@SAIABV?$allocator@PAVLivingEntity@@@2@@Z PROC ; std::allocator_traits<std::allocator<LivingEntity *> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@PAVLivingEntity@@@std@@QBEIXZ ; std::allocator<LivingEntity *>::max_size

; 763  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@PAVLivingEntity@@@std@@@std@@SAIABV?$allocator@PAVLivingEntity@@@2@@Z ENDP ; std::allocator_traits<std::allocator<LivingEntity *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVLivingEntity@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$allocator@PAVLivingEntity@@@std@@QBEIXZ PROC ; std::allocator<LivingEntity *>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 1073741823				; 3fffffffH

; 629  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVLivingEntity@@@std@@QBEIXZ ENDP ; std::allocator<LivingEntity *>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@PAVLivingEntity@@@std@@QAEXPAPAVLivingEntity@@ABQAV3@@Z
_TEXT	SEGMENT
tv68 = -220						; size = 4
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVLivingEntity@@@std@@QAEXPAPAVLivingEntity@@ABQAV3@@Z PROC ; std::allocator<LivingEntity *>::construct, COMDAT
; _this$ = ecx

; 605  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR $T1[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv68[ebp], 0
$LN1@construct:

; 607  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@PAVLivingEntity@@@std@@QAEXPAPAVLivingEntity@@ABQAV3@@Z ENDP ; std::allocator<LivingEntity *>::construct
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVLivingEntity@@@std@@QAEPAPAVLivingEntity@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVLivingEntity@@@std@@QAEPAPAVLivingEntity@@I@Z PROC ; std::allocator<LivingEntity *>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVLivingEntity@@@std@@YAPAPAVLivingEntity@@IPAPAV1@@Z ; std::_Allocate<LivingEntity *>
	add	esp, 8

; 592  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVLivingEntity@@@std@@QAEPAPAVLivingEntity@@I@Z ENDP ; std::allocator<LivingEntity *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVLivingEntity@@@std@@QAEXPAPAVLivingEntity@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVLivingEntity@@@std@@QAEXPAPAVLivingEntity@@I@Z PROC ; std::allocator<LivingEntity *>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVLivingEntity@@@std@@QAEXPAPAVLivingEntity@@I@Z ENDP ; std::allocator<LivingEntity *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVLivingEntity@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@PAVLivingEntity@@@std@@QAE@XZ PROC	; std::allocator<LivingEntity *>::allocator<LivingEntity *>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAVLivingEntity@@@std@@QAE@XZ ENDP	; std::allocator<LivingEntity *>::allocator<LivingEntity *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?isAlive@LivingEntity@@QAE_NXZ
_TEXT	SEGMENT
tv66 = -208						; size = 4
_this$ = -8						; size = 4
?isAlive@LivingEntity@@QAE_NXZ PROC			; LivingEntity::isAlive, COMDAT
; _this$ = ecx

; 150  : 	bool isAlive(){

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 151  : 		return (health>0);

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+16]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@isAlive
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@isAlive
$LN3@isAlive:
	mov	DWORD PTR tv66[ebp], 0
$LN4@isAlive:
	mov	al, BYTE PTR tv66[ebp]

; 152  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?isAlive@LivingEntity@@QAE_NXZ ENDP			; LivingEntity::isAlive
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?subHealth@LivingEntity@@UAEXH@Z
_TEXT	SEGMENT
tv82 = -232						; size = 4
$T1 = -224						; size = 4
$T2 = -212						; size = 4
_this$ = -8						; size = 4
_amount$ = 8						; size = 4
?subHealth@LivingEntity@@UAEXH@Z PROC			; LivingEntity::subHealth, COMDAT
; _this$ = ecx

; 144  : 	virtual void subHealth(int amount){

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		health-=amount;

	cvtsi2ss xmm0, DWORD PTR _amount$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+16]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+16], xmm1

; 146  : 		if(!isAlive()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isAlive@LivingEntity@@QAE_NXZ		; LivingEntity::isAlive
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@subHealth

; 147  : 			delete this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN4@subHealth
	mov	esi, esp
	push	1
	mov	edx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN5@subHealth
$LN4@subHealth:
	mov	DWORD PTR tv82[ebp], 0
$LN5@subHealth:

; 148  : 		}
; 149  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?subHealth@LivingEntity@@UAEXH@Z ENDP			; LivingEntity::subHealth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ??1LivingEntity@@UAE@XZ
_TEXT	SEGMENT
tv165 = -340						; size = 4
tv162 = -340						; size = 4
tv164 = -336						; size = 4
tv75 = -336						; size = 4
$T2 = -328						; size = 12
$T3 = -305						; size = 1
$T4 = -296						; size = 12
$T5 = -276						; size = 4
$T6 = -264						; size = 12
_item$7 = -52						; size = 4
_iter$8 = -40						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1LivingEntity@@UAE@XZ PROC				; LivingEntity::~LivingEntity, COMDAT
; _this$ = ecx

; 135  : 	virtual ~LivingEntity(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1LivingEntity@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 328				; 00000148H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-340]
	mov	ecx, 82					; 00000052H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7LivingEntity@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 136  : 		for(vector<LivingEntity*>::iterator iter = livingThings.begin(); iter != livingThings.end(); iter++){

	lea	eax, DWORD PTR _iter$8[ebp]
	push	eax
	mov	ecx, OFFSET ?livingThings@LivingEntity@@2V?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@A ; LivingEntity::livingThings
	call	?begin@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@XZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::begin
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	jmp	SHORT $LN4@LivingEnti
$LN3@LivingEnti:
	push	0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _iter$8[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator++
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ
$LN4@LivingEnti:
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, OFFSET ?livingThings@LivingEntity@@2V?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@A ; LivingEntity::livingThings
	call	?end@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@XZ ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::end
	mov	DWORD PTR tv75[ebp], eax
	mov	ecx, DWORD PTR tv75[ebp]
	mov	DWORD PTR tv162[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR tv162[ebp]
	push	edx
	lea	ecx, DWORD PTR _iter$8[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator!=
	mov	BYTE PTR $T3[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T3[ebp]
	test	eax, eax
	je	SHORT $LN2@LivingEnti

; 137  : 			LivingEntity *item = *iter;

	lea	ecx, DWORD PTR _iter$8[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QBEAAPAVLivingEntity@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<LivingEntity *> > >::operator*
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _item$7[ebp], eax

; 138  : 			if(item == this){

	mov	eax, DWORD PTR _item$7[ebp]
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $LN1@LivingEnti

; 139  : 				livingThings.erase(iter);

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T5[ebp], esp
	lea	eax, DWORD PTR _iter$8[ebp]
	push	eax
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv164[ebp], eax
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	ecx, OFFSET ?livingThings@LivingEntity@@2V?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@A ; LivingEntity::livingThings
	call	?erase@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@2@@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::erase
	mov	DWORD PTR tv165[ebp], eax
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ

; 140  : 				break;

	jmp	SHORT $LN2@LivingEnti
$LN1@LivingEnti:

; 141  : 			}

	jmp	$LN3@LivingEnti
$LN2@LivingEnti:

; 142  : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _iter$8[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ

; 143  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1OnScreen@@UAE@XZ			; OnScreen::~OnScreen
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@LivingEnti
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 340				; 00000154H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN16@LivingEnti:
	DD	1
	DD	$LN15@LivingEnti
$LN15@LivingEnti:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN13@LivingEnti
$LN13@LivingEnti:
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1LivingEntity@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OnScreen@@UAE@XZ			; OnScreen::~OnScreen
__unwindfunclet$??1LivingEntity@@UAE@XZ$1:
	lea	ecx, DWORD PTR _iter$8[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??1LivingEntity@@UAE@XZ$3:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVLivingEntity@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??1LivingEntity@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-344]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1LivingEntity@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1LivingEntity@@UAE@XZ ENDP				; LivingEntity::~LivingEntity
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ??0LivingEntity@@QAE@XZ
_TEXT	SEGMENT
$T2 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0LivingEntity@@QAE@XZ PROC				; LivingEntity::LivingEntity, COMDAT
; _this$ = ecx

; 132  : 	LivingEntity(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0LivingEntity@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0OnScreen@@QAE@XZ			; OnScreen::OnScreen
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7LivingEntity@@6B@

; 133  : 		livingThings.push_back(this);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, OFFSET ?livingThings@LivingEntity@@2V?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@A ; LivingEntity::livingThings
	call	?push_back@?$vector@PAVLivingEntity@@V?$allocator@PAVLivingEntity@@@std@@@std@@QAEXABQAVLivingEntity@@@Z ; std::vector<LivingEntity *,std::allocator<LivingEntity *> >::push_back

; 134  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0LivingEntity@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1OnScreen@@UAE@XZ			; OnScreen::~OnScreen
__ehhandler$??0LivingEntity@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0LivingEntity@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0LivingEntity@@QAE@XZ ENDP				; LivingEntity::LivingEntity
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__F?visibleItems@OnScreen@@2V?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@A@@YAXXZ
text$yd	SEGMENT
??__F?visibleItems@OnScreen@@2V?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'OnScreen::visibleItems'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?visibleItems@OnScreen@@2V?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@A ; OnScreen::visibleItems
	call	??1?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE@XZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::~vector<OnScreen *,std::allocator<OnScreen *> >
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__F?visibleItems@OnScreen@@2V?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'OnScreen::visibleItems''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ??__E?visibleItems@OnScreen@@2V?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@A@@YAXXZ
text$yc	SEGMENT
??__E?visibleItems@OnScreen@@2V?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@A@@YAXXZ PROC ; `dynamic initializer for 'OnScreen::visibleItems'', COMDAT

; 124  : vector<OnScreen*> OnScreen::visibleItems;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?visibleItems@OnScreen@@2V?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@A ; OnScreen::visibleItems
	call	??0?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE@XZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::vector<OnScreen *,std::allocator<OnScreen *> >
	push	OFFSET ??__F?visibleItems@OnScreen@@2V?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@A@@YAXXZ ; `dynamic atexit destructor for 'OnScreen::visibleItems''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?visibleItems@OnScreen@@2V?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@A@@YAXXZ ENDP ; `dynamic initializer for 'OnScreen::visibleItems''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
$T2 = -244						; size = 4
__Tmp$ = -40						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator++, COMDAT
; _this$ = ecx

; 339  : 		{	// postincrement

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE?AV01@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0

; 340  : 		_Myiter _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 341  : 		++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator++

; 342  : 		return (_Tmp);

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 343  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN9@operator:
	DD	1
	DD	$LN8@operator
$LN8@operator:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN6@operator
$LN6@operator:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE?AV01@H@Z$0:
	lea	ecx, DWORD PTR __Tmp$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE?AV01@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE?AV01@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator++
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator++, COMDAT
; _this$ = ecx

; 333  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 334  : 		++*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator++

; 335  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 336  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBEAAPAVOnScreen@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBEAAPAVOnScreen@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator*, COMDAT
; _this$ = ecx

; 323  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 324  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBEABQAVOnScreen@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator*

; 325  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBEAAPAVOnScreen@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@PAPAVOnScreen@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@PAPAVOnScreen@@PBU_Container_base12@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@PAPAVOnScreen@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >

; 307  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@PAPAVOnScreen@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVOnScreen@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVOnScreen@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::_Compat, COMDAT
; _this$ = ecx

; 236  : 		{	// test for compatible iterator pair

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 237  : 		if (this->_Getcont() == 0
; 238  : 			|| this->_Getcont() != _Right._Getcont())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	test	eax, eax
	je	SHORT $LN1@Compat
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	cmp	esi, eax
	je	$LN3@Compat
$LN1@Compat:

; 239  : 			{	// report error
; 240  : 			_DEBUG_ERROR("vector iterators incompatible");

	mov	esi, esp
	push	240					; 000000f0H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 241  : 			_SCL_SECURE_INVALID_ARGUMENT;

	mov	eax, OFFSET ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
	test	eax, eax
	je	SHORT $LN5@Compat
	xor	ecx, ecx
	jne	SHORT $LN6@Compat
$LN5@Compat:
	mov	esi, esp
	push	OFFSET ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	241					; 000000f1H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@Compat
	int	3
$LN6@Compat:
	mov	esi, esp
	push	0
	push	241					; 000000f1H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1NI@HEJHPDDM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Compat:

; 242  : 			}
; 243  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator!=, COMDAT
; _this$ = ecx

; 209  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 210  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 211  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::_Compat

; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 206  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator++, COMDAT
; _this$ = ecx

; 95   : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	test	eax, eax
	je	SHORT $LN1@operator
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN1@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@operator
$LN1@operator:

; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");

	mov	esi, esp
	push	101					; 00000065H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 102  : 			_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	102					; 00000066H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	102					; 00000066H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1OA@FLOHPEIM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 113  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 114  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBEABQAVOnScreen@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBEABQAVOnScreen@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator*, COMDAT
; _this$ = ecx

; 65   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	test	eax, eax
	je	SHORT $LN1@operator
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN1@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@operator
$LN1@operator:

; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");

	mov	esi, esp
	push	72					; 00000048H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 73   : 			_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	73					; 00000049H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	73					; 00000049H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1NO@JHOOOHOP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 87   : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBEABQAVOnScreen@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@PAPAVOnScreen@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@PAPAVOnScreen@@PBU_Container_base12@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@PAPAVOnScreen@@PBU_Container_base12@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVOnScreen@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 48   : 		this->_Adopt(_Pvector);

	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 49   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@PAPAVOnScreen@@PBU_Container_base12@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVOnScreen@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@PAPAVOnScreen@@PBU_Container_base12@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@PAPAVOnScreen@@PBU_Container_base12@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@PAPAVOnScreen@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVOnScreen@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVOnScreen@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z PROC ; std::_Iterator012<std::random_access_iterator_tag,OnScreen *,int,OnScreen * const *,OnScreen * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,OnScreen *,int,OnScreen * const *,OnScreen * const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@ABU01@@Z	; std::_Iterator_base12::_Iterator_base12
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVOnScreen@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ENDP ; std::_Iterator012<std::random_access_iterator_tag,OnScreen *,int,OnScreen * const *,OnScreen * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,OnScreen *,int,OnScreen * const *,OnScreen * const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVOnScreen@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVOnScreen@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,OnScreen *,int,OnScreen * const *,OnScreen * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,OnScreen *,int,OnScreen * const *,OnScreen * const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::~_Iterator_base12
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVOnScreen@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,OnScreen *,int,OnScreen * const *,OnScreen * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,OnScreen *,int,OnScreen * const *,OnScreen * const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVOnScreen@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVOnScreen@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,OnScreen *,int,OnScreen * const *,OnScreen * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,OnScreen *,int,OnScreen * const *,OnScreen * const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::_Iterator_base12
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVOnScreen@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,OnScreen *,int,OnScreen * const *,OnScreen * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,OnScreen *,int,OnScreen * const *,OnScreen * const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GOnScreen@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GOnScreen@@UAEPAXI@Z PROC				; OnScreen::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1OnScreen@@UAE@XZ			; OnScreen::~OnScreen
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GOnScreen@@UAEPAXI@Z ENDP				; OnScreen::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?move@OnScreen@@MAE_NW4Directions@@H@Z
_TEXT	SEGMENT
tv64 = -208						; size = 4
_this$ = -8						; size = 4
_dir$ = 8						; size = 4
_speed$ = 12						; size = 4
?move@OnScreen@@MAE_NW4Directions@@H@Z PROC		; OnScreen::move, COMDAT
; _this$ = ecx

; 99   : 	virtual bool move(Directions dir, int speed){ // return 0 if couldn't move safely

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		switch(dir){

	mov	eax, DWORD PTR _dir$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	add	ecx, 2
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 4
	ja	SHORT $LN6@move
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN10@move[edx*4]
$LN5@move:

; 101  : 		case Directions::UP:
; 102  : 			location.y-=speed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR _speed$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 103  : 			break;

	jmp	SHORT $LN6@move
$LN4@move:

; 104  : 		case Directions::DOWN:
; 105  : 			location.y+=speed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _speed$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 106  : 			break;

	jmp	SHORT $LN6@move
$LN3@move:

; 107  : 		case Directions::LEFT:
; 108  : 			location.x-=speed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _speed$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 109  : 			break;

	jmp	SHORT $LN6@move
$LN2@move:

; 110  : 		case Directions::RIGHT:
; 111  : 			location.x+=speed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _speed$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN6@move:

; 112  : 			break;
; 113  : 		}
; 114  : 		if(!isInScreenBounds()){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isInScreenBounds@OnScreen@@QAE_NXZ	; OnScreen::isInScreenBounds
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@move

; 115  : 			OnScreen::move(getOppositeDirection(dir), speed);

	mov	eax, DWORD PTR _speed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dir$[ebp]
	push	ecx
	call	?getOppositeDirection@@YA?AW4Directions@@W41@@Z ; getOppositeDirection
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?move@OnScreen@@MAE_NW4Directions@@H@Z	; OnScreen::move

; 116  : 			return false;

	xor	al, al
	jmp	SHORT $LN8@move
$LN1@move:

; 117  : 		}
; 118  : 		return true;

	mov	al, 1
$LN8@move:

; 119  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN10@move:
	DD	$LN4@move
	DD	$LN3@move
	DD	$LN6@move
	DD	$LN2@move
	DD	$LN5@move
?move@OnScreen@@MAE_NW4Directions@@H@Z ENDP		; OnScreen::move
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?intersects@OnScreen@@QAE_NPAV1@@Z
_TEXT	SEGMENT
tv74 = -208						; size = 4
_this$ = -8						; size = 4
_other$ = 8						; size = 4
?intersects@OnScreen@@QAE_NPAV1@@Z PROC			; OnScreen::intersects, COMDAT
; _this$ = ecx

; 95   : 	bool intersects(OnScreen *other){

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 96   : 		return (this->location.x == other->location.x && this->location.y == other->location.y);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _other$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN3@intersects
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _other$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@intersects
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@intersects
$LN3@intersects:
	mov	DWORD PTR tv74[ebp], 0
$LN4@intersects:
	mov	al, BYTE PTR tv74[ebp]

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?intersects@OnScreen@@QAE_NPAV1@@Z ENDP			; OnScreen::intersects
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?getLocation@OnScreen@@QAE?AVPoint@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getLocation@OnScreen@@QAE?AVPoint@@XZ PROC		; OnScreen::getLocation, COMDAT
; _this$ = ecx

; 92   : 	Point getLocation(){

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		return location;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 94   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?getLocation@OnScreen@@QAE?AVPoint@@XZ ENDP		; OnScreen::getLocation
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEXPAPAVOnScreen@@0@Z
_TEXT	SEGMENT
__Pnext$ = -44						; size = 4
__Lock$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEXPAPAVOnScreen@@0@Z PROC ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1677 : 		{	// orphan iterators within specified (inclusive) range

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Orphan_range@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEXPAPAVOnScreen@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1678 : 		_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1679 : 		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Pnext$[ebp], eax

; 1680 : 		if (_Pnext != 0)

	cmp	DWORD PTR __Pnext$[ebp], 0
	je	SHORT $LN6@Orphan_ran
$LN5@Orphan_ran:

; 1681 : 			while (*_Pnext != 0)

	mov	eax, DWORD PTR __Pnext$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@Orphan_ran

; 1682 : 				if ((*_Pnext)->_Ptr < _First || _Last < (*_Pnext)->_Ptr)

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR __First$[ebp]
	jb	SHORT $LN2@Orphan_ran
	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Last$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN3@Orphan_ran
$LN2@Orphan_ran:

; 1683 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
	mov	DWORD PTR __Pnext$[ebp], eax

; 1684 : 				else

	jmp	SHORT $LN1@Orphan_ran
$LN3@Orphan_ran:

; 1685 : 					{	// orphan the iterator
; 1686 : 					(*_Pnext)->_Clrcont();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Clrcont@_Iterator_base12@std@@QAEXXZ	; std::_Iterator_base12::_Clrcont

; 1687 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
	mov	ecx, DWORD PTR __Pnext$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
$LN1@Orphan_ran:

; 1688 : 					}

	jmp	SHORT $LN5@Orphan_ran
$LN6@Orphan_ran:

; 1689 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@Orphan_ran
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN13@Orphan_ran:
	DD	1
	DD	$LN12@Orphan_ran
$LN12@Orphan_ran:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN10@Orphan_ran
$LN10@Orphan_ran:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_range@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEXPAPAVOnScreen@@0@Z$0:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$?_Orphan_range@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEXPAPAVOnScreen@@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Orphan_range@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEXPAPAVOnScreen@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Orphan_range@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEXPAPAVOnScreen@@0@Z ENDP ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Orphan_range
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xlen@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEXXZ PROC ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Xlen, COMDAT
; _this$ = ecx

; 1666 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1667 : 		_Xlength_error("vector<T> too long");

	mov	esi, esp
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Xlen:

; 1668 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEXXZ ENDP ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
?_Tidy@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXXZ PROC ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Tidy, COMDAT
; _this$ = ecx

; 1535 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1536 : 		if (this->_Myfirst != pointer())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN2@Tidy

; 1537 : 			{	// something to free, destroy and deallocate it
; 1538 : 			this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1539 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXPAPAVOnScreen@@0@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Destroy

; 1540 : 			this->_Getal().deallocate(this->_Myfirst,
; 1541 : 				this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAEXPAPAVOnScreen@@I@Z ; std::_Wrap_alloc<std::allocator<OnScreen *> >::deallocate

; 1542 : 			this->_Myfirst = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1543 : 			this->_Mylast = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 1544 : 			this->_Myend = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
$LN2@Tidy:

; 1545 : 			}
; 1546 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXXZ ENDP ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z PROC ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Reserve, COMDAT
; _this$ = ecx

; 1525 : 		{	// ensure room for _Count new elements, grow exponentially

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1526 : 		if (_Unused_capacity() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Unused_capacity@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Unused_capacity
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN4@Reserve

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Reserve

; 1529 : 				_Xlen();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEXXZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Xlen
$LN1@Reserve:

; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow_to@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEII@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Grow_to
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reallocate@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Reallocate
$LN4@Reserve:

; 1531 : 			}
; 1532 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Reserve@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z ENDP ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T2 = -273						; size = 1
$T3 = -261						; size = 1
$T4 = -249						; size = 1
__Size$ = -48						; size = 4
__Ptr$ = -36						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z PROC ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1500 : 		{	// move to array of exactly _Count elements

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAEPAPAVOnScreen@@I@Z ; std::_Wrap_alloc<std::allocator<OnScreen *> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 1502 : 
; 1503 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVOnScreen@@@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEPAPAVOnScreen@@PAPAV2@00@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Umove<OnScreen * *>
	jmp	SHORT $LN5@Reallocate
__catch$?_Reallocate@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z$0:

; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAEXPAPAVOnScreen@@I@Z ; std::_Wrap_alloc<std::allocator<OnScreen *> >::deallocate

; 1507 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1508 : 		_CATCH_END

	mov	eax, $LN8@Reallocate
	ret	0
$LN5@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Reallocate@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z$1
$LN8@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z$1:

; 1509 : 
; 1510 : 		size_type _Size = size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::size
	mov	DWORD PTR __Size$[ebp], eax

; 1511 : 		if (this->_Myfirst != pointer())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Reallocate

; 1512 : 			{	// destroy and deallocate old array
; 1513 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXPAPAVOnScreen@@0@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Destroy

; 1514 : 			this->_Getal().deallocate(this->_Myfirst,
; 1515 : 				this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAEXPAPAVOnScreen@@I@Z ; std::_Wrap_alloc<std::allocator<OnScreen *> >::deallocate
$LN1@Reallocate:

; 1516 : 			}
; 1517 : 
; 1518 : 		this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1519 : 		this->_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1520 : 		this->_Mylast = _Ptr + _Size;

	mov	eax, DWORD PTR __Size$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1521 : 		this->_Myfirst = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN4@Reallocate:

; 1522 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 280				; 00000118H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-284]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z ENDP ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Reallocate
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBE_NPBQAVOnScreen@@@Z
_TEXT	SEGMENT
tv76 = -208						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBE_NPBQAVOnScreen@@@Z PROC ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Inside, COMDAT
; _this$ = ecx

; 1495 : 		{	// test if _Ptr points inside vector

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN3@Inside
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN4@Inside
$LN3@Inside:
	mov	DWORD PTR tv76[ebp], 0
$LN4@Inside:
	mov	al, BYTE PTR tv76[ebp]

; 1497 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBE_NPBQAVOnScreen@@@Z ENDP ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -220						; size = 4
__Capacity$ = -20					; size = 4
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEII@Z PROC ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1484 : 		{	// grow by 50% or at least to _Count

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1485 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN4@Grow_to
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN5@Grow_to
$LN4@Grow_to:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1489 : 		if (_Capacity < _Count)

	mov	eax, DWORD PTR __Capacity$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Grow_to

; 1490 : 			_Capacity = _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to:

; 1491 : 		return (_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]

; 1492 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Grow_to@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEII@Z ENDP ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXPAPAVOnScreen@@0@Z
_TEXT	SEGMENT
__Alval$ = -17						; size = 1
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXPAPAVOnScreen@@0@Z PROC ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Destroy, COMDAT
; _this$ = ecx

; 1478 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1479 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Getal

; 1480 : 		_Destroy_range(_First, _Last, _Alval);

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@YAXPAPAVOnScreen@@0AAU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<OnScreen *> > >
	add	esp, 12					; 0000000cH

; 1481 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Destroy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN5@Destroy:
	DD	1
	DD	$LN4@Destroy
$LN4@Destroy:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Destroy
$LN3@Destroy:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
?_Destroy@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXPAPAVOnScreen@@0@Z ENDP ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?erase@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv182 = -248						; size = 4
tv181 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
?erase@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z PROC ; std::vector<OnScreen *,std::allocator<OnScreen *> >::erase, COMDAT
; _this$ = ecx

; 1356 : 		{	// erase element at where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T3[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $LN1@erase
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+8]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@erase
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR __Where$[ebp+8]
	ja	SHORT $LN2@erase
$LN1@erase:

; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");

	mov	esi, esp
	push	1360					; 00000550H
	push	OFFSET ??_C@_1IM@OHMKGEOK@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@erase:

; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));

	mov	eax, DWORD PTR __Where$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+8]
	add	eax, 4
	push	eax
	call	??$_Move@PAPAVOnScreen@@PAPAV1@@std@@YAPAPAVOnScreen@@PAPAV1@00@Z ; std::_Move<OnScreen * *,OnScreen * *>
	add	esp, 12					; 0000000cH

; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXPAPAVOnScreen@@0@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Destroy

; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEXPAPAVOnScreen@@0@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Orphan_range

; 1364 : 		--this->_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1365 : 		return (_Make_iter(_Where));

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	lea	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv181[ebp], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Make_iter
	mov	DWORD PTR tv182[ebp], eax
	mov	edx, DWORD PTR $T3[ebp]
	or	edx, 1
	mov	DWORD PTR $T3[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1366 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z$0:
	lea	ecx, DWORD PTR __Where$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?erase@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z ENDP ; std::vector<OnScreen *,std::allocator<OnScreen *> >::erase
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAEXABQAVOnScreen@@@Z
_TEXT	SEGMENT
$T1 = -233						; size = 1
$T2 = -221						; size = 1
__Idx$3 = -20						; size = 4
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAEXABQAVOnScreen@@@Z PROC ; std::vector<OnScreen *,std::allocator<OnScreen *> >::push_back, COMDAT
; _this$ = ecx

; 1184 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1185 : 		if (_Inside(_STD addressof(_Val)))

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@QAVOnScreen@@@std@@YAPBQAVOnScreen@@ABQAV1@@Z ; std::addressof<OnScreen * const>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBE_NPBQAVOnScreen@@@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@push_back

; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@QAVOnScreen@@@std@@YAPBQAVOnScreen@@ABQAV1@@Z ; std::addressof<OnScreen * const>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2
	mov	DWORD PTR __Idx$3[ebp], eax

; 1188 : 			if (this->_Mylast == this->_Myend)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN3@push_back

; 1189 : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Reserve
$LN3@push_back:

; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEXPAPAVOnScreen@@0@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Orphan_range

; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Idx$3[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Getal
	mov	ecx, eax
	call	??$construct@PAVOnScreen@@AAPAV1@@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAEXPAPAVOnScreen@@AAPAV2@@Z ; std::_Wrap_alloc<std::allocator<OnScreen *> >::construct<OnScreen *,OnScreen * &>

; 1193 : 			++this->_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1194 : 			}
; 1195 : 		else

	jmp	SHORT $LN5@push_back
$LN4@push_back:

; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN1@push_back

; 1198 : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXI@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Reserve
$LN1@push_back:

; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IBEXPAPAVOnScreen@@0@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Orphan_range

; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Getal
	mov	ecx, eax
	call	??$construct@PAVOnScreen@@ABQAV1@@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAEXPAPAVOnScreen@@ABQAV2@@Z ; std::_Wrap_alloc<std::allocator<OnScreen *> >::construct<OnScreen *,OnScreen * const &>

; 1202 : 			++this->_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN5@push_back:

; 1203 : 			}
; 1204 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAEXABQAVOnScreen@@@Z ENDP ; std::vector<OnScreen *,std::allocator<OnScreen *> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
?max_size@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ PROC ; std::vector<OnScreen *,std::allocator<OnScreen *> >::max_size, COMDAT
; _this$ = ecx

; 1091 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1092 : 		return (this->_Getal().max_size());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<OnScreen *> >::max_size

; 1093 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ ENDP ; std::vector<OnScreen *,std::allocator<OnScreen *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?size@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ PROC ; std::vector<OnScreen *,std::allocator<OnScreen *> >::size, COMDAT
; _this$ = ecx

; 1086 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1087 : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 1088 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ ENDP ; std::vector<OnScreen *,std::allocator<OnScreen *> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
$T2 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
?_Make_iter@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z PROC ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Make_iter, COMDAT
; _this$ = ecx

; 1001 : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Make_iter@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1002 : 		return (iterator(_Where._Ptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+8]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@PAPAVOnScreen@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 1
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1003 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Make_iter@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z$0:
	lea	ecx, DWORD PTR __Where$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?_Make_iter@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Make_iter@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Make_iter@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z ENDP ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Make_iter
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?end@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@XZ PROC ; std::vector<OnScreen *,std::allocator<OnScreen *> >::end, COMDAT
; _this$ = ecx

; 991  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 992  : 		return (iterator(this->_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@PAPAVOnScreen@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 993  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@XZ ENDP ; std::vector<OnScreen *,std::allocator<OnScreen *> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@XZ PROC ; std::vector<OnScreen *,std::allocator<OnScreen *> >::begin, COMDAT
; _this$ = ecx

; 981  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 982  : 		return (iterator(this->_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@PAPAVOnScreen@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 983  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@XZ ENDP ; std::vector<OnScreen *,std::allocator<OnScreen *> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Unused_capacity@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ PROC ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 971  : 		{	// micro-optimization for capacity() - size()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 972  : 		return (this->_Myend - this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+8]
	sar	eax, 2

; 973  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Unused_capacity@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ ENDP ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?capacity@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ PROC ; std::vector<OnScreen *,std::allocator<OnScreen *> >::capacity, COMDAT
; _this$ = ecx

; 966  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 967  : 		return (this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 968  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ ENDP ; std::vector<OnScreen *,std::allocator<OnScreen *> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??1?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE@XZ PROC ; std::vector<OnScreen *,std::allocator<OnScreen *> >::~vector<OnScreen *,std::allocator<OnScreen *> >, COMDAT
; _this$ = ecx

; 899  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 900  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@IAEXXZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::_Tidy

; 901  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::~_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE@XZ ENDP ; std::vector<OnScreen *,std::allocator<OnScreen *> >::~vector<OnScreen *,std::allocator<OnScreen *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
??0?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE@XZ PROC ; std::vector<OnScreen *,std::allocator<OnScreen *> >::vector<OnScreen *,std::allocator<OnScreen *> >, COMDAT
; _this$ = ecx

; 685  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@PAVOnScreen@@@std@@QAE@XZ ; std::allocator<OnScreen *>::allocator<OnScreen *>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVOnScreen@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >

; 686  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE@XZ ENDP ; std::vector<OnScreen *,std::allocator<OnScreen *> >::vector<OnScreen *,std::allocator<OnScreen *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Getal, COMDAT
; _this$ = ecx

; 646  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 647  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<OnScreen *> >::_Wrap_alloc<std::allocator<OnScreen *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 648  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 635  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 636  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 637  : 			_Alproxy;

	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>

; 638  : 		this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 639  : 		_Alproxy.destroy(this->_Myproxy);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>

; 640  : 		_Alproxy.deallocate(this->_Myproxy, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate

; 641  : 		this->_Myproxy = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 642  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Free_proxy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Free_proxy:
	DD	1
	DD	$LN4@Free_proxy
$LN4@Free_proxy:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Free_proxy
$LN3@Free_proxy:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -228						; size = 8
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 626  : 		{	// construct proxy from _Alval

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 627  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 628  : 			_Alproxy;

	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>

; 629  : 		this->_Myproxy = _Alproxy.allocate(1);

	push	1
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 630  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0_Container_proxy@std@@QAE@XZ		; std::_Container_proxy::_Container_proxy
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>

; 631  : 		this->_Myproxy->_Mycont = this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], edx

; 632  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Alloc_prox
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Alloc_prox:
	DD	1
	DD	$LN4@Alloc_prox
$LN4@Alloc_prox:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Alloc_prox
$LN3@Alloc_prox:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::~_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >, COMDAT
; _this$ = ecx

; 612  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 613  : 		_Free_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Free_proxy

; 614  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::~_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVOnScreen@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVOnScreen@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >, COMDAT
; _this$ = ecx

; 606  : 	_Vector_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVOnScreen@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<OnScreen *> >::_Vector_val<std::_Simple_types<OnScreen *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 607  : 		{	// construct allocator from _Al
; 608  : 		_Alloc_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Alloc_proxy

; 609  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVOnScreen@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVOnScreen@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVOnScreen@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVOnScreen@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >::_Vector_alloc<0,std::_Vec_base_types<OnScreen *,std::allocator<OnScreen *> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<OnScreen *> >::~_Vector_val<std::_Simple_types<OnScreen *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1_Container_base12@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<OnScreen *> >::~_Vector_val<std::_Simple_types<OnScreen *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<OnScreen *> >::_Vector_val<std::_Simple_types<OnScreen *> >, COMDAT
; _this$ = ecx

; 484  : 	_Vector_val()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0_Container_base12@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 485  : 		{	// initialize values
; 486  : 		_Myfirst = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 487  : 		_Mylast = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 488  : 		_Myend = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 489  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<OnScreen *> >::_Vector_val<std::_Simple_types<OnScreen *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<OnScreen *> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@PAVOnScreen@@@std@@@std@@SAIABV?$allocator@PAVOnScreen@@@2@@Z ; std::allocator_traits<std::allocator<OnScreen *> >::max_size
	add	esp, 4

; 915  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<OnScreen *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAEXPAPAVOnScreen@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAEXPAPAVOnScreen@@I@Z PROC ; std::_Wrap_alloc<std::allocator<OnScreen *> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@PAVOnScreen@@@std@@QAEXPAPAVOnScreen@@I@Z ; std::allocator<OnScreen *>::deallocate

; 888  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAEXPAPAVOnScreen@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<OnScreen *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAEPAPAVOnScreen@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAEPAPAVOnScreen@@I@Z PROC ; std::_Wrap_alloc<std::allocator<OnScreen *> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@PAVOnScreen@@@std@@QAEPAPAVOnScreen@@I@Z ; std::allocator<OnScreen *>::allocate

; 877  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAEPAPAVOnScreen@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<OnScreen *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<OnScreen *> >::_Wrap_alloc<std::allocator<OnScreen *> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@PAVOnScreen@@@std@@QAE@XZ ; std::allocator<OnScreen *>::allocator<OnScreen *>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@PAVOnScreen@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<OnScreen *> >::_Wrap_alloc<std::allocator<OnScreen *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVOnScreen@@@std@@@std@@SAIABV?$allocator@PAVOnScreen@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAVOnScreen@@@std@@@std@@SAIABV?$allocator@PAVOnScreen@@@2@@Z PROC ; std::allocator_traits<std::allocator<OnScreen *> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@PAVOnScreen@@@std@@QBEIXZ ; std::allocator<OnScreen *>::max_size

; 763  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@PAVOnScreen@@@std@@@std@@SAIABV?$allocator@PAVOnScreen@@@2@@Z ENDP ; std::allocator_traits<std::allocator<OnScreen *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVOnScreen@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$allocator@PAVOnScreen@@@std@@QBEIXZ PROC	; std::allocator<OnScreen *>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 1073741823				; 3fffffffH

; 629  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVOnScreen@@@std@@QBEIXZ ENDP	; std::allocator<OnScreen *>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@PAVOnScreen@@@std@@QAEXPAPAVOnScreen@@ABQAV3@@Z
_TEXT	SEGMENT
tv68 = -220						; size = 4
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVOnScreen@@@std@@QAEXPAPAVOnScreen@@ABQAV3@@Z PROC ; std::allocator<OnScreen *>::construct, COMDAT
; _this$ = ecx

; 605  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR $T1[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv68[ebp], 0
$LN1@construct:

; 607  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@PAVOnScreen@@@std@@QAEXPAPAVOnScreen@@ABQAV3@@Z ENDP ; std::allocator<OnScreen *>::construct
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVOnScreen@@@std@@QAEPAPAVOnScreen@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVOnScreen@@@std@@QAEPAPAVOnScreen@@I@Z PROC ; std::allocator<OnScreen *>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVOnScreen@@@std@@YAPAPAVOnScreen@@IPAPAV1@@Z ; std::_Allocate<OnScreen *>
	add	esp, 8

; 592  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVOnScreen@@@std@@QAEPAPAVOnScreen@@I@Z ENDP ; std::allocator<OnScreen *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVOnScreen@@@std@@QAEXPAPAVOnScreen@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVOnScreen@@@std@@QAEXPAPAVOnScreen@@I@Z PROC ; std::allocator<OnScreen *>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVOnScreen@@@std@@QAEXPAPAVOnScreen@@I@Z ENDP ; std::allocator<OnScreen *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVOnScreen@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@PAVOnScreen@@@std@@QAE@XZ PROC		; std::allocator<OnScreen *>::allocator<OnScreen *>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAVOnScreen@@@std@@QAE@XZ ENDP		; std::allocator<OnScreen *>::allocator<OnScreen *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?isInScreenBounds@OnScreen@@QAE_NXZ
_TEXT	SEGMENT
tv76 = -208						; size = 4
_this$ = -8						; size = 4
?isInScreenBounds@OnScreen@@QAE_NXZ PROC		; OnScreen::isInScreenBounds, COMDAT
; _this$ = ecx

; 87   : 	bool isInScreenBounds(){

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 88   : 		return (this->location.x < NUM_OF_COLS && this->location.y < NUM_OF_ROWS && this->location.x >=0 && this->location.y >= 0);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 45			; 0000002dH
	jge	SHORT $LN3@isInScreen
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 20			; 00000014H
	jge	SHORT $LN3@isInScreen
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jl	SHORT $LN3@isInScreen
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jl	SHORT $LN3@isInScreen
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN4@isInScreen
$LN3@isInScreen:
	mov	DWORD PTR tv76[ebp], 0
$LN4@isInScreen:
	mov	al, BYTE PTR tv76[ebp]

; 89   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?isInScreenBounds@OnScreen@@QAE_NXZ ENDP		; OnScreen::isInScreenBounds
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ??1OnScreen@@UAE@XZ
_TEXT	SEGMENT
tv155 = -340						; size = 4
tv152 = -340						; size = 4
tv154 = -336						; size = 4
tv66 = -336						; size = 4
$T2 = -328						; size = 12
$T3 = -305						; size = 1
$T4 = -296						; size = 12
$T5 = -276						; size = 4
$T6 = -264						; size = 12
_item$7 = -52						; size = 4
_iter$8 = -40						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1OnScreen@@UAE@XZ PROC				; OnScreen::~OnScreen, COMDAT
; _this$ = ecx

; 78   : 	virtual ~OnScreen(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1OnScreen@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 328				; 00000148H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-340]
	mov	ecx, 82					; 00000052H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7OnScreen@@6B@

; 79   : 		for(vector<OnScreen*>::iterator iter = visibleItems.begin(); iter != visibleItems.end(); iter++){

	lea	eax, DWORD PTR _iter$8[ebp]
	push	eax
	mov	ecx, OFFSET ?visibleItems@OnScreen@@2V?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@A ; OnScreen::visibleItems
	call	?begin@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@XZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::begin
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	jmp	SHORT $LN4@OnScreen
$LN3@OnScreen:
	push	0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _iter$8[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator++
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ
$LN4@OnScreen:
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, OFFSET ?visibleItems@OnScreen@@2V?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@A ; OnScreen::visibleItems
	call	?end@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@XZ ; std::vector<OnScreen *,std::allocator<OnScreen *> >::end
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv152[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR tv152[ebp]
	push	edx
	lea	ecx, DWORD PTR _iter$8[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator!=
	mov	BYTE PTR $T3[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T3[ebp]
	test	eax, eax
	je	SHORT $LN2@OnScreen

; 80   : 			OnScreen *item = *iter;

	lea	ecx, DWORD PTR _iter$8[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QBEAAPAVOnScreen@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<OnScreen *> > >::operator*
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _item$7[ebp], eax

; 81   : 			if(item == this){

	mov	eax, DWORD PTR _item$7[ebp]
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $LN1@OnScreen

; 82   : 				visibleItems.erase(iter);

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T5[ebp], esp
	lea	eax, DWORD PTR _iter$8[ebp]
	push	eax
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv154[ebp], eax
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	ecx, OFFSET ?visibleItems@OnScreen@@2V?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@A ; OnScreen::visibleItems
	call	?erase@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@2@@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::erase
	mov	DWORD PTR tv155[ebp], eax
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ

; 83   : 				break;

	jmp	SHORT $LN2@OnScreen
$LN1@OnScreen:

; 84   : 			}

	jmp	$LN3@OnScreen
$LN2@OnScreen:

; 85   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _iter$8[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ

; 86   : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@OnScreen
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 340				; 00000154H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN15@OnScreen:
	DD	1
	DD	$LN14@OnScreen
$LN14@OnScreen:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$LN12@OnScreen
$LN12@OnScreen:
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1OnScreen@@UAE@XZ$0:
	lea	ecx, DWORD PTR _iter$8[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??1OnScreen@@UAE@XZ$2:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVOnScreen@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??1OnScreen@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-344]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1OnScreen@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1OnScreen@@UAE@XZ ENDP				; OnScreen::~OnScreen
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ??0OnScreen@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??0OnScreen@@QAE@XZ PROC				; OnScreen::OnScreen, COMDAT
; _this$ = ecx

; 75   : 	OnScreen(){

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7OnScreen@@6B@

; 76   : 		visibleItems.push_back(this);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, OFFSET ?visibleItems@OnScreen@@2V?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@A ; OnScreen::visibleItems
	call	?push_back@?$vector@PAVOnScreen@@V?$allocator@PAVOnScreen@@@std@@@std@@QAEXABQAVOnScreen@@@Z ; std::vector<OnScreen *,std::allocator<OnScreen *> >::push_back

; 77   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0OnScreen@@QAE@XZ ENDP				; OnScreen::OnScreen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
tv135 = -352						; size = 8
tv341 = -344						; size = 8
tv289 = -340						; size = 4
tv286 = -340						; size = 8
tv284 = -340						; size = 4
tv327 = -336						; size = 8
tv288 = -336						; size = 4
tv283 = -336						; size = 4
tv285 = -332						; size = 4
tv137 = -332						; size = 4
tv287 = -329						; size = 1
tv282 = -329						; size = 1
$T2 = -324						; size = 4
$T3 = -312						; size = 4
$T4 = -300						; size = 4
$T5 = -288						; size = 4
$T6 = -276						; size = 4
__Ok$ = -72						; size = 8
__Pad$ = -56						; size = 8
__Count$ = -40						; size = 8
__State$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 783  : 	{	// insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 336				; 00000150H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-352]
	mov	ecx, 84					; 00000054H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 784  : 	typedef char _Elem;
; 785  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 786  : 	ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 787  : 	streamsize _Count = (streamsize)_Traits::length(_Val);	// may overflow

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	xor	ecx, ecx
	mov	DWORD PTR __Count$[ebp], eax
	mov	DWORD PTR __Count$[ebp+4], ecx

; 788  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
; 789  : 		? 0 : _Ostr.width() - _Count;

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv327[ebp], eax
	mov	DWORD PTR tv327[ebp+4], edx
	cmp	DWORD PTR tv327[ebp+4], 0
	jl	SHORT $LN17@operator
	jg	SHORT $LN24@operator
	cmp	DWORD PTR tv327[ebp], 0
	jbe	SHORT $LN17@operator
$LN24@operator:
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv341[ebp], eax
	mov	DWORD PTR tv341[ebp+4], edx
	mov	eax, DWORD PTR tv341[ebp+4]
	cmp	eax, DWORD PTR __Count$[ebp+4]
	jl	SHORT $LN17@operator
	jg	SHORT $LN25@operator
	mov	ecx, DWORD PTR tv341[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jbe	SHORT $LN17@operator
$LN25@operator:
	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	sub	eax, DWORD PTR __Count$[ebp]
	sbb	edx, DWORD PTR __Count$[ebp+4]
	mov	DWORD PTR tv135[ebp], eax
	mov	DWORD PTR tv135[ebp+4], edx
	jmp	SHORT $LN18@operator
$LN17@operator:
	xorpd	xmm0, xmm0
	movlpd	QWORD PTR tv135[ebp], xmm0
$LN18@operator:
	mov	ecx, DWORD PTR tv135[ebp]
	mov	DWORD PTR __Pad$[ebp], ecx
	mov	edx, DWORD PTR tv135[ebp+4]
	mov	DWORD PTR __Pad$[ebp+4], edx

; 790  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 791  : 
; 792  : 	if (!_Ok)

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBEPQ?$_Bool_struct@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@2@HXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator int std::_Bool_struct<std::basic_ostream<char,std::char_traits<char> > >::*
	cmp	eax, -1
	jne	SHORT $LN14@operator

; 793  : 		_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 794  : 	else

	jmp	$LN13@operator
$LN14@operator:

; 795  : 		{	// state okay, insert
; 796  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 797  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv137[ebp], eax
	mov	eax, DWORD PTR tv137[ebp]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN11@operator

; 798  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	jmp	SHORT $LN10@operator
$LN9@operator:
	mov	eax, DWORD PTR __Pad$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR __Pad$[ebp+4]
	sbb	ecx, 0
	mov	DWORD PTR __Pad$[ebp], eax
	mov	DWORD PTR __Pad$[ebp+4], ecx
$LN10@operator:
	cmp	DWORD PTR __Pad$[ebp+4], 0
	jl	$LN11@operator
	jg	SHORT $LN26@operator
	cmp	DWORD PTR __Pad$[ebp], 0
	jbe	$LN11@operator
$LN26@operator:

; 799  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 800  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv282[ebp], al
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv283[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR tv282[ebp]
	push	eax
	mov	ecx, DWORD PTR tv283[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv284[ebp], eax
	mov	ecx, DWORD PTR tv284[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T3[ebp], eax
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@operator

; 801  : 					{	// insertion failed, quit
; 802  : 					_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 803  : 					break;

	jmp	SHORT $LN11@operator
$LN7@operator:

; 804  : 					}
; 805  : 
; 806  : 		if (_State == ios_base::goodbit

	jmp	$LN9@operator
$LN11@operator:

; 807  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $LN6@operator
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv285[ebp], eax
	mov	esi, esp
	mov	eax, DWORD PTR __Count$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR tv285[ebp]
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv286[ebp], eax
	mov	DWORD PTR tv286[ebp+4], edx
	mov	eax, DWORD PTR tv286[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jne	SHORT $LN27@operator
	mov	ecx, DWORD PTR tv286[ebp+4]
	cmp	ecx, DWORD PTR __Count$[ebp+4]
	je	SHORT $LN6@operator
$LN27@operator:

; 808  : 			_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$LN6@operator:

; 809  : 
; 810  : 		if (_State == ios_base::goodbit)

	cmp	DWORD PTR __State$[ebp], 0
	jne	$LN5@operator

; 811  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	eax, DWORD PTR __Pad$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR __Pad$[ebp+4]
	sbb	ecx, 0
	mov	DWORD PTR __Pad$[ebp], eax
	mov	DWORD PTR __Pad$[ebp+4], ecx
$LN4@operator:
	cmp	DWORD PTR __Pad$[ebp+4], 0
	jl	$LN5@operator
	jg	SHORT $LN28@operator
	cmp	DWORD PTR __Pad$[ebp], 0
	jbe	$LN5@operator
$LN28@operator:

; 812  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 813  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv287[ebp], al
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv288[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR tv287[ebp]
	push	eax
	mov	ecx, DWORD PTR tv288[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv289[ebp], eax
	mov	ecx, DWORD PTR tv289[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T5[ebp], eax
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@operator

; 814  : 					{	// insertion failed, quit
; 815  : 					_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 816  : 					break;

	jmp	SHORT $LN5@operator
$LN1@operator:

; 817  : 					}

	jmp	$LN3@operator
$LN5@operator:

; 818  : 		_Ostr.width(0);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QAE_J_J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN19@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 819  : 		_CATCH_IO_(_Ostr)

	mov	esi, esp
	push	1
	push	4
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, $LN23@operator
	ret	0
$LN19@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN13@operator
$LN23@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN13@operator:

; 820  : 		}
; 821  : 
; 822  : 	_Ostr.setstate(_State);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 823  : 	return (_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T6[ebp]

; 824  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN32@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 352				; 00000160H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN32@operator:
	DD	1
	DD	$LN31@operator
$LN31@operator:
	DD	-72					; ffffffb8H
	DD	8
	DD	$LN29@operator
$LN29@operator:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-356]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
_TEXT	SEGMENT
tv95 = -352						; size = 8
tv278 = -348						; size = 4
tv273 = -348						; size = 4
tv312 = -344						; size = 8
tv277 = -344						; size = 4
tv275 = -344						; size = 4
tv272 = -344						; size = 4
tv274 = -340						; size = 4
tv65 = -340						; size = 4
tv276 = -337						; size = 1
tv271 = -337						; size = 1
$T2 = -332						; size = 4
$T3 = -320						; size = 4
$T4 = -308						; size = 4
$T5 = -296						; size = 4
$T6 = -284						; size = 4
$T7 = -272						; size = 4
$T8 = -260						; size = 4
__Pad$9 = -56						; size = 8
__Ok$ = -40						; size = 8
__State$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Ch$ = 12						; size = 1
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 829  : 	{	// insert a char into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 336				; 00000150H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-352]
	mov	ecx, 84					; 00000054H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 830  : 	typedef char _Elem;
; 831  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 832  : 	ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 833  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 834  : 
; 835  : 	if (_Ok)

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBEPQ?$_Bool_struct@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@2@HXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator int std::_Bool_struct<std::basic_ostream<char,std::char_traits<char> > >::*
	cmp	eax, -1
	je	$LN12@operator

; 836  : 		{	// state okay, insert
; 837  : 		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv312[ebp], eax
	mov	DWORD PTR tv312[ebp+4], edx
	cmp	DWORD PTR tv312[ebp+4], 0
	jg	SHORT $LN15@operator
	jl	SHORT $LN22@operator
	cmp	DWORD PTR tv312[ebp], 1
	ja	SHORT $LN15@operator
$LN22@operator:
	xorpd	xmm0, xmm0
	movlpd	QWORD PTR tv95[ebp], xmm0
	jmp	SHORT $LN16@operator
$LN15@operator:
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	sub	eax, 1
	sbb	edx, 0
	mov	DWORD PTR tv95[ebp], eax
	mov	DWORD PTR tv95[ebp+4], edx
$LN16@operator:
	mov	eax, DWORD PTR tv95[ebp]
	mov	DWORD PTR __Pad$9[ebp], eax
	mov	ecx, DWORD PTR tv95[ebp+4]
	mov	DWORD PTR __Pad$9[ebp+4], ecx

; 838  : 
; 839  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 840  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv65[ebp], eax
	mov	eax, DWORD PTR tv65[ebp]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN10@operator

; 841  : 			for (; _State == ios_base::goodbit && 0 < _Pad;
; 842  : 				--_Pad)	// pad on left

	jmp	SHORT $LN9@operator
$LN8@operator:
	mov	eax, DWORD PTR __Pad$9[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR __Pad$9[ebp+4]
	sbb	ecx, 0
	mov	DWORD PTR __Pad$9[ebp], eax
	mov	DWORD PTR __Pad$9[ebp+4], ecx
$LN9@operator:
	cmp	DWORD PTR __State$[ebp], 0
	jne	$LN10@operator
	cmp	DWORD PTR __Pad$9[ebp+4], 0
	jl	$LN10@operator
	jg	SHORT $LN23@operator
	cmp	DWORD PTR __Pad$9[ebp], 0
	jbe	$LN10@operator
$LN23@operator:

; 843  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 844  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv271[ebp], al
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv272[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR tv271[ebp]
	push	eax
	mov	ecx, DWORD PTR tv272[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv273[ebp], eax
	mov	ecx, DWORD PTR tv273[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T3[ebp], eax
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@operator

; 845  : 					_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$LN6@operator:

; 846  : 
; 847  : 		if (_State == ios_base::goodbit

	jmp	$LN8@operator
$LN10@operator:

; 848  : 			&& _Traits::eq_int_type(_Traits::eof(),
; 849  : 				_Ostr.rdbuf()->sputc(_Ch)))

	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $LN5@operator
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv274[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv274[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv275[ebp], eax
	mov	ecx, DWORD PTR tv275[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T5[ebp], eax
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@operator

; 850  : 			_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$LN5@operator:

; 851  : 
; 852  : 		for (; _State == ios_base::goodbit && 0 < _Pad;
; 853  : 			--_Pad)	// pad on right

	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	eax, DWORD PTR __Pad$9[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR __Pad$9[ebp+4]
	sbb	ecx, 0
	mov	DWORD PTR __Pad$9[ebp], eax
	mov	DWORD PTR __Pad$9[ebp+4], ecx
$LN4@operator:
	cmp	DWORD PTR __State$[ebp], 0
	jne	$LN2@operator
	cmp	DWORD PTR __Pad$9[ebp+4], 0
	jl	$LN2@operator
	jg	SHORT $LN24@operator
	cmp	DWORD PTR __Pad$9[ebp], 0
	jbe	$LN2@operator
$LN24@operator:

; 854  : 			if (_Traits::eq_int_type(_Traits::eof(),
; 855  : 				_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv276[ebp], al
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv277[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR tv276[ebp]
	push	eax
	mov	ecx, DWORD PTR tv277[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv278[ebp], eax
	mov	ecx, DWORD PTR tv278[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T7[ebp], eax
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@operator

; 856  : 				_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$LN1@operator:

; 857  : 		_CATCH_IO_(_Ostr)

	jmp	$LN3@operator
$LN2@operator:
	jmp	SHORT $LN17@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$0:
	mov	esi, esp
	push	1
	push	4
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, $LN21@operator
	ret	0
$LN17@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN12@operator
$LN21@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN12@operator:

; 858  : 		}
; 859  : 
; 860  : 	_Ostr.width(0);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QAE_J_J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 861  : 	_Ostr.setstate(_State);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 862  : 	return (_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR $T8[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T8[ebp]

; 863  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN28@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 352				; 00000160H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN28@operator:
	DD	1
	DD	$LN27@operator
$LN27@operator:
	DD	-40					; ffffffd8H
	DD	8
	DD	$LN25@operator
$LN25@operator:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-356]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\jack\documents\visual studio 2012\projects\battelz\main\source.cpp
;	COMDAT ?getOppositeDirection@@YA?AW4Directions@@W41@@Z
_TEXT	SEGMENT
tv64 = -196						; size = 4
_dir$ = 8						; size = 4
?getOppositeDirection@@YA?AW4Directions@@W41@@Z PROC	; getOppositeDirection, COMDAT

; 44   : Directions getOppositeDirection(Directions dir){

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 45   : 	switch (dir){

	mov	eax, DWORD PTR _dir$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	add	ecx, 2
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 4
	ja	SHORT $LN1@getOpposit
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN10@getOpposit[edx*4]
$LN5@getOpposit:

; 46   : 	case UP:
; 47   : 		return DOWN;

	mov	eax, -2					; fffffffeH
	jmp	SHORT $LN8@getOpposit

; 48   : 		break;

	jmp	SHORT $LN8@getOpposit
$LN4@getOpposit:

; 49   : 	case DOWN:
; 50   : 		return UP;

	mov	eax, 2
	jmp	SHORT $LN8@getOpposit

; 51   : 		break;

	jmp	SHORT $LN8@getOpposit
$LN3@getOpposit:

; 52   : 	case LEFT:
; 53   : 		return RIGHT;

	mov	eax, 1
	jmp	SHORT $LN8@getOpposit

; 54   : 		break;

	jmp	SHORT $LN8@getOpposit
$LN2@getOpposit:

; 55   : 	case RIGHT:
; 56   : 		return LEFT;

	or	eax, -1
	jmp	SHORT $LN8@getOpposit

; 57   : 		break;

	jmp	SHORT $LN8@getOpposit
$LN1@getOpposit:

; 58   : 	default:
; 59   : 		system("cls");

	mov	esi, esp
	push	OFFSET ??_C@_03LCPHGAHP@cls?$AA@
	call	DWORD PTR __imp__system
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 60   : 		cout << "error";

	push	OFFSET ??_C@_05KKCIMGE@error?$AA@
	mov	eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 61   : 		system("pause");

	mov	esi, esp
	push	OFFSET ??_C@_05PDJBBECF@pause?$AA@
	call	DWORD PTR __imp__system
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@getOpposit:

; 62   : 		break;
; 63   : 	}
; 64   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN10@getOpposit:
	DD	$LN4@getOpposit
	DD	$LN3@getOpposit
	DD	$LN1@getOpposit
	DD	$LN2@getOpposit
	DD	$LN5@getOpposit
?getOppositeDirection@@YA?AW4Directions@@W41@@Z ENDP	; getOppositeDirection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
;	COMDAT ?sleep_until@this_thread@std@@YAXPBUxtime@@@Z
_TEXT	SEGMENT
__Now$1 = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
__Abs_time$ = 8						; size = 4
?sleep_until@this_thread@std@@YAXPBUxtime@@@Z PROC	; std::this_thread::sleep_until, COMDAT

; 135  : 	{	// sleep until _Abs_time

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 136  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)

	mov	esi, esp
	call	DWORD PTR __imp_?_Id@_CurrentScheduler@details@Concurrency@@SAIXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, -1
	je	SHORT $LN1@sleep_unti

; 137  : 		{
; 138  : 		stdext::threads::xtime _Now;
; 139  : 		stdext::threads::xtime_get(&_Now, stdext::threads::TIME_UTC);

	mov	esi, esp
	push	1
	lea	eax, DWORD PTR __Now$1[ebp]
	push	eax
	call	DWORD PTR __imp__xtime_get
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 140  : 		::Concurrency::wait(_Xtime_diff_to_millis2(_Abs_time, &_Now));

	mov	esi, esp
	lea	eax, DWORD PTR __Now$1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Abs_time$[ebp]
	push	ecx
	call	DWORD PTR __imp___Xtime_diff_to_millis2
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp_?wait@Concurrency@@YAXI@Z
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 141  : 		return;

	jmp	SHORT $LN2@sleep_unti
$LN1@sleep_unti:

; 142  : 		}
; 143  : 
; 144  : 	_Thrd_sleep(_Abs_time);

	mov	esi, esp
	mov	eax, DWORD PTR __Abs_time$[ebp]
	push	eax
	call	DWORD PTR __imp___Thrd_sleep
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@sleep_unti:

; 145  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@sleep_unti
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@sleep_unti:
	DD	1
	DD	$LN5@sleep_unti
$LN5@sleep_unti:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN4@sleep_unti
$LN4@sleep_unti:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	0
?sleep_until@this_thread@std@@YAXPBUxtime@@@Z ENDP	; std::this_thread::sleep_until
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$yc	SEGMENT
$T1 = -197						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 137  : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$yc	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 130  : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\tuple
;	COMDAT ??0_Ignore@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Ignore@std@@QAE@XZ PROC				; std::_Ignore::_Ignore, COMDAT
; _this$ = ecx

; 120  : 	_Ignore()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct
; 122  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Ignore@std@@QAE@XZ ENDP				; std::_Ignore::_Ignore
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??$?0_J@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?0_J@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64>, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from representation

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0_J@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ PROC ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch, COMDAT
; _this$ = ecx

; 271  : 		{	// get duration from epoch

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 272  : 		return (_MyDur);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 273  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ ENDP ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Other$ = 8						; size = 4
??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z PROC ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >, COMDAT
; _this$ = ecx

; 259  : 		{	// construct from a duration

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Other$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 260  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ENDP ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count, COMDAT
; _this$ = ecx

; 130  : 		{	// get stored rep

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 131  : 		return (_MyRep);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+4]

; 132  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
;	COMDAT ?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ
_TEXT	SEGMENT
$T1 = -220						; size = 8
$T2 = -204						; size = 8
___$ReturnUdt$ = 8					; size = 4
?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ PROC ; std::chrono::system_clock::now, COMDAT

; 705  : 		{	// get current time

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 706  : 		return (time_point(duration(_Xtime_get_ticks())));

	mov	esi, esp
	call	DWORD PTR __imp___Xtime_get_ticks
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR $T2[ebp+4], edx
	push	0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	??$?0_J@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_JPAPAX@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64>
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 707  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ENDP ; std::chrono::system_clock::now
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
;	COMDAT _time
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC						; COMDAT

; 132  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 133  :     return _time64(_Time);

	mov	esi, esp
	mov	eax, DWORD PTR __Time$[ebp]
	push	eax
	call	DWORD PTR __imp___time64
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 134  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	esi, esp
	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	DWORD PTR __imp_?_Syserror_map@std@@YAPBDH@Z
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
tv69 = -232						; size = 4
$T1 = -224						; size = 4
__Name$ = -20						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	esi, esp
	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	DWORD PTR __imp_?_Winerror_map@std@@YAPBDH@Z
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	eax, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	ecx, DWORD PTR tv69[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	edx, DWORD PTR $T1[ebp]
	or	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	edx, DWORD PTR $T1[ebp]
	or	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
tv69 = -232						; size = 4
$T1 = -224						; size = 4
__Name$ = -20						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	esi, esp
	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	DWORD PTR __imp_?_Syserror_map@std@@YAPBDH@Z
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	eax, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	ecx, DWORD PTR tv69[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	edx, DWORD PTR $T1[ebp]
	or	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv65 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
tv74 = -208						; size = 4
_this$ = -8						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -216						; size = 8
_this$ = -8						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	esi, esp
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__File$ = 12						; size = 4
__Line$ = 16						; size = 4
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z PROC		; std::_Debug_pointer<char>, COMDAT

; 610  : 	{	// test iterator for non-singularity, const pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 611  : 	if (_First == 0)

	cmp	DWORD PTR __First$[ebp], 0
	jne	SHORT $LN2@Debug_poin

; 612  : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Debug_poin:

; 613  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ENDP		; std::_Debug_pointer<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	mov	esi, esp
	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Xran:

; 2277 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	mov	esi, esp
	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Xlen:

; 2272 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
$T1 = -233						; size = 1
$T2 = -221						; size = 1
__Ptr$3 = -20						; size = 4
_this$ = -8						; size = 4
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Ptr$3[ebp], ecx

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$3[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$3[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -208						; size = 4
tv129 = -208						; size = 4
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	eax, BYTE PTR __Trim$[ebp]
	test	eax, eax
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+20], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -288						; size = 4
tv203 = -288						; size = 4
tv204 = -284						; size = 4
tv202 = -284						; size = 4
$T2 = -273						; size = 1
$T3 = -261						; size = 1
$T4 = -249						; size = 1
__Ptr$ = -48						; size = 4
__Newres$ = -36						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+24]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	shr	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR __Newres$[ebp], ecx

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	edx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 2213 : 		_Eos(_Oldlen);

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN23@Copy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN23@Copy:
	DD	1
	DD	$LN22@Copy
$LN22@Copy:
	DD	-48					; ffffffd0H
	DD	4
	DD	$LN20@Copy
$LN20@Copy:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-292]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv75 = -232						; size = 4
$T1 = -221						; size = 1
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	eax, DWORD PTR __Num$[ebp]
	sub	eax, 1
	mov	DWORD PTR tv75[ebp], eax
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 1734 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1717 : 		{	// return pointer to null-terminated nonmutable array

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1718 : 		return (this->_Myptr());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 1719 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -32					; size = 4
__Ptr$2 = -20						; size = 4
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR __Off$[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], ecx

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	eax, DWORD PTR __Newsize$1[ebp]
	sub	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$2[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	push	edx
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	eax, DWORD PTR __Newsize$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);

	push	1143					; 00000477H
	push	OFFSET ??_C@_1IO@DBKIKIHF@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z	; std::_Debug_pointer<char>
	add	esp, 12					; 0000000cH

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)

	cmp	DWORD PTR __Count$[ebp], 0
	je	SHORT $LN3@assign

; 1126 : 			_DEBUG_POINTER(_Ptr);

	push	1126					; 00000466H
	push	OFFSET ??_C@_1IO@DBKIKIHF@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z	; std::_Debug_pointer<char>
	add	esp, 12					; 0000000cH
$LN3@assign:

; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN4@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN4@assign:

; 1139 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -20						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], eax
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1098 : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1099 : 		return (assign(_Right, 0, npos));

	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	eax
	push	0
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1100 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T1 = -233						; size = 1
$T2 = -221						; size = 1
$T3 = -209						; size = 1
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 970  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 971  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN2@operator

; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	push	eax
	call	??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::operator!=<std::allocator<char>,std::allocator<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@operator
	xor	eax, eax
	je	SHORT $LN1@operator

; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 978  : 				this->_Change_alloc(_Right._Getal());

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Change_alloc
$LN1@operator:

; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@operator:

; 983  : 			}
; 984  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 985  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 963  : 		{	// destroy the string

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 964  : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 965  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 749  : 		{	// construct empty string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 750  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 751  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T2 = -233						; size = 1
$T3 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 733  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 734  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 735  : 		assign(_Right, 0, npos);

	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	eax
	push	0
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 736  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 677  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 678  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 679  : 			_Alproxy;

	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>

; 680  : 		this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 681  : 		_Alproxy.destroy(this->_Myproxy);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>

; 682  : 		_Alproxy.deallocate(this->_Myproxy, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate

; 683  : 		this->_Myproxy = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 684  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Free_proxy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Free_proxy:
	DD	1
	DD	$LN4@Free_proxy
$LN4@Free_proxy:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Free_proxy
$LN3@Free_proxy:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -228						; size = 8
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 668  : 		{	// construct proxy from _Alval

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 669  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 670  : 			_Alproxy;

	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>

; 671  : 		this->_Myproxy = _Alproxy.allocate(1);

	push	1
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 672  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0_Container_proxy@std@@QAE@XZ		; std::_Container_proxy::_Container_proxy
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>

; 673  : 		this->_Myproxy->_Mycont = this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], edx

; 674  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Alloc_prox
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Alloc_prox:
	DD	1
	DD	$LN4@Alloc_prox
$LN4@Alloc_prox:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Alloc_prox
$LN3@Alloc_prox:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Change_alloc, COMDAT
; _this$ = ecx

; 659  : 		{	// replace old allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 660  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Change_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 654  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 655  : 		_Free_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 656  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 648  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 649  : 		{	// construct allocator from _Al
; 650  : 		_Alloc_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy

; 651  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
__ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1_Container_base12@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -208						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -208						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0_Container_base12@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 499  : 		_Myres = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 835  : 		{	// construct by copying base

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>

; 836  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ PROC ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 806  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 807  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 808  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 767  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 768  : 		return (_Al.select_on_container_copy_construction());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ ; std::allocator<char>::select_on_container_copy_construction
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 769  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 569  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 570  : 		{	// construct by copying (do nothing)
; 571  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ PROC ; std::allocator<char>::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 544  : 		{	// return this allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 545  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 546  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ ENDP ; std::allocator<char>::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -197						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
_TEXT	SEGMENT
__Pnext$1 = -20						; size = 4
_this$ = -8						; size = 4
?_Orphan_me@_Iterator_base12@std@@QAEXXZ PROC		; std::_Iterator_base12::_Orphan_me, COMDAT
; _this$ = ecx

; 187  : 		{	// cut ties with parent

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 188  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 189  : 		if (_Myproxy != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Orphan_me

; 190  : 			{	// adopted, remove self from list
; 191  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$1[ebp], ecx
$LN3@Orphan_me:

; 192  : 			while (*_Pnext != 0 && *_Pnext != this)

	mov	eax, DWORD PTR __Pnext$1[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Orphan_me
	mov	eax, DWORD PTR __Pnext$1[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _this$[ebp]
	je	SHORT $LN2@Orphan_me

; 193  : 				_Pnext = &(*_Pnext)->_Mynextiter;

	mov	eax, DWORD PTR __Pnext$1[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$1[ebp], ecx
	jmp	SHORT $LN3@Orphan_me
$LN2@Orphan_me:

; 194  : 
; 195  : 			if (*_Pnext == 0)

	mov	eax, DWORD PTR __Pnext$1[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN1@Orphan_me

; 196  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");

	mov	esi, esp
	push	196					; 000000c4H
	push	OFFSET ??_C@_1JA@NLMHOKKJ@?$AAe?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@Orphan_me:

; 197  : 			*_Pnext = _Mynextiter;

	mov	eax, DWORD PTR __Pnext$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 198  : 			_Myproxy = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN5@Orphan_me:

; 199  : 			}
; 200  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 201  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Orphan_me@_Iterator_base12@std@@QAEXXZ ENDP		; std::_Iterator_base12::_Orphan_me
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ PROC	; std::_Iterator_base12::_Getpnext, COMDAT
; _this$ = ecx

; 182  : 		{	// get address of remaining iterator chain

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 183  : 		return (&_Mynextiter);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4

; 184  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ENDP	; std::_Iterator_base12::_Getpnext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
_TEXT	SEGMENT
tv68 = -208						; size = 4
_this$ = -8						; size = 4
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT
; _this$ = ecx

; 177  : 		{	// get owning container

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@Getcont
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@Getcont
$LN3@Getcont:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv68[ebp], eax
$LN4@Getcont:
	mov	eax, DWORD PTR tv68[ebp]

; 179  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Clrcont@_Iterator_base12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Clrcont@_Iterator_base12@std@@QAEXXZ PROC		; std::_Iterator_base12::_Clrcont, COMDAT
; _this$ = ecx

; 172  : 		{	// disown owning container

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 173  : 		_Myproxy = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 174  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Clrcont@_Iterator_base12@std@@QAEXXZ ENDP		; std::_Iterator_base12::_Clrcont
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
__Lock$2 = -56						; size = 4
__Parent_proxy$3 = -44					; size = 4
__Lock$4 = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parent$ = 8						; size = 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT
; _this$ = ecx

; 145  : 		{	// adopt this iterator by parent

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 146  : 		if (_Parent == 0)

	cmp	DWORD PTR __Parent$[ebp], 0
	jne	SHORT $LN3@Adopt

; 147  : 			{	// no future parent, just disown current parent
; 148  : 			_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 149  : 			_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 150  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 151  : 		else

	jmp	SHORT $LN4@Adopt
$LN3@Adopt:

; 152  : 			{	// have a parent, do adoption
; 153  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;

	mov	eax, DWORD PTR __Parent$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Parent_proxy$3[ebp], ecx

; 154  : 
; 155  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 156  : 			if (_Myproxy != _Parent_proxy)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Parent_proxy$3[ebp]
	je	SHORT $LN4@Adopt

; 157  : 				{	// change parentage
; 158  : 				_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 159  : 				_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 160  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parent_proxy$3[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 161  : 				_Parent_proxy->_Myfirstiter = this;

	mov	eax, DWORD PTR __Parent_proxy$3[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 162  : 				_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parent_proxy$3[ebp]
	mov	DWORD PTR [eax], ecx

; 163  : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@Adopt:

; 164  : 
; 165  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 166  : 			_Myproxy = _Parent_proxy;
; 167  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 168  : 			}
; 169  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@Adopt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN12@Adopt:
	DD	2
	DD	$LN11@Adopt
$LN11@Adopt:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN8@Adopt
	DD	-56					; ffffffc8H
	DD	4
	DD	$LN9@Adopt
$LN9@Adopt:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
$LN8@Adopt:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??1_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$ = -20						; size = 4
_this$ = -8						; size = 4
??1_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT
; _this$ = ecx

; 137  : 		{	// destroy the iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 138  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 139  : 		_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 140  : 		_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 141  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 142  : 		}

	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iterator_b
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN5@Iterator_b:
	DD	1
	DD	$LN4@Iterator_b
$LN4@Iterator_b:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN3@Iterator_b
$LN3@Iterator_b:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
??1_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
__Lock$2 = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z PROC		; std::_Iterator_base12::operator=, COMDAT
; _this$ = ecx

; 123  : 		{	// assign an iterator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN4@operator
	jmp	SHORT $LN3@operator
$LN4@operator:

; 125  : 			;
; 126  : 		else if (_Right._Myproxy != 0)

	mov	eax, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@operator

; 127  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 128  : 		else

	jmp	SHORT $LN3@operator
$LN2@operator:

; 129  : 			{	// becoming invalid, disown current parent
; 130  : 			_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 131  : 			_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 132  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@operator:

; 133  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 134  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN11@operator:
	DD	1
	DD	$LN10@operator
$LN10@operator:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN8@operator
$LN8@operator:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ENDP		; std::_Iterator_base12::operator=
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??0_Iterator_base12@std@@QAE@ABU01@@Z PROC		; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 118  : 		{	// copy an iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 119  : 		*this = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=

; 120  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Iterator_base12@std@@QAE@ABU01@@Z ENDP		; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 113  : 		{	// construct orphaned iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 114  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??0_Container_proxy@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Container_proxy@std@@QAE@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 67   : 		{	// construct from pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 68   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_proxy@std@@QAE@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -197						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 604  : 		{	// return end-of-file metacharacter

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 605  : 		return (EOF);

	or	eax, -1

; 606  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
tv65 = -196						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 593  : 		{	// test for metacharacter equality

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 594  : 		return (_Left == _Right);

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@eq_int_typ
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
	mov	DWORD PTR tv65[ebp], 0
$LN4@eq_int_typ:
	mov	al, BYTE PTR tv65[ebp]

; 595  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	esi, esp
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -196						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 65   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File e:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
END
